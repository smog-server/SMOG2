use strict;
use warnings;
use List::Util qw(max);
use Getopt::Long;

print <<EOT;
*****************************************************************************************
                                      smog_extract

      	smog_extract is part of the SMOG 2 distribution, available at smog-server.org

        This tool uses a SMOG .top and .gro file, along with an atomlist file to 
	generate a SMOG model that only includes a subset of the original atoms. This 
	allows one to generate a SMOG model for a large system, and then simulate the 
	subset of atoms using identical interactions. In addition, the module will 
	optionally generate atomic restraints for any atom that has interactions 
	removed	during the truncation step.

        For usage information, issue flag -help, or see the SMOG manual.

        For questions regarding this script, contact info\@smog-server.org

*****************************************************************************************
EOT

sub smog_quit
{
        my ($LINE)=@_;
        if($main::noexit){
                warn("\nWarning: $LINE\n");
        }else{
                print "\n\nFATAL ERROR:  $LINE\n\nFor more information about specific errors, you can check the FAQ page on smog-server.org,\nthe SMOG2 manual, or you can email us at info\@smog-server.org. \n\nNOTE: For diagnostic purposes, you can try to ignore the error by providing the flag -warnonly.\n      This will allow smog_extract to proceed as far as possible before exiting.\n      However, it is not recommended that top files generated with this flag be used for an actual simulation.\n";
                exit;
        }
}

sub usage
{
  print <<EOT;

usage: smog_extract  [-f .top file] [-g .gro file] [-of output .top file] [-og output .gro file] [-om output index mapping file] [-help|-?]

   Required Input
	-f [smog.top]: Input SMOG forcefield file
	-g [smog.gro]: Input SMOG configuration file
	-n [smog.include]: List of atoms to extract
   Optional Input/Output parameters
	-of [extracted.top]: Output SMOG forcefield file for extracted system
	-og [extracted.gro]: Output SMOG configuration file for extracted system
	-om [atomindex.map]: Output file with old-to-new atom index mapping
	-restraints <restraint weight>: Generate restraints with a specific strength for atoms 
                                        that have interactions removed during extraction
EOT
  if ( @_ ){
   smog_quit("Command-line argument \"@_\" not recognized.");
  }else{
   exit;
  }
}


my $inputTOP="smog.top";
my $inputGRO="smog.gro";
my $indexFile="smog.include";
my $outputtop="extracted.top";
my $outputgro="extracted.gro";
my $outputmap="atomindex.map";
my $help;
my $gen_restraints=0;
my $warnonly=0;
our $noexit=0;
usage() if (@ARGV < 1 || !GetOptions('help|?' => \$help, 'f=s' => \$inputTOP, 'g=s' => \$inputGRO, 'n=s' => \$indexFile, 
        'of=s' => \$outputtop, 'og=s' => \$outputgro, 'om=s' => \$outputmap, 'restraints=s' => \$gen_restraints,  'warnonly' => \$warnonly, 
        '<>' => \&usage)
        or defined $help); 

if($warnonly){
	$noexit=1;
	print "\n\n-warnonly selected.  Will not intentionally exit when an error is encountered.\nThis can lead to program instability, which may still result in a crash.\nBe cautious, ignoring errors can lead to unpredictable results. \n ONLY use this option if you are sure the error is harmless.\n\n";
}else{
	$noexit=0;
}

unless ($gen_restraints =~ m/^\d+\.\d+$/ ||  $gen_restraints =~ m/^\d+$/ || $gen_restraints eq 0){
	smog_quit("-restraints given with a non-numerical value: $gen_restraints");
}

### read in the list of atoms that we want to keep
my %keepatoms;
my $KEEPN=0;
my @keepatoms2;
open(ATOMLIST,"$indexFile") or die "\nCan\'t open $indexFile. Use --help for usage guidelines.\n\nExtract Incomplete!\n\n";

#check and add file name extensions, if missing
my ($ext)= $outputgro =~ /(\.[^.]+)$/;
if(!defined $ext || $ext ne ".gro"){
	$outputgro .=  ".gro";
}
($ext)= $outputtop =~ /(\.[^.]+)$/;
if(!defined $ext || $ext ne ".top"){
	$outputtop .=  ".top";
}
($ext)= $outputmap =~ /(\.[^.]+)$/;
if(!defined $ext || $ext ne ".map"){
	$outputmap .=  ".map";
}

if(-e $outputmap){smog_quit("$outputmap already exists.")};
open(MAPPING,">$outputmap") or die "\nCan\'t open $outputmap. Use --help for usage guidelines.\n\nExtract Incomplete!\n\n";
print MAPPING "This file contains the corresponding atom indices for the new (left column) and old (right column) systems.\n";
while(<ATOMLIST>){
	my $LINE=$_;
	chomp($LINE);
	# remove comments first
	$LINE =~ s/;.*$//g; 
	$LINE =~ s/^\s+|\s+$//g;
	$LINE =~ s/\s+|\t+/ /g;
	my @A=split(/ /,$LINE);
	for(my $I=0;$I<=$#A;$I++){
		unless($A[$I] =~ m/^\d+$/){
			smog_quit("Non-numerical value for atom number in index file: $A[$I]");
		}
		if(exists $keepatoms{$A[$I]}){
			smog_quit("Duplicate atom in atomlist: $A[$I]");
		}else{
			$keepatoms{$A[$I]}=$KEEPN+1;
			$keepatoms2[$KEEPN]=$A[$I];
			if($KEEPN > 0 && $keepatoms2[$KEEPN] < $keepatoms2[$KEEPN-1]){
				smog_quit("Atoms listed in $indexFile are not in ascending order.\n");
			}
			$KEEPN++;
			print MAPPING "$KEEPN $A[$I]\n";
		}
	}
}

close(ATOMLIST);

### extract the atoms and make a new gro file 

open(GROFILE,"$inputGRO") or die "Can\'t open GRO file \"$inputGRO\"\n";
my $groheader=<GROFILE>;
chomp($groheader);

my $TMP=<GROFILE>;
chomp($TMP);
$TMP =~ s/\t/ /g; 
$TMP =~ s/^\s+|\s+$//g;
$TMP =~ s/ +/ /g;
my @A=split(/\s+/,$TMP);
my $NATOMS=$A[0];
my @GRODATA;
unless($NATOMS =~ m/^\d+/){smog_quit("Number of atoms on line 2 of gro file ($NATOMS), is not an integer.")}

for(my $I=0;$I<$NATOMS;$I++){
	# store gro data
	my $LINE=<GROFILE>;
	chomp($LINE);
	$GRODATA[$I+1]=$LINE;
}
my $grodim=<GROFILE>;
chomp($grodim);
close(GROFILE);

if(-e $outputgro){smog_quit("$outputgro already exists.")};
open(GROFILE,">$outputgro") or die "Can\'t open output GRO file \"$outputgro\"\n";
print GROFILE "$groheader\n";
print GROFILE "$KEEPN\n";
for(my $I=0;$I<$KEEPN;$I++){
	if(!exists $GRODATA[$keepatoms2[$I]]){
		smog_quit("Atom index $I given in include list, but not found in $inputGRO");
	}
	print GROFILE "$GRODATA[$keepatoms2[$I]]\n";
}
print GROFILE "$grodim\n";

print "\n\nUsing $inputTOP, $inputGRO and $indexFile to generate extracted system...\n\n";

my %supported_directives = ( 'defaults' => '0',
        'atomtypes' => '1',
        'moleculetype' => '0',
        'atoms' => '1',
        'bonds' => '1',
        'angles' => '1',
        'dihedrals' => '1',
        'pairs' => '1',
        'exclusions' => '1',
        'system' => '1',
        'molecules' => '1',
        'position_restraints' => '1'
        );

my %atoms2restrain;
#read in the top file, with comments stripped
open(FILE, "$inputTOP") or die "Can not open $inputTOP\n"; 
my $string = "";
while (<FILE>){
	my $LINE = $_;
	chomp($LINE);
	$LINE =~ s/;.*$//g; 
	$LINE =~ s/\t/ /g; 
	$LINE =~ s/^\s+|\s+$//g;
	$LINE =~ s/ +/ /g;
	if( $LINE =~ m/[#!\^\$]/ ){
		smog_quit("Special characters not recognized in .top file\n  Offending line: $LINE\n");
	}
	# remove comments
	if($LINE ne ""){ 
	## remove blank lines
		 $string .= "$LINE\n";
	}
}

# process the top file and check that only supported directives are included.
my %DIRLIST;
my @DATA=split(/\[/,$string);
for (my $I=1;$I<=$#DATA;$I++){
	my $string1 = $DATA[$I];
	open my($fh), "<", \$string1 or die ; # reading from the data in $string
	my $first_line = <$fh>; 
	$first_line =~  s/^\s//g;
	close $fh;
	my @B=split(/ /,$first_line);
	my $DIR=$B[0];
	chomp($DIR);
	$DIR =~ s/\]$//g;
		
	if(!exists $supported_directives{$DIR}){
		smog_quit("Directive \"$DIR \" not supported\n");
	}else{
		$DIRLIST{$DIR}=$I;
	}
}

# Go through the directives, in order, and write out information for the subsystem
if(-e $outputtop){smog_quit("$outputtop already exists.")}
open(TOPOUT,">$outputtop") or die "Can\'t open $outputtop for writing.\n";

if(!exists $DIRLIST{"defaults"}){
	smog_quit("\"defaults\" does not appear in .top file.\n");
}else{
	my @C= split(/\n/,$DATA[$DIRLIST{"defaults"}]);
	if($#C != 1){
		my $NN=$#C;
		smog_quit("Must have one line in the \"defaults\" directive. Found $NN\n");
	}
	my @D=split(/ /,$C[1]);
	if($#D != 2){
		smog_quit("Improperly formatted defaults line.  Must provide nbfunc, comb-rule and gen-pairs.\n");
	}
	print TOPOUT "[ defaults ]\n";
	print TOPOUT "$C[1]\n\n";
}



# start with atomtypes
if(!exists $DIRLIST{"atomtypes"}){
	smog_quit("\"atomtypes\" does not appear in .top file.\n");
}else{
	my @indextotype;
	my $typeindex=0;
	my @C= split(/\n/,$DATA[$DIRLIST{"atomtypes"}]);
	# keep all the atomtypes, even though some may not be used in the new system.	
	print TOPOUT "[ atomtypes ]\n";
	for(my $II=1;$II<=$#C;$II++){
		print TOPOUT "$C[$II]\n";
	}
	print TOPOUT "\n";
}

if(!exists $DIRLIST{"moleculetype"}){
	smog_quit("\"moleculetype\" does not appear in .top file.\n");
}else{
	my @C= split(/\n/,$DATA[$DIRLIST{"moleculetype"}]);
	if($#C != 1){
		my $NN=$#C;
		smog_quit("Must have one line in the \"moleculetype\" directive. Found $NN\n");
	}
	my @D=split(/ /,$C[1]);
	if($#D != 1){
		smog_quit("Improperly formatted moleculetype line. Must provide name and nrexcl value.\n");
	}
	print TOPOUT "[ moleculetype ]\n";
	print TOPOUT "$C[1]\n\n";
}

# information about the atoms 
if(!exists $DIRLIST{"atoms"}){
	smog_quit("\"atoms\" does not appear in .top file.\n");
}else{
	my @C= split(/\n/,$DATA[$DIRLIST{"atoms"}]);

	print TOPOUT "[ atoms ]\n";

	for(my $I=0;$I<$KEEPN;$I++){
		my $JJ=$keepatoms2[$I];
		my @D=split(/ /,$C[$JJ]);
		print TOPOUT "$keepatoms{$JJ} $D[1] $D[2] $D[3] $D[4] $keepatoms{$JJ}\n";
	}
}

print TOPOUT "\n";

# information about the bonds 
if(!exists $DIRLIST{"bonds"}){
	smog_quit("\"bonds\" does not appear in .top file.\n");
}else{
	my @C= split(/\n/,$DATA[$DIRLIST{"bonds"}]);
	if($#C<1){
		smog_quit("There must be at least 1 bond listed under the bonds directive\n");
	}

	print TOPOUT "[ bonds ]\n";
	for(my $JJ=1;$JJ<=$#C;$JJ++){
		my @D=split(/ /,$C[$JJ]);
		if(exists $keepatoms{$D[0]} && exists $keepatoms{$D[1]}){
			print TOPOUT "$keepatoms{$D[0]} $keepatoms{$D[1]} ";
			for(my $J=2;$J<=$#D;$J++){
				print TOPOUT "$D[$J] ";
			}
			print TOPOUT "\n";
		}elsif(exists $keepatoms{$D[0]} && !exists $keepatoms{$D[1]}){
			$atoms2restrain{$keepatoms{$D[0]}}=1;
		}elsif(!exists $keepatoms{$D[0]} && exists $keepatoms{$D[1]}){
			$atoms2restrain{$keepatoms{$D[1]}}=1;
		}
	}
}

# information about the angles 
if(!exists $DIRLIST{"angles"}){
	smog_quit("\"angles\" does not appear in .top file.\n");
}else{
	my @C= split(/\n/,$DATA[$DIRLIST{"angles"}]);
	if($#C<1){
		smog_quit("There must be at least 1 angle listed under the angles directive\n");
	}
	print TOPOUT "[ angles ]\n";
	for(my $JJ=1;$JJ<=$#C;$JJ++){
		my @D=split(/ /,$C[$JJ]);
		if(exists $keepatoms{$D[0]} && exists $keepatoms{$D[1]} && exists $keepatoms{$D[2]} ){
			print TOPOUT "$keepatoms{$D[0]} $keepatoms{$D[1]} $keepatoms{$D[2]} ";
			for(my $J=3;$J<=$#D;$J++){
				print TOPOUT "$D[$J] ";
			}
			print TOPOUT "\n";
		}elsif(exists $keepatoms{$D[0]} || exists $keepatoms{$D[1]} || exists $keepatoms{$D[2]}){
			for(my $M=0;$M<3;$M++){
				if(exists $keepatoms{$D[$M]}){
					$atoms2restrain{$keepatoms{$D[$M]}}=1;
				}
			}
		}
	}
}

# information about the dihedrals 
if(!exists $DIRLIST{"dihedrals"}){
	smog_quit("\"dihedrals\" does not appear in .top file.\n");
}else{
	my @LAST;
	my @C= split(/\n/,$DATA[$DIRLIST{"dihedrals"}]);
	if($#C<1){
		smog_quit("There must be at least 1 dihedral listed under the dihedrals directive\n");
	}

	print TOPOUT "[ dihedrals ]\n";
	for(my $JJ=1;$JJ<=$#C;$JJ++){
		my @D=split(/ /,$C[$JJ]);
		if(exists $keepatoms{$D[0]} && exists $keepatoms{$D[1]} && exists $keepatoms{$D[2]} && exists $keepatoms{$D[3]} ){
			print TOPOUT "$keepatoms{$D[0]} $keepatoms{$D[1]} $keepatoms{$D[2]} $keepatoms{$D[3]} ";
			for(my $J=4;$J<=$#D;$J++){
				print TOPOUT "$D[$J] ";
			}
			print TOPOUT "\n";
		}elsif(exists $keepatoms{$D[0]} || exists $keepatoms{$D[1]} || exists $keepatoms{$D[2]} || exists $keepatoms{$D[3]}){
			for(my $M=0;$M<4;$M++){
				if(exists $keepatoms{$D[$M]}){
					$atoms2restrain{$keepatoms{$D[$M]}}=1;
				}
			}
		}
	}
}

# information about the contacts 
if(!exists $DIRLIST{"pairs"}){
	smog_quit("\"pairs\" does not appear in .top file.\n");
}else{
	print TOPOUT "[ pairs ]\n";
	my @C=split(/\n/,$DATA[$DIRLIST{"pairs"}]);
	for(my $JJ=1;$JJ<=$#C;$JJ++){
		my @D=split(/ /,$C[$JJ]);
		if(exists $keepatoms{$D[0]} && exists $keepatoms{$D[1]}){
			print TOPOUT "$keepatoms{$D[0]} $keepatoms{$D[1]} ";
			for(my $J=2;$J<=$#D;$J++){
				print TOPOUT "$D[$J] ";
			}
			print TOPOUT "\n";
		}elsif(exists $keepatoms{$D[0]} && !exists $keepatoms{$D[1]}){
			$atoms2restrain{$keepatoms{$D[0]}}=1;
		}elsif(!exists $keepatoms{$D[0]} && exists $keepatoms{$D[1]}){
			$atoms2restrain{$keepatoms{$D[1]}}=1;
		}
	}
}



# information about the exclusions 
if(!exists $DIRLIST{"exclusions"}){
	smog_quit("\"exclusions\" does not appear in .top file.\n");
}else{
	my @C= split(/\n/,$DATA[$DIRLIST{"exclusions"}]);
	if($#C<1){
		smog_quit("There must be at least 1 bond listed under the bonds directive\n");
	}

	print TOPOUT "[ exclusions ]\n";
	for(my $JJ=1;$JJ<=$#C;$JJ++){
		my @D=split(/ /,$C[$JJ]);
		if(exists $keepatoms{$D[0]} && exists $keepatoms{$D[1]}){
			print TOPOUT "$keepatoms{$D[0]} $keepatoms{$D[1]}\n";
		}
	}
}

# information about the restraints 
if(exists $DIRLIST{"position_restraints"} ){
	smog_quit("position_restraints not supported in the input top file (yet).");
}else{
	if($gen_restraints != 0){
		print "Generating restraints of strength $gen_restraints for atoms that have had interactions removed.\n";
		print MAPPING "\nThe following atoms are restrained (old and new numbering)\n";
		print TOPOUT "[ position_restraints ]\n";
		foreach my $res(sort {$a<=>$b} keys %atoms2restrain){
			print TOPOUT "$res 1 $gen_restraints $gen_restraints $gen_restraints\n";
			print MAPPING "$res $keepatoms2[$res-1]\n";
		}
	}
}

if(!exists $DIRLIST{"system"}){
	smog_quit("\"system\" does not appear in .top file.\n");
}else{
	my @C= split(/\n/,$DATA[$DIRLIST{"system"}]);
	print TOPOUT "[ system ]\n";
	for(my $II=1;$II<=$#C;$II++){
		print TOPOUT "$C[$II]\n";
	}
	print TOPOUT "\n";
}

if(!exists $DIRLIST{"molecules"}){
	smog_quit("\"molecules\" does not appear in .top file.\n");
}else{
	my @C= split(/\n/,$DATA[$DIRLIST{"molecules"}]);
	print TOPOUT "[ molecules ]\n";
	for(my $II=1;$II<=$#C;$II++){
		print TOPOUT "$C[$II]\n";
	}
	print TOPOUT "\n";
}

if($warnonly){
	print "\n\tExtracted $KEEPN-atom subsystem. Since -warnonly was used, carefully check output.\n\n";
}else{
	print "\n\tSUCCESS: Extracted $KEEPN-atom subsystem.\n\n";
}

