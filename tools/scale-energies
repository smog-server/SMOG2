use strict;
use warnings;
use List::Util qw(max);
use Getopt::Long;
use smog_common;

print <<EOT;
********************************************************************************************
                                      smog_scale-energies

      	smog_scale-energies is part of the SMOG 2 distribution, available at smog-server.org

        This tool uses a SMOG .top and .gro file, along with an index file to 
	generate a SMOG model in which contacts and/or dihedrals weights are modified.
	This is a common task when using SMOG models, and we provide this script as a 
	convenience. 

	-rc <value> will indicate that all inter-group contacts should be scaled by value
	-rd <value> will indicate that all intra-group dihedrals should be scaled by value

        For usage information, issue flag -help, or see the SMOG manual.

        For questions regarding this script, contact info\@smog-server.org

********************************************************************************************
EOT

sub usage
{
  print <<EOT;

usage: smog_scale-energies  .. options ..

   Options
	-f [smog.top]		: input SMOG forcefield file
	-n [smog.ndx]		: index file
        -of [rescaled.top]	: output SMOG forcefield file with rescaled energies
	-rc [1.0]		: rescale inter-group contact weights (default all groups) 
	-rd [1.0]		: rescale intra-group dihedral weights (default all groups)
	-help    		: show options
EOT
  if ( @_ ){
   smog_quit("Command-line argument \"@_\" not recognized.");
  }else{
   exit;
  }
}

my $inputTOP="smog.top";
my $indexFile="smog.ndx";
my $outputTOP="rescaled.top";
my $rescaleC=1.0;
my $rescaleD=1.0;
my $help;
quit_init();
our $noexit=0;
usage() if (@ARGV < 0 || !GetOptions('help|?' => \$help, 'f=s' => \$inputTOP, 'n=s' => \$indexFile, 
        'of=s' => \$outputTOP, 'rc=f' => \$rescaleC, 'rd=f' => \$rescaleD, 'warn=i' => \$maxwarn, 
        '<>' => \&usage)
        or defined $help); 

if($rescaleC <= 0){
	smog_quit("only positive values may be provided with -rc.")
}
if($rescaleD <= 0){
	smog_quit("only positive values may be provided with -rd.")
}
if($outputTOP !~ m/.top$/){
	$outputTOP .= ".top";
}
if($inputTOP !~ m/.top$/){
	$inputTOP .= ".top";
}
if($indexFile !~ m/.ndx$/){
	$indexFile .= ".ndx";
}

my $maxbu=10;
foreach my $filen($outputTOP){
	my ($ext) = $filen =~ /(\.[^.]+)$/;
	if($filen ne "" && -e $filen){
		for(my $bu=1;$bu<=$maxbu;$bu++){
			my $buname="$filen.bu$bu";
			if( ! -e $buname){	
			print "$filen already exists.  Backing up to $buname\n";
			system("mv $filen $buname");
			last;
			}
			if($bu == $maxbu){
		 	smog_quit ("Already backed up $maxbu copies of $filen."); 
			}
		}
	}
}

warninfo();

### read in the list of atoms that we want to keep
my %atomgroup;
my $Ngrps=0;
my $modgrp;
my @grpnms;
my %groupnames;
my $groupname;
print "Reading index file $indexFile\n";
open(ATOMLIST,"$indexFile") or die "\nCan\'t open $indexFile. Use --help for usage guidelines.\n\nRescaling Incomplete!\n\n";
while(<ATOMLIST>){
	my $LINE=$_;
	chomp($LINE);
	# remove comments first
	$LINE =~ s/;.*$//g; 
	# in case we have a group directive w/o spaces
	$LINE =~ s/\[/\[ /g;
	$LINE =~ s/\]/ \]/g;
	$LINE =~ s/^\s+|\s+$//g;
	$LINE =~ s/\s+|\t+/ /g;
	my @A=split(/ /,$LINE);
	if($#A == -1){
		# blank line
		next;
	}
	if($A[0] eq "[" and $A[2] eq "]"){
		# must be a new group
		$groupname=$A[1];
		$grpnms[$Ngrps]=$groupname;
		if(exists $A[3]){
			smog_quit("Group name declarations must not have trailing characters.  $A[3] appears after $A[0] $A[1] $A[2]\n;")	
		}
		if(exists $groupnames{$groupname}){
			smog_quit("Group name $groupname declared more than once.");
		}
		$groupnames{$groupname}=$Ngrps;
		$Ngrps++;

		next; # this is a new group, so go to next line.
	}

	for(my $I=0;$I<=$#A;$I++){
		unless($A[$I] =~ m/^\d+$/){
			smog_quit("Non-numerical value for atom number in index file: $A[$I]");
		}
		if(exists $atomgroup{$A[$I]}){
			smog_quit("Duplicate atom in index file: Atom $A[$I] already defined in group $atomgroup{$A[$I]}");
		}else{
			$atomgroup{$A[$I]}=$groupname;
		}
	}
}

if($Ngrps==0){
	smog_quit("no atom groups given in ndx file.");

}elsif($Ngrps>1){
	print "Select the index of the group you would like to rescale?\n";
	print "index\t:\tgroup name\n";
	for(my $I=0;$I<$Ngrps;$I++){
		print "$I\t:\t$grpnms[$I]\n";
	}
	my $tmp=<STDIN>;
	chomp($tmp);
	unless($tmp =~ m/^\d+$/){
		smog_quit("$tmp is an invalid selection");
	}
	if($tmp <0 or $tmp >=$Ngrps){
		smog_quit("selection must be positive and less than or $Ngrps");
	}
	$modgrp=$grpnms[$tmp];
	print "Will modify weights for atom group $modgrp\n";
}else{
	$modgrp=$grpnms[0];	
}

close(ATOMLIST);

my %supported_directives = ( 'defaults' => '0',
        'atomtypes' => '1',
        'moleculetype' => '0',
        'atoms' => '1',
        'bonds' => '1',
        'angles' => '1',
        'dihedrals' => '1',
        'pairs' => '1',
        'exclusions' => '1',
        'system' => '1',
        'molecules' => '1',
        'position_restraints' => '1'
        );

#read in the top file, with comments stripped
print "Reading top file $inputTOP\n";
open(FILE, "$inputTOP") or die "Can not open $inputTOP\n"; 
my $string = "";
while (<FILE>){
	my $LINE = $_;
	chomp($LINE);
	$LINE =~ s/;.*$//g; 
	$LINE =~ s/\t/ /g; 
	$LINE =~ s/^\s+|\s+$//g;
	$LINE =~ s/ +/ /g;
	if( $LINE =~ m/[#!\^\$]/ ){
		smog_quit("Special characters not recognized in .top file\n  Offending line: $LINE\n");
	}
	# remove comments
	if($LINE ne ""){ 
	## remove blank lines
		 $string .= "$LINE\n";
	}
}

print "\nUsing $inputTOP and $indexFile to generate $outputTOP. Contacts will be rescaled by $rescaleC and dihedrals by $rescaleD\n";
# process the top file and check that only supported directives are included.
my %DIRLIST;
my @DATA=split(/\[/,$string);
for (my $I=1;$I<=$#DATA;$I++){
	my $string1 = $DATA[$I];
	open my($fh), "<", \$string1 or die ; # reading from the data in $string
	my $first_line = <$fh>; 
	$first_line =~  s/^\s//g;
	close $fh;
	my @B=split(/ /,$first_line);
	my $DIR=$B[0];
	chomp($DIR);
	$DIR =~ s/\]$//g;
		
	if(!exists $supported_directives{$DIR}){
		smog_quit("Directive \"$DIR \" not supported\n");
	}elsif(exists $DIRLIST{$DIR}){
		smog_quit("detected repeated directive $DIR.  Currently, only a single molecule definition is supported by this script.");
	}else{
		$DIRLIST{$DIR}=$I;
	}
}

# Go through the directives, in order, and write out information for the subsystem
open(TOPOUT,">$outputTOP") or die "Can\'t open $outputTOP for writing.\n";

print TOPOUT "; $inputTOP and $indexFile were used to generate this file: $outputTOP.\n; Contacts were rescaled by $rescaleC and dihedrals by $rescaleD.\n\n";

if(!exists $DIRLIST{"defaults"}){
	smog_quit("\"defaults\" does not appear in .top file.\n");
}else{
	my @C= split(/\n/,$DATA[$DIRLIST{"defaults"}]);
	if($#C != 1){
		my $NN=$#C;
		smog_quit("Must have one line in the \"defaults\" directive. Found $NN\n");
	}
	my @D=split(/ /,$C[1]);
	if($#D != 2){
		smog_quit("Improperly formatted defaults line.  Must provide nbfunc, comb-rule and gen-pairs.\n");
	}
	print TOPOUT "[ defaults ]\n";
	print TOPOUT "$C[1]\n\n";
}



# start with atomtypes
if(!exists $DIRLIST{"atomtypes"}){
	smog_quit("\"atomtypes\" does not appear in .top file.\n");
}else{
	my $typeindex=0;
	my @C= split(/\n/,$DATA[$DIRLIST{"atomtypes"}]);
	# keep at the atomtypes, even though some may not be used in the new system.	
	print TOPOUT "[ atomtypes ]\n";
	for(my $II=1;$II<=$#C;$II++){
		print TOPOUT "$C[$II]\n";
	}
	print TOPOUT "\n";
}

if(!exists $DIRLIST{"moleculetype"}){
	smog_quit("\"moleculetype\" does not appear in .top file.\n");
}else{
	my @C= split(/\n/,$DATA[$DIRLIST{"moleculetype"}]);
	if($#C != 1){
		my $NN=$#C;
		smog_quit("Must have one line in the \"moleculetype\" directive. Found $NN\n");
	}
	my @D=split(/ /,$C[1]);
	if($#D != 1){
		smog_quit("Improperly formatted moleculetype line. Must provide name and nrexcl value.\n");
	}
	print TOPOUT "[ moleculetype ]\n";
	print TOPOUT "$C[1]\n\n";
}

# information about the atoms 
if(!exists $DIRLIST{"atoms"}){
	smog_quit("\"atoms\" does not appear in .top file.\n");
}else{	
	my @C= split(/\n/,$DATA[$DIRLIST{"atoms"}]);
	if($#C<1){
		smog_quit("There must be at least 1 atom listed under the atoms directive\n");
	}
	my $TMP=$DIRLIST{"atoms"};
	print TOPOUT "[$DATA[$TMP]";
}

print TOPOUT "\n";

# information about the bonds 
if(!exists $DIRLIST{"bonds"}){
	smog_quit("\"bonds\" does not appear in .top file.\n");
}else{	
	my @C= split(/\n/,$DATA[$DIRLIST{"bonds"}]);
	if($#C<1){
		smog_quit("There must be at least 1 bond listed under the bonds directive\n");
	}
	my $TMP=$DIRLIST{"bonds"};
	print TOPOUT "[$DATA[$TMP]";
}

# information about the angles 
if(!exists $DIRLIST{"angles"}){
	smog_quit("\"angles\" does not appear in .top file.\n");
}else{
	my @C= split(/\n/,$DATA[$DIRLIST{"angles"}]);
	if($#C<1){
		smog_quit("There must be at least 1 angle listed under the angles directive\n");
	}
	my $TMP=$DIRLIST{"angles"};
	print TOPOUT "[$DATA[$TMP]";
}

# information about the dihedrals 
if(!exists $DIRLIST{"dihedrals"}){
	smog_quit("\"dihedrals\" does not appear in .top file.\n");
}else{
	my @C= split(/\n/,$DATA[$DIRLIST{"dihedrals"}]);
	if($#C<1){
		smog_quit("There must be at least 1 dihedral listed under the dihedrals directive\n");
	}

	print TOPOUT "[ dihedrals ]\n";
	for(my $JJ=1;$JJ<=$#C;$JJ++){
		my @D=split(/ /,$C[$JJ]);

		if(exists $atomgroup{$D[0]} && exists $atomgroup{$D[1]} && exists $atomgroup{$D[2]} && exists $atomgroup{$D[3]} ){
			if($D[4] == 1 && $atomgroup{$D[0]} eq $modgrp  && $atomgroup{$D[1]} eq $modgrp && $atomgroup{$D[2]} eq $modgrp && $atomgroup{$D[3]} eq $modgrp){
				# rescale dihedral potential
				$D[6] *= $rescaleD;	

			}
		}

		# print atoms and function type
		for(my $J=0;$J<=$#D;$J++){
			print TOPOUT "$D[$J] ";
		}
		print TOPOUT "\n";
	}
}

# information about the contacts 
if(!exists $DIRLIST{"pairs"}){
	smog_quit("\"pairs\" does not appear in .top file.\n");
}else{
	print TOPOUT "[ pairs ]\n";
	my @C=split(/\n/,$DATA[$DIRLIST{"pairs"}]);

	for(my $JJ=1;$JJ<=$#C;$JJ++){
		my @D=split(/ /,$C[$JJ]);
		if(exists $atomgroup{$D[0]} && exists $atomgroup{$D[1]}){
			if($D[2] == 1 && $atomgroup{$D[0]} eq $modgrp && $atomgroup{$D[1]} eq $modgrp){
				$D[3] *= $rescaleC;	
				$D[4] *= $rescaleC;	
			}
		}

		# print atoms and function type
		for(my $J=0;$J<=$#D;$J++){
			print TOPOUT "$D[$J] ";
		}
		print TOPOUT "\n";
	}
}

# information about the exclusions 
if(!exists $DIRLIST{"exclusions"}){
	smog_quit("\"exclusions\" does not appear in .top file.\n");
}else{
	my @C= split(/\n/,$DATA[$DIRLIST{"exclusions"}]);
	if($#C<1){
		smog_quit("There must be at least 1 bond listed under the exclusions directive\n");
	}
	my $TMP=$DIRLIST{"exclusions"};
	print TOPOUT "[$DATA[$TMP]";
}

# information about the restraints 
if(exists $DIRLIST{"position_restraints"} ){
	my @C= split(/\n/,$DATA[$DIRLIST{"position_restraints"}]);
	if($#C<1){
		smog_quit("There must be at least 1 position restraint listed under the position_restraints directive\n");
	}
	my $TMP=$DIRLIST{"position_restraints"};
	print TOPOUT "[$DATA[$TMP]";
}

if(!exists $DIRLIST{"system"}){
	smog_quit("\"system\" does not appear in .top file.\n");
}else{
	my $TMP=$DIRLIST{"system"};
	print TOPOUT "[$DATA[$TMP]\n";
}

if(!exists $DIRLIST{"molecules"}){
	smog_quit("\"molecules\" does not appear in .top file.\n");
}else{
	my @C= split(/\n/,$DATA[$DIRLIST{"molecules"}]);
        if($#C<1){
                smog_quit("There must be at least 1 molecule listed under the molecules directive\n");
        }
	my $TMP=$DIRLIST{"molecules"};
	print TOPOUT "[$DATA[$TMP]\n";
}

warnsummary();

print "\n\tSUCCESS: Interactions rescaled.\n\n";

