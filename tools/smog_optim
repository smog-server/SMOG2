use strict;
use warnings;

print <<EOT;
*****************************************************************************************
                                      smog_optim

     smog_optim is part of the SMOG 2 distribution, available at smog-server.org

Long term plan for the code:
    This tool will generate an OPTIM input file from a SMOG model

Currently:
    This code generates files necessary for rigidification routine usage in OPTIM

                       See the SMOG manual for usage guidelines.

            For questions regarding this script, contact info\@smog-server.org
*****************************************************************************************
EOT


### read the options

my $GROFILE;
my $TOPFILE;
if(-e "SBM.INP"){print "SBM.INP exists.  Will not overwrite.  Quitting.\n"; exit;}

print "Would you like to convert a .top and .gro file to make input for OPTIM? [Y/N]\n";
my $TMP;
$TMP=<STDIN>;

until($TMP=~ m/^[YyNn]$/){
	print "Please answer Y, or N.\n";
	$TMP=<STDIN>;
	chomp($TMP);
}

my $SBMINPON=$TMP;



print "Would you also like to generate files necessary for rigidification code in OPTIM? [Y/N]\n";
$TMP=<STDIN>;

until($TMP=~ m/^[YyNn]$/){
	print "Please answer Y, or N.\n";
	$TMP=<STDIN>;
	chomp($TMP);
}

my $RIGIDON=$TMP;

if($SBMINPON =~ m/^Y$/){
	print "What is the input .top file\n";
	$TOPFILE=<STDIN>;
	chomp($TOPFILE);
}

print "What is the input .gro file\n";
$GROFILE=<STDIN>;
chomp($GROFILE);
open(GROFILE,"$GROFILE") or die "Can\'t open GRO file \"$GROFILE\"\n";

## Generate rigidification files

my %GROUPS;
my %RESCOUNT;
my %ATOMSINRES;
my %rigidified;

if($RIGIDON =~ m/^Y$/){

	print "Going to use $GROFILE to generate rbodyconfig and coordsinrigid for OPTIM\n";
	
	
	## for now, always use a default generic definitions for rigid groups
	## format: <RESIDUE NAME> <LIST OF ATOM NAMES IN GROUP>
	
	
	open(MAPFILE,"$ENV{SMOG_PATH}/tools/rigidmap") or die "Can\'t open rigidmap file\n";
	if(-e "rbodyconfig"){print "rbodyconfig already exists.  Will not overwrite. Quitting.\n"; exit;}
	if(-e "coordsinrigid"){print "coordsinrigid already exists.  Will not overwrite. Quitting.\n"; exit;}
	open(RIGIDOUT,">rbodyconfig") or die "Can\'t open rbodyconfig for writing\n";
	open(RIGIDCOORDS,">coordsinirigid") or die "Can\'t open rbodyconfig for writing\n";
	
	while(<MAPFILE>){
		my $LINE=$_;
		chomp($LINE);
		my @A=split(/\s+/,$LINE);
		my $A1=$A[0];
		if(exists $RESCOUNT{$A1}){
			print "$RESCOUNT{$A1}\n";
			$RESCOUNT{$A1}=eval($RESCOUNT{$A1})+1;
		}else{
			$RESCOUNT{$A1}=1;
		}
			$A1=$A1 . "-" . $RESCOUNT{$A1};
		for(my $I=1;$I<=$#A;$I++){
			$GROUPS{$A1}->[$I-1]=$A[$I];
		}
	
		$ATOMSINRES{$A1}=$#A;
	
		if($ATOMSINRES{$A1}<3){
			print "Rigid group $A1 only has $ATOMSINRES{$A1} atoms. Must have at least 3.  Quitting\n";
			exit;
		}
	
	}
	
	my $GROUPS=%GROUPS;
	
	# add a check to make sure that atoms don't appear in two different group
	
	
	
	$TMP=<GROFILE>;
	$TMP=<GROFILE>;
	chomp($TMP);
	my @A=split(/\s+/,$TMP);
	my $NATOMS=$A[0];
	my %ATOMNUM;
	my $LINE=<GROFILE>;
	
	my $LASTRESNUM=substr($LINE,0,5);
	$LASTRESNUM =~ s/^\s+|\s+$//g;
	
	my $ATOMNAME=substr($LINE,10,5);
	$ATOMNAME =~ s/^\s+|\s+$//g;
	
	my $NUMT=substr($LINE,15,5);
	$NUMT =~ s/^\s+|\s+$//g;
	$ATOMNUM{$ATOMNAME}= $NUMT;
	
	my $LASTRESNAME=substr($LINE,5,5);
	$LASTRESNAME =~ s/^\s+|\s+$//g;
#	my $ATOMSINRES=1;
	my $RIGIDINDEX=0;
	for(my $I=1;$I<$NATOMS;$I++){
	# read a line
	# parse using fixed formatting
		my $LINE=<GROFILE>;
		my $RESNUM=substr($LINE,0,5);
		$RESNUM =~ s/^\s+|\s+$//g;
		my $ATOMNAME=substr($LINE,10,5);
		$ATOMNAME =~ s/^\s+|\s+$//g;
		my $ATOMNUMT=substr($LINE,15,5);
		$ATOMNUMT =~ s/^\s+|\s+$//g;
		my $RESNAME=substr($LINE,5,5);
		$RESNAME =~ s/^\s+|\s+$//g;
		my $COORDS=substr($LINE,20,24);
		print RIGIDCOORDS "$COORDS\n";
	# Once done reading a residue, create the rigid groups
		if($RESNUM != $LASTRESNUM && exists $RESCOUNT{$LASTRESNAME}){
			# go through the rigid groups for that residue
			for (my $J=1;$J<=eval($RESCOUNT{$LASTRESNAME});$J++){
				my $GROUPSIZE=0;
				my $PRINTBUFF = "";;
		                my $A1=$LASTRESNAME . "-" . $J ;
				my %rgroup;
				for (my $K=0;$K<$ATOMSINRES{$A1};$K++){
					if( !exists $ATOMNUM{$GROUPS{$A1}->[$K]}){
						print "Warning: $GROUPS{$A1}->[$K] atom not found in residue $LASTRESNAME$LASTRESNUM\n";
					}else{
						if(exists $rigidified{$ATOMNUM{$GROUPS{$A1}->[$K]}}){
							print "atom index $ATOMNUM{$GROUPS{$A1}->[$K]} ($LASTRESNAME$LASTRESNUM) appeared in two groups. Quitting\n";
							exit;
						}else{
							$rigidified{$ATOMNUM{$GROUPS{$A1}->[$K]}}=$RIGIDINDEX;
							# remember that this atom is of a specific rigid group
						}
						$PRINTBUFF = $PRINTBUFF."$ATOMNUM{$GROUPS{$A1}->[$K]}\n";
						$GROUPSIZE++;
					}
				}
	
				if($GROUPSIZE>2){
					print RIGIDOUT "GROUP $GROUPSIZE\n";
					print RIGIDOUT "$PRINTBUFF";
				}elsif($GROUPSIZE==1 || $GROUPSIZE==2){
					print "Only found $GROUPSIZE atoms in group $J of $LASTRESNAME$LASTRESNUM. Not adding as rigid group\n";
				}
				$RIGIDINDEX++;
			}
			undef %ATOMNUM;
		}
	
	
		$LASTRESNAME=$RESNAME;
		$LASTRESNUM=$RESNUM;
		$ATOMNUM{$ATOMNAME}= $ATOMNUMT;
	
	}
	# check last residue
	
	# go through the rigid groups for that residue
	
	if( exists $RESCOUNT{$LASTRESNAME}){
		for (my $J=1;$J<=eval($RESCOUNT{$LASTRESNAME});$J++){
			my $GROUPSIZE=0;
			my $PRINTBUFF = "";;
		        my $A1=$LASTRESNAME . "-" . $J ;
			print "\naccessing $A1\n";
			for (my $K=0;$K<$ATOMSINRES{$A1};$K++){
				if( !exists $ATOMNUM{$GROUPS{$A1}->[$K]}){
					print "Warning: $GROUPS{$A1}->[$K] atom not found in residue $LASTRESNAME$LASTRESNUM\n";
				}else{
					if(exists $rigidified{$ATOMNUM{$GROUPS{$A1}->[$K]}}){
						print "atom index $ATOMNUM{$GROUPS{$A1}->[$K]} ($LASTRESNAME$LASTRESNUM) appeared in two groups. Quitting\n";
						exit;
					}else{
						$rigidified{$ATOMNUM{$GROUPS{$A1}->[$K]}}=$RIGIDINDEX;
						# remember that this atom is of a specific rigid group
					}

					$PRINTBUFF = $PRINTBUFF . "$ATOMNUM{$GROUPS{$A1}->[$K]}\n";
					$GROUPSIZE++;
				}
			}
		
			if($GROUPSIZE>0){
				print "size $GROUPSIZE\n";
				print RIGIDOUT "GROUP $GROUPSIZE\n";
				print RIGIDOUT "$PRINTBUFF";
			}
		}
		undef %ATOMNUM;
	}

}

## Generate SBM.INP

if($SBMINPON =~ m/^Y$/){
	print "Going to convert $TOPFILE and $GROFILE to SBM.INP and odata for OPTIM\n";

	my %supported_directives = ( 'defaults' => '0',
                'atomtypes' => '1',
                'moleculetype' => '0',
                'atoms' => '1',
                'bonds' => '1',
                'angles' => '1',
                'dihedrals' => '1',
                'pairs' => '1',
                'exclusions' => '1',
                'system' => '1',
                'molecules' => '1'
                );


	#read in the top file, with comments stripped

	open(FILE, "$TOPFILE") or die "Can not open $TOPFILE\n"; 
	my $string = "";
	while (<FILE>){
		my $LINE = $_;
		chomp($LINE);
		$LINE =~ s/;.*$//g; 
		$LINE =~ s/^\s+|\s+$//g;
		$LINE =~ s/ +/ /g;
		# remove comments
		if($LINE ne ""){ 
		## remove blank lines
			 $string .= "$LINE\n";
		}
	}
	
	# read in the top file and check that only supported directives are included.
	my %DIRLIST;
	my @DATA=split(/\[/,$string);
	for (my $I=1;$I<=$#DATA;$I++){
		my $string1 = $DATA[$I];
		open my($fh), "<", \$string1 or die ; # reading from the data in $string
		my $first_line = <$fh>; # gives "Fred"
		$first_line =~  s/^\s//g;
		close $fh;
		my @B=split(/ /,$first_line);
		my $DIR=$B[0];
		
		if(!exists $supported_directives{$DIR}){
			print "Directive \"$DIR \" not supported\n";
		}else{
			$DIRLIST{$DIR}=$I;
		}
	}
	
	
	my $SWITCHD=5.0;	
	my $CUTD=6.0;
	my $CHARGE;
	my $MASS;	
	# Write out SBM.INP
	if(-e "SBM.INP"){print "SBM.INP already exists.  Quitting.\n"; exit;}
	open(OPTIMTOP,">SBM.INP") or die "Can not open SBM.INP\n";
	
	print OPTIMTOP "Structure-based topology file for use with OPTIM.  Generated by smog_optim, as part of the SMOG 2 distrubution\n";
	print OPTIMTOP  "excluded volume: sigma, epsilon, switching distance, truncate distance\n";

	# Go through the directives, in order
	
	# start with atomtypes
	if(!exists $DIRLIST{"atomtypes"}){
		print "ERROR: \"atomtypes\" does not appear in .top file.\n";
		exit;
	}else{
		my @C= split(/\n/,$DATA[$DIRLIST{"atomtypes"}]);
		if($#C>1){
			print "ERROR: Multiple atomtypes not currently supported by smog_optim\n";
			exit;
		}

		my @D=split(/ /,$C[1]);
		$MASS=$D[1];
		$CHARGE=$D[2];
		if($CHARGE != 0){
			print "ERROR: Charges not supported.\n";
			exit;
		}
		if($D[4] != 0){
			print "ERROR: Non-specific attractive c6 term must be 0.\n";
			exit;
		}
		my $EPSILON=1.0;
		my $SIGMA=10.0*($D[5]/$EPSILON)**(1.0/12);
		if($SIGMA > $SWITCHD){
			print "ERROR: Switching distance must be larger than sigma\n";
			exit;
		}

		printf (OPTIMTOP "%f %f %f %f\n", $SIGMA, $EPSILON, $SWITCHD, $CUTD);

	}

	# provide information about the atoms 
	if(!exists $DIRLIST{"atoms"}){
		print "ERROR: \"atoms\" does not appear in .top file.\n";
		exit;
	}else{
		my @C= split(/\n/,$DATA[$DIRLIST{"atoms"}]);
		if($#C<1){
			print "ERROR: There must be at least 1 atom listed under the atoms directive\n";
			exit;
		}
		printf (OPTIMTOP "%i atoms\n",$#C);
		for (my $K=1;$K<$#C;$K++){
			my @D=split(/ /,$C[$K]);
			printf (OPTIMTOP "%5i %5s %4i %5s %5s %8.5f %8.5f\n", $D[0],$D[1],$D[2],$D[3],$D[4],$CHARGE,$MASS);
		}
	}

	print OPTIMTOP "\n";


	# provide information about the atoms 
	if(!exists $DIRLIST{"bonds"}){
		print "WARNING: \"bonds\" does not appear in .top file.\n";
	}else{
		my @C= split(/\n/,$DATA[$DIRLIST{"bonds"}]);
		if($#C<1){
			print "ERROR: There must be at least 1 bond listed under the bonds directive\n";
			exit;
		}
		printf (OPTIMTOP "%i bonds\n",$#C);
		for (my $K=1;$K<$#C;$K++){
			my @D=split(/ /,$C[$K]);
			$D[3]*=10;
			$D[4]*=0.5;
			if(!exists $rigidified{$D[0]} || !exists $rigidified{$D[1]} ){
				printf (OPTIMTOP "%5i %5i %8.5f %8.5f\n", $D[0],$D[1],$D[3],$D[4]);
			}else{
				unless ($rigidified{$D[0]} == $rigidified{$D[1]}){
					printf (OPTIMTOP "%5i %5i %8.5f %8.5f\n", $D[0],$D[1],$D[3],$D[4]);
				}
			}
		}
	}
}

