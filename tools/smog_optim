use strict;
use warnings;

print <<EOT;
*****************************************************************************************
                                      smog_optim

     smog_optim is part of the SMOG 2 distribution, available at smog-server.org

Long term plan for the code:
    This tool will generate an OPTIM input file from a SMOG model

Currently:
    This code generates files necessary for rigidification routine usage in OPTIM

                       See the SMOG manual for usage guidelines.

            For questions regarding this script, contact info\@smog-server.org
*****************************************************************************************
EOT


### read the options

my $GROFILE;
my $TOPFILE;
my $DEG2RAD=3.1415926/180.0;

print "Would you like to convert a .top and .gro file to make input for OPTIM? [Y/N]\n";
my $TMP;
$TMP=<STDIN>;

until($TMP=~ m/^[YN]$/){
	print "Please answer Y, or N.\n";
	$TMP=<STDIN>;
	chomp($TMP);
}

my $SBMINPON=$TMP;



print "Would you also like to generate files necessary for rigidification code in OPTIM? [Y/N]\n";
$TMP=<STDIN>;

until($TMP=~ m/^[YN]$/){
	print "Please answer Y, or N.\n";
	$TMP=<STDIN>;
	chomp($TMP);
}

my $RIGIDON=$TMP;

if($SBMINPON =~ m/^Y$/){
	print "What is the input .top file\n";
	$TOPFILE=<STDIN>;
	chomp($TOPFILE);
}

print "What is the input .gro file\n";
$GROFILE=<STDIN>;
chomp($GROFILE);

## Generate rigidification files

my %GROUPS;
my %RESCOUNT;
my %ATOMSINRES;
my %rigidified;

if($RIGIDON =~ m/^Y$/){

	print "Going to use $GROFILE to generate rbodyconfig and coordsinrigid for OPTIM\n";

	print "Would you like to provide an index file that defines the rigid atoms [F], or use the default [D]?\n";

	$TMP=<STDIN>;

	until($TMP=~ m/^[FD]$/){
		print "Please answer F (file), or D (default).\n";
		$TMP=<STDIN>;
		chomp($TMP);
	}
	my $RDEF=$TMP;

	if($RDEF =~ m/^F$/){
		# using file
		print "What file should be read for defining the rigid groups?\n";
		my $RGFILE=<STDIN>;
		open(RGFILE,"$RGFILE") or die "Can\'t open $RGFILE.\n";
		open(RIGIDOUT,">rbodyconfig") or die "Can\'t open rbodyconfig for writing\n";
		my $RIGIDINDEX=0;
		while(<RGFILE>){

			my $LINE=$_;
			chomp($LINE);
			$LINE =~ s/\t/ /g; 
			$LINE =~ s/^\s+|\s+$//g;
			$LINE =~ s/ +/ /g;
			my @A=split(/ /,$LINE);
			unless($A[0] eq "GROUP"){
				print "ERROR: Each line of the rigid group file must start with GROUP. Quitting.\n";
				exit;
			}
			my $PRINTBUFF ="";
			for (my $J=1;$J<=$#A;$J++){
				if(exists $rigidified{$A[$J]}){
					print "atom index $A[$J] appeared in two groups. Quitting\n";
                                        exit;
                                }else{
					$rigidified{$A[$J]}=$RIGIDINDEX;
					$PRINTBUFF .= "$A[$J]\n";
					# remember that this atom is of a specific rigid group
				}
			}

			if($#A>3){
				print RIGIDOUT "GROUP $#A\n";
				print RIGIDOUT "$PRINTBUFF";
			}else{
				print "Only found $#A atoms in group $RIGIDINDEX. Not adding as rigid group\n";
			}
			$RIGIDINDEX++;
		}

		# make coordsinrigid file 
		open(RIGIDCOORDS,">coordsinirigid") or die "Can\'t open rbodyconfig for writing\n";
		open(GROFILE,"$GROFILE") or die "Can\'t open GRO file \"$GROFILE\"\n";
		$TMP=<GROFILE>;
		$TMP=<GROFILE>;
		chomp($TMP);
		my @A=split(/\s+/,$TMP);
		my $NATOMS=$A[0];
		for(my $I=0;$I<$NATOMS;$I++){
			my $LINE=<GROFILE>;
			my $COORDS=substr($LINE,20,24);
			print RIGIDCOORDS "$COORDS\n";
		}
		close(RIGIDCOORDS);

	}elsif($RDEF =~ m/^D$/){
		# using defaults

		open(GROFILE,"$GROFILE") or die "Can\'t open GRO file \"$GROFILE\"\n";
		
		## for now, always use a default generic definitions for rigid groups
		## format: <RESIDUE NAME> <LIST OF ATOM NAMES IN GROUP>
		
		open(MAPFILE,"$ENV{SMOG_PATH}/tools/rigidmap") or die "Can\'t open rigidmap file\n";
		if(-e "rbodyconfig"){print "rbodyconfig already exists.  Will not overwrite. Quitting.\n"; exit;}
		if(-e "coordsinrigid"){print "coordsinrigid already exists.  Will not overwrite. Quitting.\n"; exit;}
		open(RIGIDOUT,">rbodyconfig") or die "Can\'t open rbodyconfig for writing\n";
		open(RIGIDCOORDS,">coordsinirigid") or die "Can\'t open rbodyconfig for writing\n";
		
		while(<MAPFILE>){
			my $LINE=$_;
			chomp($LINE);
			my @A=split(/\s+/,$LINE);
			my $A1=$A[0];
			if(exists $RESCOUNT{$A1}){
				$RESCOUNT{$A1}=eval($RESCOUNT{$A1})+1;
			}else{
				$RESCOUNT{$A1}=1;
			}
				$A1=$A1 . "-" . $RESCOUNT{$A1};
			for(my $I=1;$I<=$#A;$I++){
				$GROUPS{$A1}->[$I-1]=$A[$I];
			}
		
			$ATOMSINRES{$A1}=$#A;
		
			if($ATOMSINRES{$A1}<3){
				print "Rigid group $A1 only has $ATOMSINRES{$A1} atoms. Must have at least 3.  Quitting\n";
				exit;
			}
		
		}
		
		my $GROUPS=%GROUPS;
		
		# add a check to make sure that atoms don't appear in two different group
		
		
		
		$TMP=<GROFILE>;
		$TMP=<GROFILE>;
		chomp($TMP);
		my @A=split(/\s+/,$TMP);
		my $NATOMS=$A[0];
		my %ATOMNUM;
		my $LINE=<GROFILE>;
		
		my $LASTRESNUM=substr($LINE,0,5);
		$LASTRESNUM =~ s/^\s+|\s+$//g;
		
		my $ATOMNAME=substr($LINE,10,5);
		$ATOMNAME =~ s/^\s+|\s+$//g;
		
		my $NUMT=substr($LINE,15,5);
		$NUMT =~ s/^\s+|\s+$//g;
		$ATOMNUM{$ATOMNAME}= $NUMT;
		
		my $LASTRESNAME=substr($LINE,5,5);
		$LASTRESNAME =~ s/^\s+|\s+$//g;
		my $RIGIDINDEX=0;
		for(my $I=1;$I<$NATOMS;$I++){
		# read a line
		# parse using fixed formatting
			my $LINE=<GROFILE>;
			my $RESNUM=substr($LINE,0,5);
			$RESNUM =~ s/^\s+|\s+$//g;
			my $ATOMNAME=substr($LINE,10,5);
			$ATOMNAME =~ s/^\s+|\s+$//g;
			my $ATOMNUMT=substr($LINE,15,5);
			$ATOMNUMT =~ s/^\s+|\s+$//g;
			my $RESNAME=substr($LINE,5,5);
			$RESNAME =~ s/^\s+|\s+$//g;
			my $COORDS=substr($LINE,20,24);
			print RIGIDCOORDS "$COORDS\n";
		# Once done reading a residue, create the rigid groups
			if($RESNUM != $LASTRESNUM && exists $RESCOUNT{$LASTRESNAME}){
				# go through the rigid groups for that residue
				for (my $J=1;$J<=eval($RESCOUNT{$LASTRESNAME});$J++){
					my $GROUPSIZE=0;
					my $PRINTBUFF = "";;
			                my $A1=$LASTRESNAME . "-" . $J ;
					my %rgroup;
					for (my $K=0;$K<$ATOMSINRES{$A1};$K++){
						if( !exists $ATOMNUM{$GROUPS{$A1}->[$K]}){
							print "Warning: $GROUPS{$A1}->[$K] atom not found in residue $LASTRESNAME$LASTRESNUM\n";
						}else{
							if(exists $rigidified{$ATOMNUM{$GROUPS{$A1}->[$K]}}){
								print "atom index $ATOMNUM{$GROUPS{$A1}->[$K]} ($LASTRESNAME$LASTRESNUM:$GROUPS{$A1}->[$K]) appeared in two groups. Quitting\n";
								exit;
							}else{
								$rigidified{$ATOMNUM{$GROUPS{$A1}->[$K]}}=$RIGIDINDEX;
								# remember that this atom is of a specific rigid group
							}
							$PRINTBUFF = $PRINTBUFF."$ATOMNUM{$GROUPS{$A1}->[$K]}\n";
							$GROUPSIZE++;
						}
					}
		
					if($GROUPSIZE>2){
						print RIGIDOUT "GROUP $GROUPSIZE\n";
						print RIGIDOUT "$PRINTBUFF";
					}elsif($GROUPSIZE==1 || $GROUPSIZE==2){
						print "Only found $GROUPSIZE atoms in group $J of $LASTRESNAME$LASTRESNUM. Not adding as rigid group\n";
					}
					$RIGIDINDEX++;
				}
				undef %ATOMNUM;
			}
		
		
			$LASTRESNAME=$RESNAME;
			$LASTRESNUM=$RESNUM;
			$ATOMNUM{$ATOMNAME}= $ATOMNUMT;
		
		}
		# check last residue
		
		# go through the rigid groups for that residue
		
		if( exists $RESCOUNT{$LASTRESNAME}){
			for (my $J=1;$J<=eval($RESCOUNT{$LASTRESNAME});$J++){
				my $GROUPSIZE=0;
				my $PRINTBUFF = "";;
			        my $A1=$LASTRESNAME . "-" . $J ;
				print "\naccessing $A1\n";
				for (my $K=0;$K<$ATOMSINRES{$A1};$K++){
					if( !exists $ATOMNUM{$GROUPS{$A1}->[$K]}){
						print "Warning: $GROUPS{$A1}->[$K] atom not found in residue $LASTRESNAME$LASTRESNUM\n";
					}else{
						if(exists $rigidified{$ATOMNUM{$GROUPS{$A1}->[$K]}}){
							print "atom index $ATOMNUM{$GROUPS{$A1}->[$K]} ($LASTRESNAME$LASTRESNUM) appeared in two groups. Quitting\n";
							exit;
						}else{
							$rigidified{$ATOMNUM{$GROUPS{$A1}->[$K]}}=$RIGIDINDEX;
							# remember that this atom is of a specific rigid group
						}
	
						$PRINTBUFF = $PRINTBUFF . "$ATOMNUM{$GROUPS{$A1}->[$K]}\n";
						$GROUPSIZE++;
					}
				}
			
				if($GROUPSIZE>0){
					print "size $GROUPSIZE\n";
					print RIGIDOUT "GROUP $GROUPSIZE\n";
					print RIGIDOUT "$PRINTBUFF";
				}
			}
			undef %ATOMNUM;
		}
		close(GROFILE);
	}
}

## Generate SBM.INP

if($SBMINPON =~ m/^Y$/){
	print "Going to convert $TOPFILE and $GROFILE to SBM.INP and odata for OPTIM\n";

	my %supported_directives = ( 'defaults' => '0',
                'atomtypes' => '1',
                'moleculetype' => '0',
                'atoms' => '1',
                'bonds' => '1',
                'angles' => '1',
                'dihedrals' => '1',
                'pairs' => '1',
                'exclusions' => '1',
                'system' => '1',
                'molecules' => '1'
                );


	#read in the top file, with comments stripped

	open(FILE, "$TOPFILE") or die "Can not open $TOPFILE\n"; 
	my $string = "";
	while (<FILE>){
		my $LINE = $_;
		chomp($LINE);
		$LINE =~ s/;.*$//g; 
		$LINE =~ s/\t/ /g; 
		$LINE =~ s/^\s+|\s+$//g;
		$LINE =~ s/ +/ /g;
		# remove comments
		if($LINE ne ""){ 
		## remove blank lines
			 $string .= "$LINE\n";
		}
	}
	
	# read in the top file and check that only supported directives are included.
	my %DIRLIST;
	my @DATA=split(/\[/,$string);
	for (my $I=1;$I<=$#DATA;$I++){
		my $string1 = $DATA[$I];
		open my($fh), "<", \$string1 or die ; # reading from the data in $string
		my $first_line = <$fh>; # gives "Fred"
		$first_line =~  s/^\s//g;
		close $fh;
		my @B=split(/ /,$first_line);
		my $DIR=$B[0];
		
		if(!exists $supported_directives{$DIR}){
			print "Directive \"$DIR \" not supported\n";
		}else{
			$DIRLIST{$DIR}=$I;
		}
	}
	
	
	my $SWITCHD=5.0;	
	my $CUTD=6.0;
	my $CHARGE;
	my $MASS;	
	# write out odata

	if(-e "odata"){print "odata already exists.  Quitting.\n"; exit;}
	open(ODATA,">odata") or die "Can not open odata\n";
	print ODATA "STEPS 100000000\nBFGSMIN 0.000001\n";

	if($RIGIDON =~ m/^Y$/){
		print ODATA "RIGIDINIT\nPOINTS\n";
	}

	open(GROFILE,"$GROFILE") or die "Can\'t open GRO file \"$GROFILE\"\n";
	$TMP=<GROFILE>;
	$TMP=<GROFILE>;
	chomp($TMP);
	my @A=split(/\s+/,$TMP);
	my $NATOMS=$A[0];
	for(my $I=0;$I<$NATOMS;$I++){
		# read a line
		my $LINE=<GROFILE>;
		my $COORDS=substr($LINE,20,24);
		print ODATA "SB $COORDS\n";
	}
	close(GROFILE);

	# Write out SBM.INP
	if(-e "SBM.INP"){print "SBM.INP already exists.  Quitting.\n"; exit;}
	open(OPTIMTOP,">SBM.INP") or die "Can not open SBM.INP\n";
	
	print OPTIMTOP "Structure-based topology file for use with OPTIM.  Generated by smog_optim, as part of the SMOG 2 distrubution\n";
	print OPTIMTOP  "excluded volume: sigma, epsilon, switching distance, truncate distance\n";

	# Go through the directives, in order
	
	# start with atomtypes
	if(!exists $DIRLIST{"atomtypes"}){
		print "ERROR: \"atomtypes\" does not appear in .top file.\n";
		exit;
	}else{
		my @C= split(/\n/,$DATA[$DIRLIST{"atomtypes"}]);
		if($#C>1){
			print "ERROR: Multiple atomtypes not currently supported by smog_optim\n";
			exit;
		}

		my @D=split(/ /,$C[1]);
		$MASS=$D[1];
		$CHARGE=$D[2];
		if($CHARGE != 0){
			print "ERROR: Charges not supported.\n";
			exit;
		}
		if($D[4] != 0){
			print "ERROR: Non-specific attractive c6 term must be 0.\n";
			exit;
		}
		my $EPSILON=1.0;
		my $SIGMA=10.0*($D[5]/$EPSILON)**(1.0/12);
		if($SIGMA > $SWITCHD){
			print "ERROR: Switching distance must be larger than sigma\n";
			exit;
		}

		printf (OPTIMTOP "%f %f %f %f\n", $SIGMA, $EPSILON, $SWITCHD, $CUTD);

	}

	# provide information about the atoms 
	if(!exists $DIRLIST{"atoms"}){
		print "ERROR: \"atoms\" does not appear in .top file.\n";
		exit;
	}else{
		my @C= split(/\n/,$DATA[$DIRLIST{"atoms"}]);
		if($#C<1){
			print "ERROR: There must be at least 1 atom listed under the atoms directive\n";
			exit;
		}
		printf (OPTIMTOP "%i atoms\n",$#C);
		for (my $K=1;$K<$#C;$K++){
			my @D=split(/ /,$C[$K]);
			printf (OPTIMTOP "%5i %5s %4i %5s %5s %8.5f %8.5f\n", $D[0],$D[1],$D[2],$D[3],$D[4],$CHARGE,$MASS);
		}
	}

	print OPTIMTOP "\n";


	# provide information about the atoms 
	if(!exists $DIRLIST{"bonds"}){
		print "WARNING: \"bonds\" does not appear in .top file.\n";
	}else{
		my @C= split(/\n/,$DATA[$DIRLIST{"bonds"}]);
		if($#C<1){
			print "ERROR: There must be at least 1 bond listed under the bonds directive\n";
			exit;
		}
		printf (OPTIMTOP "%i bonds\n",$#C);
		for (my $K=1;$K<$#C;$K++){
			my @D=split(/ /,$C[$K]);
			$D[3]*=10;
			$D[4]*=0.01;
			if($D[2] != 1 && $D[2] != 6){
				print "ERROR: Only bonds of type 1 and 6 are supported. Quitting.\n";
				exit;
			}

			if(!exists $rigidified{$D[0]} || !exists $rigidified{$D[1]} ){
				printf (OPTIMTOP "%5i %5i %8.5f %8.5e\n", $D[0],$D[1],$D[3],$D[4]);
			}else{
				unless ($rigidified{$D[0]} == $rigidified{$D[1]}){
					printf (OPTIMTOP "%5i %5i %8.5f %8.5e\n", $D[0],$D[1],$D[3],$D[4]);
				}
			}
		}
	}

	print OPTIMTOP "\n";

	# provide information about the atoms 
	if(!exists $DIRLIST{"angles"}){
		print "WARNING: \"angles\" does not appear in .top file.\n";
	}else{
		my @C= split(/\n/,$DATA[$DIRLIST{"angles"}]);
		if($#C<1){
			print "ERROR: There must be at least 1 angle listed under the angles directive\n";
			exit;
		}
		printf (OPTIMTOP "%i angles\n",$#C);
		for (my $K=1;$K<$#C;$K++){
			my @D=split(/ /,$C[$K]);
			$D[4]*=$DEG2RAD;
			if($D[3] != 1 ){
				print "ERROR: Only angles of type 1 are supported. Quitting.\n";
				exit;
			}
			if(!exists $rigidified{$D[0]} || !exists $rigidified{$D[1]} || !exists $rigidified{$D[2]} ){
				printf (OPTIMTOP "%5i %5i %5i %8.5e %8.5e\n", $D[0],$D[1],$D[2],$D[4],$D[5]);
			}else{
				unless (($rigidified{$D[0]} == $rigidified{$D[1]}) && ($rigidified{$D[1]} == $rigidified{$D[2]})   ){
					printf (OPTIMTOP "%5i %5i %5i %8.5e %8.5e\n", $D[0],$D[1],$D[2],$D[4],$D[5]);
				}
			}
		}
	}


	print OPTIMTOP "\n";

	# provide information about the atoms 
	if(!exists $DIRLIST{"dihedrals"}){
		print "WARNING: \"dihedrals\" does not appear in .top file.\n";
	}else{
		my @LAST;
		my @C= split(/\n/,$DATA[$DIRLIST{"dihedrals"}]);
		if($#C<1){
			print "ERROR: There must be at least 1 dihedral listed under the dihedrals directive\n";
			exit;
		}
		printf (OPTIMTOP "%i dihedrals\n",$#C);
		for (my $K=1;$K<$#C;$K++){
			my @D=split(/ /,$C[$K]);
			$D[5]*=$DEG2RAD;

			if($D[4] !=1 && $D[4] !=2 ){
				print "ERROR: Only dihedrals of type 1 and 2 are supported. Quitting.\n";
				exit;
			}
			if(exists $D[7] && $D[7] == 3){
			# if N=3, it must immediately follow an N=1 dihedral
				my $DD=($D[5]/$LAST[5]-3.0);
				if($DD > 0.01 || $DD < -0.01){
					print "ERROR: N=3 dihedral has wrong angle, relative to N=1 dihedral.\n";
					print "See: $C[$K]\n";
					exit;
				}
				$DD=($D[6]/$LAST[6]-0.5);
				if($DD > 0.01 || $DD < -0.01){
					print "ERROR: N=3 dihedral has wrong weight, relative to N=1 dihedral.\n";
					print "See: $C[$K]\n";
					exit;
				}
				if($D[0] != $LAST[0] || $D[1] != $LAST[1] || $D[2] != $LAST[2] || $D[3] != $LAST[3]){
					print "ERROR: N=3 dihedral has wrong atoms, relative to N=1 dihedral.\n";
					print "See: $C[$K]\n";
					exit;
				}
				# if type 3, don't write it again, since it is handles inside OPTIM
				next; 
			}

			if(!exists $rigidified{$D[0]} || !exists $rigidified{$D[1]} || !exists $rigidified{$D[2]} || !exists $rigidified{$D[3]} ){
				printf (OPTIMTOP "%5i %5i %5i %5i %1i %8.5e %8.5e\n", $D[0],$D[1],$D[2],$D[3],$D[4],$D[5],$D[6]);
			}else{
				unless (($rigidified{$D[0]} == $rigidified{$D[1]}) && ($rigidified{$D[1]} == $rigidified{$D[2]})   ){
					printf (OPTIMTOP  "%5i %5i %5i %5i %1i %8.5e %8.5e\n", $D[0],$D[1],$D[2],$D[3],$D[4],$D[5],$D[6]);
				}
			}
		@LAST=@D;
		}
	}


	print OPTIMTOP "\n";


}

