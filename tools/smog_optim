use strict;
use warnings;

print <<EOT;
*****************************************************************************************
                                      smog_optim

     smog_optim is part of the SMOG 2 distribution, available at smog-server.org

Long term plan for the code:
    This tool will generate an OPTIM input file from a SMOG model


TODO: Change the switching distance depending on the model.

Currently:
    This code generates files necessary for rigidification routine usage in OPTIM

                       See the SMOG manual for usage guidelines.

            For questions regarding this script, contact info\@smog-server.org
*****************************************************************************************
EOT

my $GROFILE;
my $TOPFILE;
my $PI=3.1415926;
my $DEG2RAD=$PI/180.0;
my @X;
### read the options

print "Would you like to convert a .top and .gro file to make input for OPTIM? [Y/N]\n";
my $TMP;
$TMP=<STDIN>;

until($TMP=~ m/^[YN]$/){
	print "Please answer Y, or N.\n";
	$TMP=<STDIN>;
	chomp($TMP);
}

my $SBMINPON=$TMP;



print "Would you also like to generate files necessary for rigidification code in OPTIM? [Y/N]\n";
$TMP=<STDIN>;

until($TMP=~ m/^[YN]$/){
	print "Please answer Y, or N.\n";
	$TMP=<STDIN>;
	chomp($TMP);
}

my $RIGIDON=$TMP;

my $CONTTYPE;
if($SBMINPON =~ m/^Y$/){
	print "What is the input .top file\n";
	$TOPFILE=<STDIN>;
	chomp($TOPFILE);

	print "\tAre 10-12, or 6-12 contacts being used? [10/6]?";
	my $TMP;
	$TMP=<STDIN>;
	chomp($TMP);
	until($TMP=~ m/^[6|10]$/){
		print "Please answer 6, or 10.\n";
		$TMP=<STDIN>;
		chomp($TMP);
	}

	if($TMP=~ m/^6$/){
		$CONTTYPE = 6;
	}elsif($TMP=~ m/^10$/){
		$CONTTYPE = 10;
	}

}

print "What is the input .gro file\n";
$GROFILE=<STDIN>;
chomp($GROFILE);

## Generate rigidification files

my %GROUPS;
my %RESCOUNT;
my %ATOMSINRES;
my %rigidified;
my %excludedlist;

if($RIGIDON =~ m/^Y$/){
	print "Going to use $GROFILE to generate rbodyconfig and coordsinrigid for OPTIM\n";

	print "Would you like to provide an index file that defines the rigid atoms [F], use the defaults [D], or both [B]?\n";

	$TMP=<STDIN>;

	until($TMP=~ m/^[FD]$/){
		print "Please answer F (file), or D (default).\n";
		$TMP=<STDIN>;
		chomp($TMP);
	}
	my $RDEF=$TMP;
	my $RIGIDINDEX=0;

	if($RDEF =~ m/^[FB]$/){
		# using file
		print "What file should be read for defining the rigid groups?\n";
		my $RGFILE=<STDIN>;
		open(RGFILE,"$RGFILE") or die "Can\'t open $RGFILE.\n";
		open(RIGIDOUT,">rbodyconfig") or die "Can\'t open rbodyconfig for writing\n";
		while(<RGFILE>){

			my $LINE=$_;
			chomp($LINE);
			$LINE =~ s/\t/ /g; 
			$LINE =~ s/^\s+|\s+$//g;
			$LINE =~ s/ +/ /g;
			my @A=split(/ /,$LINE);
			unless($A[0] eq "GROUP"){
				print "ERROR: Each line of the rigid group file must start with GROUP. Quitting.\n";
				exit;
			}
			my $PRINTBUFF ="";
			for (my $J=1;$J<=$#A;$J++){
				if(exists $rigidified{$A[$J]}){
					print "atom index $A[$J] appeared in two groups. Quitting\n";
                                        exit;
                                }else{
					$rigidified{$A[$J]}=$RIGIDINDEX;
					$PRINTBUFF .= "$A[$J]\n";
					# remember that this atom is of a specific rigid group
				}
			}

			if($#A>3){
				print RIGIDOUT "GROUP $#A\n";
				print RIGIDOUT "$PRINTBUFF";
			}else{
				print "Only found $#A atoms in group $RIGIDINDEX. Not adding as rigid group\n";
			}
			$RIGIDINDEX++;
		}
		if($RDEF =~ m/^[F]$/){
			# make coordsinrigid file, if we are not going to repeat later 
			if(-e "coordsinrigid"){print "coordsinrigid already exists.  Will not overwrite. Quitting.\n"; exit;}
			open(RIGIDCOORDS,">coordsinirigid") or die "Can\'t open rbodyconfig for writing\n";
			open(GROFILE,"$GROFILE") or die "Can\'t open GRO file \"$GROFILE\"\n";
			$TMP=<GROFILE>;
			$TMP=<GROFILE>;
			chomp($TMP);
			my @A=split(/\s+/,$TMP);
			my $NATOMS=$A[0];
			for(my $I=0;$I<$NATOMS;$I++){
				my $LINE=<GROFILE>;
				my $COORDS=substr($LINE,20,24);
				$COORDS =~ s/\t/ /g; 
				$COORDS =~ s/^\s+|\s+$//g;
				$COORDS =~ s/ +/ /g;
				my @E=split(/ /,$COORDS);
				$E[0]*=10.0;
				$E[1]*=10.0;
				$E[2]*=10.0;
				my $ATOMINDEX=substr($LINE,15,5);
				$X[$ATOMINDEX][0]=$E[0];
				$X[$ATOMINDEX][1]=$E[1];
				$X[$ATOMINDEX][2]=$E[2];
				print RIGIDCOORDS "$E[0] $E[1] $E[2]\n";
			}
			close(RIGIDCOORDS);
		}

	}elsif($RDEF =~ m/^[DB]$/){
		# using defaults

		open(GROFILE,"$GROFILE") or die "Can\'t open GRO file \"$GROFILE\"\n";
		
		## for now, always use a default generic definitions for rigid groups
		## format: <RESIDUE NAME> <LIST OF ATOM NAMES IN GROUP>
		
		open(MAPFILE,"$ENV{SMOG_PATH}/tools/rigidmap") or die "Can\'t open rigidmap file\n";
		if(-e "rbodyconfig"){print "rbodyconfig already exists.  Will not overwrite. Quitting.\n"; exit;}
		if(-e "coordsinrigid"){print "coordsinrigid already exists.  Will not overwrite. Quitting.\n"; exit;}
		open(RIGIDOUT,">rbodyconfig") or die "Can\'t open rbodyconfig for writing\n";
		open(RIGIDCOORDS,">coordsinirigid") or die "Can\'t open rbodyconfig for writing\n";
		
		while(<MAPFILE>){
			my $LINE=$_;
			chomp($LINE);
			my @A=split(/\s+/,$LINE);
			my $A1=$A[0];
			if(exists $RESCOUNT{$A1}){
				$RESCOUNT{$A1}=eval($RESCOUNT{$A1})+1;
			}else{
				$RESCOUNT{$A1}=1;
			}
				$A1=$A1 . "-" . $RESCOUNT{$A1};
			for(my $I=1;$I<=$#A;$I++){
				$GROUPS{$A1}->[$I-1]=$A[$I];
			}
		
			$ATOMSINRES{$A1}=$#A;
		
			if($ATOMSINRES{$A1}<3){
				print "Rigid group $A1 only has $ATOMSINRES{$A1} atoms. Must have at least 3.  Quitting\n";
				exit;
			}
		
		}
		
		my $GROUPS=%GROUPS;
		
		# add a check to make sure that atoms don't appear in two different group
		
		
		
		$TMP=<GROFILE>;
		$TMP=<GROFILE>;
		chomp($TMP);
		my @A=split(/\s+/,$TMP);
		my $NATOMS=$A[0];
		my %ATOMNUM;
		my $LINE=<GROFILE>;
		
		my $LASTRESNUM=substr($LINE,0,5);
		$LASTRESNUM =~ s/^\s+|\s+$//g;
		
		my $ATOMNAME=substr($LINE,10,5);
		$ATOMNAME =~ s/^\s+|\s+$//g;
		
		my $NUMT=substr($LINE,15,5);
		$NUMT =~ s/^\s+|\s+$//g;
		$ATOMNUM{$ATOMNAME}= $NUMT;
		
		my $LASTRESNAME=substr($LINE,5,5);
		$LASTRESNAME =~ s/^\s+|\s+$//g;
		my $COORDS=substr($LINE,20,24);

		$COORDS =~ s/\t/ /g; 
		$COORDS =~ s/^\s+|\s+$//g;
		$COORDS =~ s/ +/ /g;
		my @E=split(/ /,$COORDS);
		$E[0]*=10.0;
		$E[1]*=10.0;
		$E[2]*=10.0;
		my $ATOMINDEX=substr($LINE,15,5);
		$X[$ATOMINDEX][0]=$E[0];
		$X[$ATOMINDEX][1]=$E[1];
		$X[$ATOMINDEX][2]=$E[2];

		print RIGIDCOORDS "$E[0] $E[1] $E[2]\n";
		for(my $I=1;$I<$NATOMS;$I++){
		# read a line
		# parse using fixed formatting
			my $LINE=<GROFILE>;
			my $RESNUM=substr($LINE,0,5);
			$RESNUM =~ s/^\s+|\s+$//g;
			my $ATOMNAME=substr($LINE,10,5);
			$ATOMNAME =~ s/^\s+|\s+$//g;
			my $ATOMNUMT=substr($LINE,15,5);
			$ATOMNUMT =~ s/^\s+|\s+$//g;
			my $RESNAME=substr($LINE,5,5);
			$RESNAME =~ s/^\s+|\s+$//g;
			my $COORDS=substr($LINE,20,24);
			$COORDS =~ s/\t/ /g; 
			$COORDS =~ s/^\s+|\s+$//g;
			$COORDS =~ s/ +/ /g;
			my @E=split(/ /,$COORDS);
			$E[0]*=10.0;
			$E[1]*=10.0;
			$E[2]*=10.0;
			my $ATOMINDEX=substr($LINE,15,5);
			$X[$ATOMINDEX][0]=$E[0];
			$X[$ATOMINDEX][1]=$E[1];
			$X[$ATOMINDEX][2]=$E[2];

			print RIGIDCOORDS "$E[0] $E[1] $E[2]\n";

			# Once done reading a residue, create the rigid groups
			if($RESNUM != $LASTRESNUM && exists $RESCOUNT{$LASTRESNAME}){
				# go through the rigid groups for that residue
				for (my $J=1;$J<=eval($RESCOUNT{$LASTRESNAME});$J++){
					my $GROUPSIZE=0;
					my $PRINTBUFF = "";;
			                my $A1=$LASTRESNAME . "-" . $J ;
					my %rgroup;
					for (my $K=0;$K<$ATOMSINRES{$A1};$K++){
						if( !exists $ATOMNUM{$GROUPS{$A1}->[$K]}){
							print "Warning: $GROUPS{$A1}->[$K] atom not found in residue $LASTRESNAME$LASTRESNUM\n";
						}else{
							if(exists $rigidified{$ATOMNUM{$GROUPS{$A1}->[$K]}}){
								print "atom index $ATOMNUM{$GROUPS{$A1}->[$K]} ($LASTRESNAME$LASTRESNUM:$GROUPS{$A1}->[$K]) appeared in two groups. Quitting\n";
								exit;
							}else{
								$rigidified{$ATOMNUM{$GROUPS{$A1}->[$K]}}=$RIGIDINDEX;
								# remember that this atom is of a specific rigid group
							}
							$PRINTBUFF = $PRINTBUFF."$ATOMNUM{$GROUPS{$A1}->[$K]}\n";
							$GROUPSIZE++;
						}
					}
		
					if($GROUPSIZE>2){
						print RIGIDOUT "GROUP $GROUPSIZE\n";
						print RIGIDOUT "$PRINTBUFF";
					}elsif($GROUPSIZE==1 || $GROUPSIZE==2){
						print "Only found $GROUPSIZE atoms in group $J of $LASTRESNAME$LASTRESNUM. Not adding as rigid group\n";
					}


					for (my $K1=0;$K1<$ATOMSINRES{$A1};$K1++){
						for (my $K2=0;$K2<$ATOMSINRES{$A1};$K2++){

							if( exists $ATOMNUM{$GROUPS{$A1}->[$K1]} && exists $ATOMNUM{$GROUPS{$A1}->[$K2]} ){
								if( $ATOMNUM{$GROUPS{$A1}->[$K1]} < $ATOMNUM{$GROUPS{$A1}->[$K2]}){
									$excludedlist{"$ATOMNUM{$GROUPS{$A1}->[$K1]}-$ATOMNUM{$GROUPS{$A1}->[$K2]}"}=1;
								}elsif($ATOMNUM{$GROUPS{$A1}->[$K1]} !=  $ATOMNUM{$GROUPS{$A1}->[$K2]}){
									$excludedlist{"$ATOMNUM{$GROUPS{$A1}->[$K2]}-$ATOMNUM{$GROUPS{$A1}->[$K1]}"}=1;
								}
							}
						}
					}
					$RIGIDINDEX++;
				}
				undef %ATOMNUM;
			}
		
		
			$LASTRESNAME=$RESNAME;
			$LASTRESNUM=$RESNUM;
			$ATOMNUM{$ATOMNAME}= $ATOMNUMT;
		
		}
		# check last residue
		
		# go through the rigid groups for that residue
		
		if( exists $RESCOUNT{$LASTRESNAME}){
			for (my $J=1;$J<=eval($RESCOUNT{$LASTRESNAME});$J++){
				my $GROUPSIZE=0;
				my $PRINTBUFF = "";;
			        my $A1=$LASTRESNAME . "-" . $J ;
				print "\naccessing $A1\n";
				for (my $K=0;$K<$ATOMSINRES{$A1};$K++){
					if( !exists $ATOMNUM{$GROUPS{$A1}->[$K]}){
						print "Warning: $GROUPS{$A1}->[$K] atom not found in residue $LASTRESNAME$LASTRESNUM\n";
					}else{
						if(exists $rigidified{$ATOMNUM{$GROUPS{$A1}->[$K]}}){
							print "atom index $ATOMNUM{$GROUPS{$A1}->[$K]} ($LASTRESNAME$LASTRESNUM) appeared in two groups. Quitting\n";
							exit;
						}else{
							$rigidified{$ATOMNUM{$GROUPS{$A1}->[$K]}}=$RIGIDINDEX;
							# remember that this atom is of a specific rigid group
						}
	
						$PRINTBUFF = $PRINTBUFF . "$ATOMNUM{$GROUPS{$A1}->[$K]}\n";
						$GROUPSIZE++;
					}
				}
				if($GROUPSIZE>0){
					print "size $GROUPSIZE\n";
					print RIGIDOUT "GROUP $GROUPSIZE\n";
					print RIGIDOUT "$PRINTBUFF";
				}
			}
			undef %ATOMNUM;
		}
		close(GROFILE);
	}
}

## Generate SBM.INP

if($SBMINPON =~ m/^Y$/){
	print "Going to convert $TOPFILE and $GROFILE to SBM.INP and odata for OPTIM\n";

	my %supported_directives = ( 'defaults' => '0',
                'atomtypes' => '1',
                'moleculetype' => '0',
                'atoms' => '1',
                'bonds' => '1',
                'angles' => '1',
                'dihedrals' => '1',
                'pairs' => '1',
                'exclusions' => '1',
                'system' => '1',
                'molecules' => '1',
                'position_restraints' => '1'
                );


	#read in the top file, with comments stripped

	open(FILE, "$TOPFILE") or die "Can not open $TOPFILE\n"; 
	my $string = "";
	while (<FILE>){
		my $LINE = $_;
		chomp($LINE);
		$LINE =~ s/;.*$//g; 
		$LINE =~ s/\t/ /g; 
		$LINE =~ s/^\s+|\s+$//g;
		$LINE =~ s/ +/ /g;
		# remove comments
		if($LINE ne ""){ 
		## remove blank lines
			 $string .= "$LINE\n";
		}
	}
	
	# read in the top file and check that only supported directives are included.
	my %DIRLIST;
	my @DATA=split(/\[/,$string);
	for (my $I=1;$I<=$#DATA;$I++){
		my $string1 = $DATA[$I];
		open my($fh), "<", \$string1 or die ; # reading from the data in $string
		my $first_line = <$fh>; # gives "Fred"
		$first_line =~  s/^\s//g;
		close $fh;
		my @B=split(/ /,$first_line);
		my $DIR=$B[0];
		chomp($DIR);
		$DIR =~ s/\]$//g;
			
		if(!exists $supported_directives{$DIR}){
			print "ERROR: Directive \"$DIR \" not supported\n";
			exit;
		}else{
			$DIRLIST{$DIR}=$I;
		}
	}
	
	my $PREFACTOR=332.0;
 	my $DC=80;
	my $CONCENTRATION=0.1;
	my $DHswitch=12;
	my $DHcut=15;
	
	my $SWITCHD=5.0;	
	my $CUTD=6.0;
	my $MASS;	
	# write out odata

	if(-e "odata"){print "odata already exists.  Quitting.\n"; exit;}
	open(ODATA,">odata") or die "Can not open odata\n";
	print ODATA "STEPS 100000000\nBFGSMIN 0.000001\n";

	if($RIGIDON =~ m/^Y$/){
		print ODATA "RIGIDINIT\nPOINTS\n";
	}

	open(GROFILE,"$GROFILE") or die "Can\'t open GRO file \"$GROFILE\"\n";
	$TMP=<GROFILE>;
	$TMP=<GROFILE>;
	chomp($TMP);
	my @A=split(/\s+/,$TMP);
	my $NATOMS=$A[0];
	for(my $I=0;$I<$NATOMS;$I++){
		# read a line
		my $LINE=<GROFILE>;
		my $COORDS=substr($LINE,20,24);

		$COORDS =~ s/\t/ /g; 
		$COORDS =~ s/^\s+|\s+$//g;
		$COORDS =~ s/ +/ /g;
		my @E=split(/ /,$COORDS);
		$E[0]*=10.0;
		$E[1]*=10.0;
		$E[2]*=10.0;

		print ODATA "SB $E[0] $E[1] $E[2]\n";
	}
	close(GROFILE);

	# Write out SBM.INP
	if(-e "SBM.INP"){print "SBM.INP already exists.  Quitting.\n"; exit;}
	open(OPTIMTOP,">SBM.INP") or die "Can not open SBM.INP\n";
	
	print OPTIMTOP "Structure-based topology file for use with OPTIM.  Generated by smog_optim, as part of the SMOG 2 distrubution\n";
	print OPTIMTOP "Debye-Huckel Parameters: PREFACTOR,Dialectric Constant, Monovalent Ion Concentration, DH switching distance, DH cutoff distance\n";
	print OPTIMTOP "$PREFACTOR $DC $CONCENTRATION $DHswitch $DHcut\n";
	print OPTIMTOP  "excluded volume: sigma, epsilon, switching distance, truncate distance\n";

	# Go through the directives, in order
	
	# start with atomtypes
	my %massbytype;
	my %chargebytype;
	my $c12val;
	$c12val=-1;
	my $CFL=0;
	if(!exists $DIRLIST{"atomtypes"}){
		print "ERROR: \"atomtypes\" does not appear in .top file.\n";
		exit;
	}else{
		my @C= split(/\n/,$DATA[$DIRLIST{"atomtypes"}]);
		for(my $II=1;$II<=$#C;$II++){
			my @D=split(/ /,$C[$II]);
			$massbytype{$D[0]}=$D[1];
			$chargebytype{$D[0]}=$D[2];
			if($D[2] != 0 && $CFL==0){
				print "NOTE: Charges detected.  Debye-Huckel parameters will be assigned.  You may want to double check the output.\n";
				$CFL=1;
			}
			if($c12val != -1){
				if($c12val != $D[5]){
					print "ERROR: Multiple C12 values not supported.\n";
				}
			}else{
				$c12val = $D[5]
			}
			if($D[4] != 0){
				print "ERROR: Non-specific attractive c6 term must be 0.\n";
				exit;
			}
		}
		my $EPSILON=1.0;
		my $SIGMA=10.0*($c12val/$EPSILON)**(1.0/12);
		if($SIGMA > $SWITCHD){
			print "ERROR: Switching distance must be larger than sigma\n";
			exit;
		}

		printf (OPTIMTOP "%f %f %f %f\n", $SIGMA, $EPSILON, $SWITCHD, $CUTD);

	}

	# provide information about the atoms 
	if(!exists $DIRLIST{"atoms"}){
		print "ERROR: \"atoms\" does not appear in .top file.\n";
		exit;
	}else{
		my @C= split(/\n/,$DATA[$DIRLIST{"atoms"}]);
		if($#C<1){
			print "ERROR: There must be at least 1 atom listed under the atoms directive\n";
			exit;
		}
		printf (OPTIMTOP "%i atoms\n",$#C);
		for (my $K=1;$K<=$#C;$K++){
			my @D=split(/ /,$C[$K]);
			printf (OPTIMTOP "%5i %5s %4i %5s %5s %8.5f %8.5f\n", $D[0],$D[1],$D[2],$D[3],$D[4],$chargebytype{"$D[1]"},$massbytype{$D[1]});
		}
	}

	print OPTIMTOP "\n";


	# provide information about the contacts 
	if(!exists $DIRLIST{"pairs"}){
		print "ERROR: \"pairs\" does not appear in .top file.\n";
		exit;
	}else{
		print "\tpairs directive found.\nAre 10-12, or 6-12 contacts being used? [10/6]?";
		my $TMP;
		$TMP=<STDIN>;
		chomp($TMP);
		until($TMP=~ m/^[6|10]$/){
			print "Please answer 6, or 10.\n";
			$TMP=<STDIN>;
			chomp($TMP);
		}


		my @C= split(/\n/,$DATA[$DIRLIST{"pairs"}]);
		if($#C<1){
			print "ERROR: There must be at least 1 contact listed under the pairs directive\n";
			exit;
		}
		
		my $CT=0;
		my $TEMPSTRING = "";
		for (my $K=1;$K<=$#C;$K++){
			my @D=split(/ /,$C[$K]);
			my $sigma;
			my $epsilon;
			if($D[2] != 1){
				print "ERROR: Only contacts of type 1 are supported. Quitting.\n";
				exit;
			}
			if($CONTTYPE == 10){
				$sigma=(6.0/5.0*$D[4]/$D[3])**(0.5);
				$epsilon=$D[3]/(6.0*$sigma**10);
				$sigma*=10.0;
			}elsif($CONTTYPE == 6){
				$sigma=(2.0*$D[4]/$D[3])**(1.0/6.0);
				$epsilon=$D[3]**2/(4.0*$D[4]);
				$sigma*=10.0;

			}else{ 
				print "Internal error 1: Please contact info\@smog-server.org for help.\n"; 
				exit;
			}
			if(!exists $rigidified{$D[0]} || !exists $rigidified{$D[1]} ){
				$TEMPSTRING .= sprintf ("%5i %5i %8.5f %8.5e\n", $D[0],$D[1],$sigma,$epsilon);
				$CT++;
			}else{
				unless ($rigidified{$D[0]} == $rigidified{$D[1]}){
					$TEMPSTRING .= sprintf ("%5i %5i %8.5f %8.5e\n", $D[0],$D[1],$sigma,$epsilon);
					$CT++;
				}
			}
		}

		printf (OPTIMTOP "%i contacts\n",$CT);	
		print OPTIMTOP "1 C$CONTTYPE-C12\n";
		print OPTIMTOP "$TEMPSTRING\n";
	}



	# provide information about the bonds 
	if(!exists $DIRLIST{"bonds"}){
		print "ERROR: \"bonds\" does not appear in .top file.\n";
		exit;
	}else{
		my @C= split(/\n/,$DATA[$DIRLIST{"bonds"}]);
		if($#C<1){
			print "ERROR: There must be at least 1 bond listed under the bonds directive\n";
			exit;
		}


		my $CT=0;
		my $TEMPSTRING = "";
		for (my $K=1;$K<=$#C;$K++){
			my @D=split(/ /,$C[$K]);
			$D[3]*=10;
			$D[4]*=0.01;
			if($D[2] != 1 && $D[2] != 6){
				print "ERROR: Only bonds of type 1 and 6 are supported. Quitting.\n";
				exit;
			}

			if(!exists $rigidified{$D[0]} || !exists $rigidified{$D[1]} ){
				$TEMPSTRING .= sprintf ("%5i %5i %8.5f %8.5e\n", $D[0],$D[1],$D[3],$D[4]);
				$CT++;
			}else{
				unless ($rigidified{$D[0]} == $rigidified{$D[1]}){
					$TEMPSTRING .= sprintf ("%5i %5i %8.5f %8.5e\n", $D[0],$D[1],$D[3],$D[4]);
					$CT++;
				}
			}
		}

		printf (OPTIMTOP "%i bonds\n",$CT);	
		print OPTIMTOP "$TEMPSTRING\n";

	}


	# provide information about the angles 
	if(!exists $DIRLIST{"angles"}){
		print "ERROR: \"angles\" does not appear in .top file.\n";
		exit;
	}else{
		my @C= split(/\n/,$DATA[$DIRLIST{"angles"}]);
		if($#C<1){
			print "ERROR: There must be at least 1 angle listed under the angles directive\n";
			exit;
		}

		my $CT=0;
		my $TEMPSTRING = "";
		for (my $K=1;$K<=$#C;$K++){
			my @D=split(/ /,$C[$K]);
			$D[4]*=$DEG2RAD;
			if($D[3] != 1 ){
				print "ERROR: Only angles of type 1 are supported. Quitting.\n";
				exit;
			}
			if(!exists $rigidified{$D[0]} || !exists $rigidified{$D[1]} || !exists $rigidified{$D[2]} ){
				$TEMPSTRING .= sprintf ("%5i %5i %5i %8.5e %8.5e\n", $D[0],$D[1],$D[2],$D[4],$D[5]);
				$CT++;
			}else{
				unless (($rigidified{$D[0]} == $rigidified{$D[1]}) && ($rigidified{$D[1]} == $rigidified{$D[2]})   ){
					$TEMPSTRING .= sprintf ("%5i %5i %5i %8.5e %8.5e\n", $D[0],$D[1],$D[2],$D[4],$D[5]);
					$CT++;
				}
			}
		}
		printf (OPTIMTOP "%i angles\n",$CT);
		print OPTIMTOP "$TEMPSTRING\n";
	}



	# provide information about the dihedrals 
	if(!exists $DIRLIST{"dihedrals"}){
		print "ERROR: \"dihedrals\" does not appear in .top file.\n";
		exit;
	}else{
		my @LAST;
		my @C= split(/\n/,$DATA[$DIRLIST{"dihedrals"}]);
		if($#C<1){
			print "ERROR: There must be at least 1 dihedral listed under the dihedrals directive\n";
			exit;
		}
		my $CT=0;
		my $TEMPSTRING = "";
		for (my $K=1;$K<=$#C;$K++){
			my @D=split(/ /,$C[$K]);
			$D[5]*=$DEG2RAD;
			my $D5;
			if($D[4] ==1){
				$D5=$D[5]-$PI;
			}else{
				$D5=$D[5];
			}
			if($D[4] !=1 && $D[4] !=2 ){
				print "ERROR: Only dihedrals of type 1 and 2 are supported. Quitting.\n";
				exit;
			}
			if(exists $D[7] && $D[7] == 3){
			# if N=3, it must immediately follow an N=1 dihedral
				my $DD=($D[5]/$LAST[5]-3.0);
				if($DD > 0.01 || $DD < -0.01){
					print "ERROR: N=3 dihedral has wrong angle, relative to N=1 dihedral.\n";
					print "See: $C[$K]\n";
					exit;
				}
				$DD=($D[6]/$LAST[6]-0.5);
				if($DD > 0.01 || $DD < -0.01){
					print "ERROR: N=3 dihedral has wrong weight, relative to N=1 dihedral.\n";
					print "See: $C[$K]\n";
					exit;
				}
				if($D[0] != $LAST[0] || $D[1] != $LAST[1] || $D[2] != $LAST[2] || $D[3] != $LAST[3]){
					print "ERROR: N=3 dihedral has wrong atoms, relative to N=1 dihedral.\n";
					print "See: $C[$K]\n";
					exit;
				}
				# if type 3, don't write it again, since it is handles inside OPTIM
				next; 
			}
			$D[4]= $D[4] % $PI;

			if(!exists $rigidified{$D[0]} || !exists $rigidified{$D[1]} || !exists $rigidified{$D[2]} || !exists $rigidified{$D[3]} ){
				$TEMPSTRING .= sprintf ("%5i %5i %5i %5i %1i %8.5e %8.5e\n", $D[0],$D[1],$D[2],$D[3],$D[4],$D5,$D[6]);
				$CT++;
			}else{
				unless (($rigidified{$D[0]} == $rigidified{$D[1]}) && ($rigidified{$D[1]} == $rigidified{$D[2]})   ){
					$TEMPSTRING .= sprintf ("%5i %5i %5i %5i %1i %8.5e %8.5e\n", $D[0],$D[1],$D[2],$D[3],$D[4],$D5,$D[6]);
					$CT++;
				}
			}
		@LAST=@D;
		}
		printf (OPTIMTOP "%i dihedrals\n",$CT);
		print OPTIMTOP "$TEMPSTRING\n";
	}
	my $NEXC=scalar keys %excludedlist;
	print OPTIMTOP "$NEXC exclusions\n";
	for my $exc (keys %excludedlist){
		my @A=split(/-/,$exc);
		print OPTIMTOP "$A[0] $A[1]\n";
	}
	print OPTIMTOP "\n";


	# provide information about the atoms 
	if(!exists $DIRLIST{"position_restraints"}){
		print "NOTE: \"position_restraints\" does not appear in .top file.\n";
		print OPTIMTOP "0 position restraints\n";
	}else{
		my @C= split(/\n/,$DATA[$DIRLIST{"position_restraints"}]);
		if($#C<1){
			print "ERROR: \"position_restraints\" found in .top file, but there are not restraints listed.\n";
			exit;
		}
		printf (OPTIMTOP "%i position restraints\n",$#C);
		for (my $K=1;$K<=$#C;$K++){
			my @D=split(/ /,$C[$K]);
			if($#D !=4){
				print "ERROR: Wrong number of fields in position restaint.  Offending line:\n$C[$K]\n";
			}
			if($D[1] != 1){print "ERROR: Only restraints of type 1 are supported\n Quitting.\n"; exit;} 
			# printing atom number, 6 position restraint contacts and 3 coordinates.  Restraints are xx, yy, zz, xy, xz, yz, though cross terms not yet supported.
			printf (OPTIMTOP "%5i %8.5e %8.5e %8.5e %8.5e %8.5e %8.5e %8.3f %8.3f %8.3f\n", $D[0],$D[2],$D[3],$D[4],0,0,0,$X[$D[0]][0],$X[$D[0]][1],$X[$D[0]][2]);
		}
	}
}

print "\n\n\t\tSUCCESS: OPTIM files generated without errors.\n\n";


