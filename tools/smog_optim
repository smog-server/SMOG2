use strict;
use warnings;

print <<EOT;
*****************************************************************************************
                                      smog_optim

     smog_optim is part of the SMOG 2 distribution, available at smog-server.org

Long term plan for the code:
    This tool will generate an OPTIM input file from a SMOG model

Currently:
    This code generates files necessary for rigidification routine usage in OPTIM

                       See the SMOG manual for usage guidelines.

            For questions regarding this script, contact info\@smog-server.org
*****************************************************************************************
EOT

my %GROUPS;
my %RESCOUNT;
my %ATOMSINRES;
my %rigidified;
print "Would you like to generate files necessary for rigidification code in OPTIM? [Y/N]\n";
my $TMP;
$TMP=<STDIN>;

until($TMP=~ m/^[YyNn]$/){
	print "Please answer Y, or N.\n";
	$TMP=<STDIN>;
	chomp($TMP);
}

if($TMP=~ m/^N$/){
print "quitting\n";
exit;
}

print "What is the input .gro file\n";

my $FILE=<STDIN>;
chomp($FILE);


## for now, always use a default generic definitions for rigid groups
## format: <RESIDUE NAME> <LIST OF ATOM NAMES IN GROUP>


open(MAPFILE,"$ENV{SMOG_PATH}/tools/rigidmap") or die "Can\'t open rigidmap file\n";
if(-e "rbodyconfig"){print "rbodyconfig already exists.  Will not overwrite. Quitting.\n"; exit;}
if(-e "coordsinrigid"){print "coordsinrigid already exists.  Will not overwrite. Quitting.\n"; exit;}
open(RIGIDOUT,">rbodyconfig") or die "Can\'t open rbodyconfig for writing\n";
open(RIGIDCOORDS,">coordsinirigid") or die "Can\'t open rbodyconfig for writing\n";
while(<MAPFILE>){
	my $LINE=$_;
	chomp($LINE);
	my @A=split(/\s+/,$LINE);
	my $A1=$A[0];
	if(exists $RESCOUNT{$A1}){
		print "$RESCOUNT{$A1}\n";
		$RESCOUNT{$A1}=eval($RESCOUNT{$A1})+1;
	}else{
		$RESCOUNT{$A1}=1;
	}
		$A1=$A1 . "-" . $RESCOUNT{$A1};
		print "$A1 ";
	for(my $I=1;$I<=$#A;$I++){
		$GROUPS{$A1}->[$I-1]=$A[$I];
                print "$GROUPS{$A1}->[$I-1] "
	}

	$ATOMSINRES{$A1}=$#A;

	if($ATOMSINRES{$A1}<3){
		print "Rigid group $A1 only has $ATOMSINRES{$A1} atoms. Must have at least 3.  Quitting\n";
		exit;
	}

}

my $GROUPS=%GROUPS;

# add a check to make sure that atoms don't appear in two different group


open(GROFILE,"$FILE") or die "Can\'t open file \"$FILE\"\n";

$TMP=<GROFILE>;
$TMP=<GROFILE>;
chomp($TMP);
my @A=split(/\s+/,$TMP);
my $NATOMS=$A[0];
my %ATOMNUM;
my $LINE=<GROFILE>;

my $LASTRESNUM=substr($LINE,0,5);
$LASTRESNUM =~ s/^\s+|\s+$//g;

my $ATOMNAME=substr($LINE,10,5);
$ATOMNAME =~ s/^\s+|\s+$//g;

my $NUMT=substr($LINE,15,5);
$NUMT =~ s/^\s+|\s+$//g;
$ATOMNUM{$ATOMNAME}= $NUMT;

my $LASTRESNAME=substr($LINE,5,5);
$LASTRESNAME =~ s/^\s+|\s+$//g;
my $ATOMSINRES=1;

for(my $I=1;$I<$NATOMS;$I++){
# read a line
# parse using fixed formatting
	my $LINE=<GROFILE>;
	my $RESNUM=substr($LINE,0,5);
	$RESNUM =~ s/^\s+|\s+$//g;
	my $ATOMNAME=substr($LINE,10,5);
	$ATOMNAME =~ s/^\s+|\s+$//g;
	my $ATOMNUMT=substr($LINE,15,5);
	$ATOMNUMT =~ s/^\s+|\s+$//g;
	my $RESNAME=substr($LINE,5,5);
	$RESNAME =~ s/^\s+|\s+$//g;
	my $COORDS=substr($LINE,20,24);
	print RIGIDCOORDS "$COORDS\n";
# Once done reading a residue, create the rigid groups
	if($RESNUM != $LASTRESNUM && exists $RESCOUNT{$LASTRESNAME}){
		# go through the rigid groups for that residue
		for (my $J=1;$J<=eval($RESCOUNT{$LASTRESNAME});$J++){
			my $GROUPSIZE=0;
			my $PRINTBUFF = "";;
	                my $A1=$LASTRESNAME . "-" . $J ;
			for (my $K=0;$K<$ATOMSINRES{$A1};$K++){
				if( !exists $ATOMNUM{$GROUPS{$A1}->[$K]}){
					print "Warning: $GROUPS{$A1}->[$K] atom not found in residue $LASTRESNAME$LASTRESNUM\n";
				}else{
					if(exists $rigidified{$ATOMNUM{$GROUPS{$A1}->[$K]}}){
						print "atom index $ATOMNUM{$GROUPS{$A1}->[$K]} ($LASTRESNAME$LASTRESNUM) appeared in two groups. Quitting\n";
						exit;
					}else{
						$rigidified{$ATOMNUM{$GROUPS{$A1}->[$K]}}=1;
					}
					$PRINTBUFF = $PRINTBUFF."$ATOMNUM{$GROUPS{$A1}->[$K]}\n";
					$GROUPSIZE++;
				}
			}

			if($GROUPSIZE>2){
				print "size $GROUPSIZE\n";
				print RIGIDOUT "GROUP $GROUPSIZE\n";
				print RIGIDOUT "$PRINTBUFF";
			}elsif($GROUPSIZE==1 || $GROUPSIZE==2){
				print "Only found $GROUPSIZE atoms in group $J of $LASTRESNAME$LASTRESNUM. Not adding as rigid group\n";
			}

		}
		undef %ATOMNUM;
	}


	$LASTRESNAME=$RESNAME;
	$LASTRESNUM=$RESNUM;
	$ATOMNUM{$ATOMNAME}= $ATOMNUMT;

}
# check last residue

# go through the rigid groups for that residue

if( exists $RESCOUNT{$LASTRESNAME}){
	for (my $J=1;$J<=eval($RESCOUNT{$LASTRESNAME});$J++){
		my $GROUPSIZE=0;
		my $PRINTBUFF = "";;
	        my $A1=$LASTRESNAME . "-" . $J ;
		print "\naccessing $A1\n";
		for (my $K=0;$K<$ATOMSINRES{$A1};$K++){
			if( !exists $ATOMNUM{$GROUPS{$A1}->[$K]}){
				print "Warning: $GROUPS{$A1}->[$K] atom not found in residue $LASTRESNAME$LASTRESNUM\n";
			}else{
				$PRINTBUFF = $PRINTBUFF . "$ATOMNUM{$GROUPS{$A1}->[$K]}\n";
				$GROUPSIZE++;
			}
		}
	
		if($GROUPSIZE>0){
			print "size $GROUPSIZE\n";
			print RIGIDOUT "GROUP $GROUPSIZE\n";
			print RIGIDOUT "$PRINTBUFF";
		}
	}
	undef %ATOMNUM;
}


