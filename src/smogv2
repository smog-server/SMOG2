#########################################################################################
# smog2 contains the main routines
#
#                          Structure-based Model (SMOG) software
#    This package is the product of contributions from a number of people, including:
#                 Jeffrey Noel, Mariana Levi, Mohit Raghunathan, Joyce Yang           
#                       Prasad Bandarkar, Udayan Mohanty, Ailun Wang
#                 Heiko Lammert, Ryan Hayes, Jose Onuchic & Paul Whitford
#
#                     Copyright (c) 2015, The SMOG development team at
#                        Rice University and Northeastern University
#
#              SMOG 2 & Shadow are available at http://smog-server.org
#
#          You can direct questions to info@smog-server.org, or the smog-users forum, 
#          which you can find at https://mailman.rice.edu/mailman/listinfo/smog-users
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#########################################################################################

use strict;
use warnings FATAL => 'all';
&checkForModules;
use XML::Simple;
use templateParser;
use PDB_Bonded;
use PDL;
use mathFunctions;
use setRatios;
use Getopt::Long;
Getopt::Long::Configure("pass_through");
use Data::Dumper;
use XML::SAX::ParserFactory;
use XML::Validator::Schema; 
use IPC::Open3;
use smog_common;

######################
## GLOBAL VARIABLES ##
######################
my $VERSION="2.3-pr1";
my $angToNano = 0.1;
my $OUTPUT;
my $help;
our $gen_map;
my $inputPDB="molecule.pdb"; 
my $inputFolder=""; my $bifForSCM;
my $userProvidedMap=0;
my $topFile = "";
my $groFile = "";
my $groFile4SCM = "";
my $topFile4SCM = "";
my $ContactFile;
my $shadowFile = "";
my $ndxFile = "";
my $mapOpt = "shadow";
my $numContacts = 0;
my $coarseFolder = ""; ## Coarse Grain Folder ##
my $AAdefault = 0; 
my $CAdefault = 0;
my $AAGdefault = 0; 
my $CAGdefault = 0;
my $saveSCMorig=0;
my $printversion;
my $ignoreHydrogen=0; #variable that is set when you don't want contact map generation to consider hydrogens
my $DNAME="smog";
my $backup="yes";
my $allowCG = 0;
my $nocheck = "no";
my $keep4SCM;
my $extrasfile="";
our %freeangles;
our $CGenabled=0; ## enable coarse-graining
our $setBondtoLimit=0;
our $setContacttoLimit;
our $DeleteShortContact;
our %funtypechecked;
our %presentatomtypes;
our %foundBtype;
our %foundAtype;
our %foundDtype;
our @topFileBuffer;
our @linesInDirectives;
our @linesInDirectivesWithContent;
our $inputArguments=join(' ',@ARGV);
our %Btypespresent;
our %NBtypespresent;
our %PAIRtypespresent;
our %pairtypesused;
our %fTypes;
our %fTypesArgNum;
our %directives;
our @directivesList;
our %extraatomtypes;
our %bondParseSeen;
our %angleParseSeen;
our %dihParseSeen;
our %contactParseSeen;
our $normalizevals;
#######END GLOBAL DEFS#######


#######MAIN PROGRAM####### 

quit_init();
note_init();

setglobals();

header();

parse_args();

print "Parsing templates files...\n";
parseTemplatesAndPDB($inputFolder,$inputPDB,$allowCG);
if($CGenabled == 0 || ($CGenabled == 1 && $userProvidedMap == 0)) {
	# either no CG, or CG and need to generate a map
	printBondedTopOutput($inputPDB,$groFile,$groFile4SCM,$ndxFile,$userProvidedMap);
} 

appendDefaults();

# generate contact map
if($userProvidedMap == 0) { #use SCM.jar if user doesn't provide a map
	printTop($topFile4SCM);
	generateContactMap($groFile4SCM,$ndxFile,$shadowFile,$topFile4SCM);
	if(! defined $keep4SCM){
		# this is only used for smog-check
		`rm $groFile4SCM $topFile4SCM`;
	}
}

# do CGing, if needed
if($CGenabled == 1) { #Coarse graining, do everything over with new templates
    	clearBifMemory();
	clearPDBMemory();
	undef %presentatomtypes;
	$allowCG = 1;
	print "\nParsing templates for coarse graining... ";
	$inputFolder = $coarseFolder;
	parseTemplatesAndPDB($coarseFolder,$inputPDB,$allowCG);
	printBondedTopOutput($inputPDB,$groFile,$groFile4SCM,$ndxFile,$userProvidedMap);
	appendDefaults();
}

appendContacts($shadowFile,$ContactFile,$userProvidedMap,$saveSCMorig);

printTop($topFile);
print "\nYour Structure-based Model is ready!\n\nFiles generated: \n\t$topFile\n\t$groFile\n\t$ndxFile\n";
	if(!$userProvidedMap) { print "\t$shadowFile\n"; }
	if($CGenabled && !$userProvidedMap) { print "\t$shadowFile.CG\n"; }
	printCitation();

warnsummary();

###### END OF MAIN PROGRAM ######

######SUBROUTINES######
sub setglobals {
	## this is the array that defines how function names are converted to gromacs function types
	%fTypes = ('bond_harmonic' => '1',
		'bond_bytype' => '-1',
		'bond_type6' => '6',
		'angle_harmonic' => '1',
		'angle_bytype' => '-1',
		'angle_free' => '0',
		'dihedral_cosine'=>'1',
		'dihedral_cosine4'=>'4',
		'dihedral_harmonic' => '2',
		'dihedral_bytype' => '-1',
		'dihedral_free' => '0',
		'contact_free'=>'0',
		'contact_1'=>'1',
		'contact_2'=>'1',
		'contact_gaussian'=>'6'
		);
	# note, only bonds are properly set in fTypesArgNum.  The rest will be updated later.
	%fTypesArgNum = ('bond_harmonic' => '2',
		'bond_bytype' => '0',
		'bond_type6' => '2',
		'angle_harmonic' => '2',
		'angle_bytype' => '0',
		'angle_free' => '0',
		'dihedral_cosine'=>'3',
		'dihedral_cosine4'=>'3',
		'dihedral_harmonic' => '2',
		'dihedral_bytype' => '0',
		'dihedral_free' => '0',
		'contact_free'=>'0',
		'contact_1'=>'4',
		'contact_2'=>'4',
		'contact_gaussian'=>'4'
		);

	## this is the topfile buffer stuff
	%directives = ("comments",1,"defaults",2,"atomtypes",3,"bondtypes",4,"angletypes",5,"dihedraltypes",6,"nonbond_params",7,"moleculetype",8,"atoms",9,"bonds",10,"angles",11,"dihedrals",12,"pairs",13,"exclusions",14,"position_restraints",15,"system",16,"molecules",17);
	@directivesList=("comments","defaults","atomtypes","bondtypes","angletypes","dihedraltypes","nonbond_params","moleculetype","atoms","bonds","angles","dihedrals","pairs","exclusions","position_restraints","system","molecules");
}

sub parse_args {
	## parse command line options ##
	# -o output top file name, default is smog.top
	my $tempcheckoff;
	usage() if (@ARGV < 1 || !GetOptions('help|?' => \$help, 
		'o=s' => \$topFile, 
		't=s' => \$inputFolder, 
		'i=s' => \$inputPDB, 
		'g=s' => \$groFile,
		'c=s' => \$ContactFile, 
		'SCMorig' => \$saveSCMorig, 
		's=s' => \$shadowFile, 
		'n=s' => \$ndxFile, 
		'ignH' => \$ignoreHydrogen,  
		'gen_map=s' => \$gen_map,
		'tCG=s' => \$coarseFolder, 
		'CA'=> \$CAdefault, 
		'AA' => \$AAdefault, 
		'CAgaussian'=> \$CAGdefault, 
		'AAgaussian' => \$AAGdefault, 
		'dname=s' => \$DNAME, 
		'warn=i' => \$maxwarn, 
		'backup=s' => \$backup, 
		'limitbondlength' => \$setBondtoLimit, 
		'limitcontactlength' => \$setContacttoLimit, 
		'deleteshortcontacts' => \$DeleteShortContact, 
		'nocheck'=> \$tempcheckoff,
		'keep4SCM'=> \$keep4SCM,
		'<>' => \&usage, 
		'v' => \$printversion)
	          or defined $help 
	          or !defined $inputPDB 
	          or (!defined $inputFolder  && !defined $coarseFolder));
	
	if($printversion){
		print "Version $VERSION\n";
		exit;
	}
	
	warninfo();
	if(defined $tempcheckoff){
		smog_note("-nocheck was issued. Will not cross check the templates for consistency in energetics declarations. Use this option at your own risk...");
		$nocheck="yes";
	}

	if(defined $setContacttoLimit && defined $DeleteShortContact){
		smog_quit("Can not use -limitcontactlength and -deleteshortcontacts at the same time.");
	}

	
	if(!defined $setContacttoLimit){
		$setContacttoLimit=0;
	}
	if(!defined $DeleteShortContact){
		$DeleteShortContact=0;
	}
	
	if($coarseFolder ne "" and $inputFolder eq ""){
		smog_quit("When using a CG model with -tCG, you must also specify the model to be used when calculating the contact map by invoking the option -t. Check -help for usage information. ");
	}
	
	my $numdefaults=$CAdefault+$AAdefault+$AAGdefault+$CAGdefault;
	if($inputFolder eq "" && $numdefaults==0){
		smog_quit("No model specified. You must use either -t, -AA, or -CA. Try -help for usage information.");
	}
	
	if($coarseFolder ne "") { $CGenabled = 1; }
	
	if($backup ne "yes" and $backup ne "no"){
		smog_quit("Can not understand -backup flag. Usage -backup [yes/no]");
	}elsif($backup eq "no"){
		print "-backup no issued.  Will overwrite any existing output files.\n";
	}
	
	if($numdefaults > 1){
		smog_quit('Can not select more than one default model at a time.');
	}
	if($CAdefault == 1 and defined $ContactFile){
		smog_quit('Can not use -c and -CA options at the same time.');
	}
	if(defined $ContactFile and $CGenabled == 1){
		smog_quit('Can not use -tCG and -c options at the same time.');
	}
	if($CAdefault == 1 and $CGenabled == 1){
		smog_quit('Can not use -tCG and -CA options at the same time.');
	}
	if($CAGdefault == 1 and $CGenabled == 1){
		smog_quit('Can not use -tCG and -CAgaussian options at the same time.');
	}
	if($CAdefault == 1 and $inputFolder ne ""){
		smog_quit('Can not use -CA and -t options at the same time.');
	}
	if($CAGdefault == 1 and $inputFolder ne ""){
		smog_quit('Can not use -CAgaussian and -t options at the same time.');
	}
	
	if($AAdefault == 1 and $inputFolder ne ""){
		smog_quit('Can not use -AA and -t options at the same time.');
	}
	if($AAGdefault == 1 and $inputFolder ne ""){
		smog_quit('Can not use -AAgaussian and -t options at the same time.');
	}
	if($numdefaults and $coarseFolder ne ""){
		smog_quit('Can not use a default model with -tCG.');
	}
	
	if($CAdefault == 1){
		print "\n -CA given. Will use the default Calpha SMOG model provided with the distribution.\n";
		my $SMOGDIR=$ENV{'SMOG_PATH'};
		$inputFolder="$SMOGDIR/SBM_AA";
		$coarseFolder="$SMOGDIR/SBM_calpha";
		print "Will try to use templates found in \n$inputFolder\n and\n$coarseFolder\n\n";
		if(! -d $inputFolder){
			smog_quit("$inputFolder is not a valid template directory.");
		}
		if(! -d $coarseFolder){
			smog_quit("$coarseFolder is not a valid template directory.");
		}
		$CGenabled=1;
	}
	if($AAdefault == 1){
		print "\n-AA given. Will use the default All-Atom SMOG model provided with the distribution.\n";
		my $SMOGDIR=$ENV{'SMOG_PATH'};
		$inputFolder="$SMOGDIR/SBM_AA";
		print "Will try to use templates found in \n$inputFolder\n\n";
		if(! -d $inputFolder){
			smog_quit("$inputFolder is not a valid template directory.");
		}
	}
	
	if($CAGdefault == 1){
		print "\n -CAgaussian given. Will use the default Calpha SMOG model with gaussian contacts, as provided with the distribution.\n";
		my $SMOGDIR=$ENV{'SMOG_PATH'};
		$inputFolder="$SMOGDIR/SBM_AA";
		$coarseFolder="$SMOGDIR/SBM_calpha+gaussian";
		print "Will try to use templates found in \n$inputFolder\n and\n$coarseFolder\n\n";
		if(! -d $inputFolder){
			smog_quit("$inputFolder is not a valid template directory.");
		}
		if(! -d $coarseFolder){
			smog_quit("$coarseFolder is not a valid template directory.");
		}
		$CGenabled=1;
	}
	if($AAGdefault == 1){
		print "\n-AAgaussian given. Will use the default All-Atom SMOG model with gaussian contacts, as provided with the distribution.\n";
		my $SMOGDIR=$ENV{'SMOG_PATH'};
		$inputFolder="$SMOGDIR/SBM_AA+gaussian";
		print "Will try to use templates found in \n$inputFolder\n\n";
		if(! -d $inputFolder){
			smog_quit("$inputFolder is not a valid template directory.");
		}
	}
	
	if(defined $gen_map) {
		# read the bif, generate a map file and exit
		if (-e $gen_map) {
			smog_quit("$gen_map exists, will not overwrite");
		}
		parseTemplatesAndPDB($inputFolder,$inputPDB,0);
	}
	
	# if a contact file is provided, then don't calculate contacts
	if(defined $ContactFile){
		$userProvidedMap=1;
	}
	
	## Ensure we only write out files with gromacs-compatible suffices
	if($topFile eq ""){$topFile=$DNAME};
	if($groFile eq ""){$groFile=$DNAME};
	$groFile4SCM=$groFile . "4SCM.gro";
	$topFile4SCM=$topFile . "4SCM.top";
	if($shadowFile eq ""){$shadowFile=$DNAME};
	if($ndxFile eq ""){$ndxFile=$DNAME};
	
	$topFile=checksuffix($topFile,".top");
	$groFile=checksuffix($groFile,".gro");
	$shadowFile=checksuffix($shadowFile,".contacts");
	$ndxFile=checksuffix($ndxFile,".ndx");
	
	
	## check if files exist
	# things we don't want to overwrite
	if($backup eq "yes"){
		foreach my $filen($topFile, $groFile, $groFile4SCM, $shadowFile, $ndxFile){
			checkalreadyexists($filen);
		}
	}
	 
	# files we will read
	foreach my $filen($inputPDB,$ContactFile){
		if(defined $filen  && ! -f $filen){
			smog_quit("Can't find file $filen !! ");
		}
	}
	
	# directories we will access
	foreach my $filen($inputFolder,$coarseFolder){
		if($filen ne "" && ! -d $filen){
			smog_quit ("Can't find directory $filen !! ");
		}
	}

	if($CGenabled == 0) {
		print "\n*****************************************************\n";
		print   "******* ALL-ATOM SMOG MODEL WILL BE GENERATED *******";
		print "\n*****************************************************\n";
	} else {
		print "\n*****************************************************\n";
		print   "**** COARSE-GRAINED SMOG MODEL WILL BE GENERATED ****";
		print "\n*****************************************************\n";
	}
}

sub printTop {
	my ($topFile) = @_;
	open($OUTPUT, ">$topFile");
	my $i;
	my $directive;
	foreach $directive (@directivesList) { #order of list defines order in top
		if($directive eq "comments") { 
			foreach $i (1 .. scalar @{$topFileBuffer[$directives{$directive}]}-1) {
				my $nextcomment = $topFileBuffer[$directives{$directive}][$i][0];
				$nextcomment =~ s/^\s*;\s*//; #remove all semicolons at the beginning
				$nextcomment =~ s/\\n;*/\n; /; #add requested newlines 
				print $OUTPUT "; ".$nextcomment; #append semicolon and space before each comment
			}
		}
		elsif($linesInDirectivesWithContent[$directives{$directive}] > 1) { # print if the section has more than a header and comments
			foreach $i (0 .. scalar @{$topFileBuffer[$directives{$directive}]}-1) { 
				print $OUTPUT $topFileBuffer[$directives{$directive}][$i][0];
			}
		}
	}
	close($OUTPUT);
}

# utility method to set all the initial directive comments
sub initializeDirectives {
	my($inputFolder,$inputPDB) = @_;
	for (keys %directives) { 
		$linesInDirectives[$directives{$_}]=0; 
		$linesInDirectivesWithContent[$directives{$_}]=0; 
		#need this because we are going to output a top without pairs but want it to not die when it is not initialized
		push @{$topFileBuffer[$directives{$_}][$linesInDirectives[$directives{$_}]++]}, ""; 
	}
	my $hostdate=printhostdate();
	addToTop("comments", "Structure-based \"SMOG\" model for use with GROMACS, NAMD, or openMM\n");
	addToTop("comments", "Generated by the SMOG tool version $VERSION\n");
	addToTop("comments", "$hostdate");
	addToTop("comments", "SMOG2 run with the following flags: $inputArguments\n");	
	addToTop("defaults", "\n[ defaults ]\n");
	addToTop("bonds","\n[ bonds ]\n");
	addToTop("bonds",";ai\taj\tfunc\t r0(nm)\t         Kb\n");
	addToTop("angles","\n[ angles ]\n");
	addToTop("angles",";ai\taj\tak\tfunc\t th0(deg)        Ka\n");
  	addToTop("dihedrals","\n[ dihedrals ]\n");
  	addToTop("dihedrals",";ai\taj\tak\tal\tfunc\t phi0(deg)       Kd              mult\n");
	addToTop("pairs","\n[ pairs ]\n");
	addToTop("exclusions","\n[ exclusions ]\n");
	addToTop("exclusions",";ai	aj\n");
	addToTop("atomtypes","\n[ atomtypes ] \n");
	addToTop("bondtypes","\n[ bondtypes ] \n");
	addToTop("angletypes","\n[ angletypes ] \n");
	addToTop("dihedraltypes","\n[ dihedraltypes ] \n");
	addToTop("nonbond_params","\n[ nonbond_params ]\n");
	if($interactions->{"gmx-combination-rule"}==1){
		addToTop("nonbond_params",";ai     aj    func    c6       c12\n");
		addToTop("atomtypes","; name  mass     charge    ptype c6            c12\n");
		addToTop("pairs",";ai\taj\ttype\t A               B\n");
	}elsif($interactions->{"gmx-combination-rule"}==2){
		addToTop("nonbond_params",";ai     aj    func    sigma       epsilon\n");
		addToTop("atomtypes","; name  mass     charge    ptype  sigma   epsilon\n");
		addToTop("pairs",";ai\taj\ttype\tsigma\t\tepsilon\n");
	}
	addToTop("position_restraints","\n[ position_restraints ]\n");
	addToTop("position_restraints",";ai    func    kx    ky   kz\n");
	addToTop("atoms","\n[ atoms ]\n");
	addToTop("atoms",";  nr        type   resnr residue atom   cgnr   charge\n");
	addToTop("moleculetype","\n[ moleculetype ]\n");
	addToTop("moleculetype","; name            nrexcl\n");
	addToTop("moleculetype","  Macromolecule   3\n");
	addToTop("system","\n[ system ]\n");
	addToTop("system","; name\n");
	addToTop("system","  Macromolecule\n");
	addToTop("molecules","\n[ molecules ]\n");
	addToTop("molecules","; name            #molec\n");
	addToTop("molecules","  Macromolecule   1\n");
}

#adds something to the topfile at the bottom of a directive
sub addToTop {
	my($directive,$stuff) = @_;
	$linesInDirectivesWithContent[$directives{$directive}]+= hascontent($stuff);
	push  @{$topFileBuffer[$directives{$directive}][$linesInDirectives[$directives{$directive}]++]}, $stuff;
}

#read file "extras" in template directory
sub addExtras {
	my ($filename) = @_;
	my %foundNBe;
	if( -e $filename){
		print "\nAdding extras information\n\n";
		open(EXTRA,"$filename");
		my $line = "";
		my $directive;my $stuff;my @tokens;
		while($line = <EXTRA>)
		{
			my ($A,$B)=checkcomment($line);
			if($A eq ""){next;}  # skip the line if it is only a comment
		    	@tokens = split('<',$line);
			$directive = $tokens[0];
			$directive =~ s/^\s+|\s+$//g;
			$stuff = $tokens[1];
			$stuff =~ s/^\s+|\s+$//g;
			# check that nonbonded params are only added if the atom types are present

			if($directive eq "atomtypes"){
		    		my @ltokens = split('<',$A);
				if(@ltokens ==1){
					# if it is just a comment, save.
					addToTop($directive,$stuff."\n");
					next;	
				}
				my $lstuff=$ltokens[1];
				$lstuff =~ s/^\s+|\s+$//g;
				my @entries = split(/\s+/,$lstuff);
				if(defined $presentatomtypes{$entries[0]} ){
					# this atomtype is found in the system. store the extra info
					$extraatomtypes{$entries[0]}=$lstuff;
				}
				next;
			}

			if($directive eq "nonbond_params"){
		    		my @ltokens = split('<',$A);
				if(@ltokens ==1){
					# if it is just a comment, save.
					addToTop($directive,$stuff."\n");
					next;	
				}
				my $lstuff=$ltokens[1];
				$lstuff =~ s/^\s+|\s+$//g;
				my @tarray=split(/\s+/,$lstuff);
				if(@tarray < 5){
					smog_quit("nonbond_params defined in extras file, but too few parameters are given. Offending line:$line");
				}
				unless($tarray[2]  =~ /^[1-3]$/){
					smog_quit("In extras file, only nonbond_param types 1-3 are supported. Offending line:$line");
				}
				if($tarray[2]==1 && @tarray!=5){
					smog_quit("In extras file, nonbond_param defined with nbtype 1. Must have 5 parameters. Offending line:$line");
				}
				if($tarray[2]==3 && @tarray!=20){
					smog_quit("In extras file, nonbond_param defined with nbtype 3. Must have 20 parameters. Offending line:$line");
				}
				if(!defined $presentatomtypes{$tarray[0]} || !defined $presentatomtypes{$tarray[1]}){
					next;
				}	
				# since they are both defined, we will keep a record of them.
				my $f;
				if($tarray[0] lt $tarray[1]){
					$f = $tarray[0] . "-" . $tarray[1];
				}else{
					$f = $tarray[1] . "-" . $tarray[0];
				}
				$foundNBe{$f}=1;

			}
			if($directive eq "bondtypes"){
		    		my @ltokens = split('<',$A);
				if(@ltokens ==1){
					# if it is just a comment, save.
					addToTop($directive,$stuff."\n");
					next;	
				}
				my $lstuff=$ltokens[1];
				$lstuff =~ s/^\s+|\s+$//g;
				my @tarray=split(/\s+/,$lstuff);
				if(@tarray < 5 ){
					smog_quit("bondtypes defined in extras file, but too few parameters are given. Offending line:$line");
				}
				unless($tarray[2]  =~ /^[1-9]$|^10$/){
					smog_quit("In extras file, only bondtypes types 1-10 are supported. Offending line:$line");
				}
				if($tarray[2]==1 && @tarray!=5){
					smog_quit("In extras file, bondtypes defined with nbtype 1. Must have 5 parameters. Offending line:$line");
				}
				unless(defined $presentatomtypes{$tarray[0]} &&  defined $presentatomtypes{$tarray[1]}){
					next;
				}	
				# since they are both defined, we will keep a record of them.
				# save the type hash
				$foundBtype{"$tarray[0]-$tarray[1]"}=1;
				$foundBtype{"$tarray[1]-$tarray[0]"}=1;
			}
			if($directive eq "angletypes"){
		    		my @ltokens = split('<',$A);
				if(@ltokens ==1){
					# if it is just a comment, save.
					addToTop($directive,$stuff."\n");
					next;	
				}
				my $lstuff=$ltokens[1];
				$lstuff =~ s/^\s+|\s+$//g;
				my @tarray=split(/\s+/,$lstuff);
				if(@tarray < 6 ){
					smog_quit("angletypes defined in extras file, but too few parameters are given. Offending line:$line");
				}
				unless($tarray[3]  =~ /^[1-6]$|^8$|^10$/){
					smog_quit("In extras file, only angletypes types 1-6, 8 and 10 are supported. Offending line:$line");
				}
				if($tarray[3]==1 && @tarray!=6){
					smog_quit("In extras file, angletypes defined with nbtype 1. Must have 6 parameters. Offending line:$line");
				}
				unless(defined $presentatomtypes{$tarray[0]} && defined $presentatomtypes{$tarray[1]} && defined $presentatomtypes{$tarray[2]}){
					next;
				}	
				# since they are both defined, we will keep a record of them.

				$foundAtype{"$tarray[0]-$tarray[1]-$tarray[2]"}=1;
				$foundAtype{"$tarray[2]-$tarray[1]-$tarray[0]"}=1;
			}
			if($directive eq "dihedraltypes"){
		    		my @ltokens = split('<',$A);
				if(@ltokens ==1){
					# if it is just a comment, save.
					addToTop($directive,$stuff."\n");
					next;	
				}
				my $lstuff=$ltokens[1];
				$lstuff =~ s/^\s+|\s+$//g;
				my @tarray=split(/\s+/,$lstuff);
				if(@tarray < 7 ){
					smog_quit("dihedraltypes defined in extras file, but too few parameters are given. Offending line:$line");
				}
				unless($tarray[4]  =~ /^[1-5]$|^[89]$|^1[01]$/){
					smog_quit("In extras file, only angletypes types 1-5, 8, 9, 10 and 11 are supported. Offending line:$line");
				}
				if((!defined $presentatomtypes{$tarray[0]} && $tarray[0] ne "X") || (!defined $presentatomtypes{$tarray[1]} && $tarray[1] ne "X") || (!defined $presentatomtypes{$tarray[2]} && $tarray[2] ne "X") || (!defined $presentatomtypes{$tarray[3]} && $tarray[3] ne "X") ){
					next;
				}	
				# since they are both defined, we will keep a record of them.
				$foundDtype{"$tarray[0]-$tarray[1]-$tarray[2]-$tarray[3]"}=1;
				$foundDtype{"$tarray[3]-$tarray[2]-$tarray[1]-$tarray[0]"}=1;
			}
			addToTop($directive,$stuff."\n");
		}
	}
	if(exists $interactions->{"nbfunc"} && $interactions->{"nbfunc"} == 3){
	# type 3 is not defined for official versions of gromacs. We have added routines in a SMOG-supported version, in which effective potentials are defined for nonbonded interactions. These effective potentials are defined as type 3. Since there are no known combination rules for the effective potentials, the nonbonded params need to be given for every possible type of combination.  We will check that this condition is satisfied, here.
		foreach my $t1(keys %presentatomtypes){	
			foreach my $t2(keys %presentatomtypes){	
				my $f;
				if($t1 lt $t2){
					$f = $t1 . "-" . $t2;
				}else{
					$f = $t2 . "-" . $t1;
				}
				if(!exists $foundNBe{$f}){
					smog_quit("nbtype 3 is being used, yet not all possible nonbond_params are given in extras file. Did not find params for atomtype pair $f");
				}
			}
		}
	}
}

sub checkExtras {
	my ($filename) = @_;
	open(EXTRA,"$filename");
	my $line = "";
	my $directive;my $stuff;my @tokens;
	while($line = <EXTRA>)
	{
		my ($A,$B)=checkcomment($line);
		if($A eq ""){next;}  # skip the line if it is only a comment
	    	@tokens = split('<',$line);
		if(scalar @tokens > 2) {
			smog_quit("Line in extras file: $filename contains more than one instance of character '<'. Offending line:\n $line");
		}
		$directive = $tokens[0];
		$directive =~ s/^\s+|\s+$//g;
		if(!exists $directives{$directive}) {
			smog_quit("extras file: $filename has a non-valid directive \"$directive\". Check for typos or add directive to directivesList in src/smogv2.");			
		}
	}
}

# Combined bond calculation,sorting, and printing
sub printOrderedBonds
{

	my($bondFunctHandle1,$whichPDL1,$bondHandle2,$whichPDL2,$indexhandle,$allatoms) = @_;
	my @bondCache; ## CACHE BONDS TO ORDER

	## Cache Bonds ##
	calculateBonds1($bondFunctHandle1,$whichPDL1,\@bondCache,$indexhandle,$allatoms);
	calculateBonds2($bondHandle2,$whichPDL2,\@bondCache,$indexhandle);
	## Sort bonds by i then j ## 
	@bondCache = sort {($a->{"i"} <=> $b->{"i"}) || ($a->{"j"} <=> $b->{"j"}) } @bondCache;

	## Print our sorted bonds ##
	foreach my $p(@bondCache)
	{
		addToTop("bonds",$p->{"v"});
	}
}

# call  calculateBondsHelper1() for each residue defined in templates
sub calculateBonds1
{
	my($bondFunctHandle,$whichPDL,$bondCache,$indexhandle,$allatoms) = @_;
	foreach my $res(keys %{$bondFunctHandle}){
	       if(!exists $whichPDL->{$res}){next;}
	       calculateBondsHelper1($bondFunctHandle->{$res},$whichPDL->{$res},$bondCache,$indexhandle,$allatoms);
	}
}

#call connCalculateBondsHelper() for each chain in PDB
sub calculateBonds2
{
	my($bondHandle,$whichPDL,$bondCache,$indexhandle) = @_;
	foreach my $chain(keys %{$bondHandle})
	{
		calculateBondsHelper2($bondHandle->{$chain},$whichPDL->{$chain},$bondCache,$indexhandle);
	
	}
}

sub calculateBondsHelper1
{
	my($bondHash,$inputPDL,$bondCache,$indexhandle,$allatoms) = @_;
	my $bondArr = $bondHash->{"bonds"};
	my $bondFunc =$bondHash->{"functions"};
	my $bondIndex = 0;
	foreach my $bonds(@{$bondArr})
	{
	       my ($atomOne,$atomTwo) = split("-",$bonds);
	       my $outer = slice($inputPDL,"0:2,$atomOne,:")-slice($inputPDL,"0:2,$atomTwo,:");
	       my @bondList = (sqrt(inner($outer,$outer))*$angToNano)->flat()->list();
	       my @indexList1 = slice($inputPDL,"3:3,$atomOne,:")->flat()->list();
	       my @indexList2 = slice($inputPDL,"3:3,$atomTwo,:")->flat()->list();
	       for(my $i=0;$i<scalar(@bondList);$i++)
	       {
			my $I1=$indexList1[$i];
			my $I2=$indexList2[$i];
			my $val=bondOutput($bondFunc->[$bondIndex],$I1,$I2,$bondList[$i],$indexhandle,$allatoms);
			if(!$val){next;}
			# i,j are meta data
	 		push @{$bondCache}, {'i' => $I1,'j' => $I2, 'v' => $val};
		}
	       	$bondIndex++;
	
	}
}

sub calculateBondsHelper2
{
	my($bondInfo,$inputPDL,$bondCache,$indexhandle) = @_;
	my $size = $bondInfo->dim(1);
	for(my $i=0;$i<$size;$i++)
	{
		my $atomOne = sclr(slice($bondInfo,"0:0,$i:$i"));
		my $atomTwo = sclr(slice($bondInfo,"1:1,$i:$i")); 
		my $func = sclr(slice($bondInfo,"2:2,$i:$i"));
		my $outer = slice($inputPDL,"0:2,$atomOne,:")-slice($inputPDL,"0:2,$atomTwo,:");
		my $output = sclr(sqrt(inner($outer,$outer))*$angToNano);
		$atomOne = sclr(slice($inputPDL,"3:3,$atomOne,:"));
		$atomTwo = sclr(slice($inputPDL,"3:3,$atomTwo,:"));
		my $val=bondOutput(intToFunc("bonds",$func,""),$atomOne, $atomTwo,$output,$indexhandle,0);
		if(!$val){next;}
		push @{$bondCache}, {'i' => $atomOne,'j' => $atomTwo, 'v' => $val};
	}
}

# Convert internal bond function format to gromacs function format,
sub bondOutput
{
	my($inputFunc,$i,$j,$values,$indexhandle,$allatoms) = @_;
	if(!$inputFunc){smog_quit ("BONDOUTPUT::NO FUNCTION DEFINED");}
	## Remove white spaces from string ##
	$inputFunc =~ s/^\s+|\s+$//g;
	## If $input contains a + ##
	my @funcs = split(/\+/,$inputFunc); ## split combination of functions
	my $outputString="";
	my @paramArr;
	my $fType=""; my $formattedString;
	       ## Parse each part of the function ##
	foreach my $fun(@funcs){
		my $paramFormat="";
		($fType,@paramArr) = bondFuncParser($fun);
		## $paramArr[0] is bond length
		if($fType == -1){
			# this mean bond_bytype was used
			# don't write distances or strengths. Make gromacs use bondtype
			# since we are not writing a distance, let's check and make sure this pair has a bondtype provided
			&checkbondtype($i,$j,$allatoms); 
			$formattedString = sprintf("%d\t%d",$i,$j);
			$outputString = "$outputString$formattedString\n";
        		if($values < $interactionThreshold->{"bonds"}->{"shortBond"}
        		|| $values > $interactionThreshold->{"bonds"}->{"longBond"}){
				my $DIST=int($values*100)/100.0;
				my %reflist=%{$indexhandle};
				if(!exists $reflist{$i} || !exists $reflist{$j}){
					smog_quit("Internal error 3.  Please inform smog team");
				}
				my $i1=$reflist{$i};
				my $j1=$reflist{$j};
				smog_note("Distance of $DIST nm calculated for atom pair $i $j (gro indices.  Or, lines $i1 and $j1 of PDB file) is outside of the bond threshold range. Since the parameters for this interaction will be read from bondtypes, energy minimization will fix the structure.  However, it is possible that there is a problem with the input PDB (e.g. residue numbering error).");
			}
		}else{
			# by default, assume we will replace and evaluate the distance.
			my $dosub=0;
			if($paramArr[0] !~ m/\?/){
				# nothing to sub.  Just use the value given in the .b file
				$dosub=1;
			}
			$paramArr[0]=evalsub($paramArr[0],$values);
			if($dosub==1){
				if(abs($paramArr[0]-$values)/$paramArr[0] > 0.1){
					my %reflist=%{$indexhandle};
					my $i1=$reflist{$i};
					my $j1=$reflist{$j};
					my $DIST=int($values*100)/100.0;
					smog_note("Distance of $DIST nm calculated for atom pair $i $j (gro indices.  Or, lines $i1 and $j1 of PDB file). This differs by more than 10 percent from the value explicitly given in the templates ($values). This may mean there is something strange with your structure.");
				}
			}
        		## Check bonds threshold ##
        		if($values < $interactionThreshold->{"bonds"}->{"shortBond"}
        		|| $values > $interactionThreshold->{"bonds"}->{"longBond"} && $dosub==0){
				#note, only reset the distance and/or check it, if the templates don't define a specific value (i.e. $dosub==0)
				my $DIST=int($values*100)/100.0;
				my %reflist=%{$indexhandle};
				if($setBondtoLimit){
					if(!exists $reflist{$i} || !exists $reflist{$j}){
						smog_quit("Internal error 2.  Please inform smog team");
					}
					my $i1=$reflist{$i};
					my $j1=$reflist{$j};
	 				if($paramArr[0] < $interactionThreshold->{"bonds"}->{"shortBond"}){
	  					$paramArr[0]=$interactionThreshold->{"bonds"}->{"shortBond"};
	  					print "$paramArr[0] nm\n\n";
	 				}elsif($paramArr[0] > $interactionThreshold->{"bonds"}->{"longBond"}){
	  					$paramArr[0]=$interactionThreshold->{"bonds"}->{"longBond"};
	  					print "$paramArr[0] nm\n\n";
	 				}
					smog_note("Distance of $DIST nm calculated for atom pair $i $j (gro indices.  Or, lines $i1 and $j1 of PDB file). This is outside of bond threshold range. -limitbondlength is being used, will set length to: $paramArr[0]");
				}else{
					if(!exists $reflist{$i} || !exists $reflist{$j}){
						smog_quit("Internal error 3.  Please inform smog team");
					}
					my $i1=$reflist{$i};
					my $j1=$reflist{$j};
					smog_quit("Distance of $DIST nm calculated for atom pair $i $j (gro indices.  Or, lines $i1 and $j1 of PDB file). This is outside of bond threshold range.");
				}
        		}	
## Format output <i j function p1 p2 ... pn>
			foreach(@paramArr){$paramFormat="$paramFormat %12.9e";}
			$formattedString = sprintf("%d\t%d\t%d\t$paramFormat",$i,$j,$fType,@paramArr);
			$outputString = "$outputString$formattedString\n";
       		}
	}
	return $outputString;
}

sub checkbondtype
{
	my ($i,$j,$allatoms)=@_;
	my $found=0;
	# only check that the pair has a bondtype, if the hash is defined
	if($allatoms ne "0"){
		my $typei=$allatoms->{$i}->[0];
		my $typej=$allatoms->{$j}->[0];
		foreach my $I("X",$typei)
		{
			foreach my $J("X",$typej)
			{
				my $nm="$I-$J";
				if(defined $foundBtype{$nm})
				{
					$found=1;
					return;
				}
			}
		}
		if($found ==0){
			smog_quit("Default bond interaction not provided for pair $i-$j (types $typei and $typej)");
		}
	}
}

sub checkangletype
{
	my ($i,$j,$k,$allatoms)=@_;
	my $found=0;
	# only check that the pair has a bondtype, if the hash is defined
	my $typei=$allatoms->{$i}->[0];
	my $typej=$allatoms->{$j}->[0];
	my $typek=$allatoms->{$k}->[0];
	foreach my $I("X",$typei)
	{
		foreach my $J("X",$typej)
		{
			foreach my $K("X",$typek)
			{
				my $nm="$I-$J-$K";
				if(defined $foundAtype{$nm})
				{
					$found=1;
					return;
				}
			}
		}
	}
	if($found ==0){
		smog_quit("Default angle interaction not provided for pair $i-$j-$k (types $typei, $typej, $typek)");
	}
}

sub checkdihedraltype
{
	my ($i,$j,$k,,$l,$allatoms)=@_;
	# only check that the pair has a bondtype, if the hash is defined
	my $typei=$allatoms->{$i}->[0];
	my $typej=$allatoms->{$j}->[0];
	my $typek=$allatoms->{$k}->[0];
	my $typel=$allatoms->{$l}->[0];
	my $found=0;
	foreach my $I("X",$typei)
	{
		foreach my $J("X",$typej)
		{
			foreach my $K("X",$typek)
			{
				foreach my $L("X",$typel)
				{
					my $nm="$I-$J-$K-$L";
					if(defined $foundDtype{$nm})
					{
						$found=1;
						return;
					}
				}
			}
		}
	}
	if($found ==0){
		smog_quit("Default dihedral interaction not provided for pair $i-$j-$k-$l (types $typei, $typej, $typek, $typel)");
	}
}

# Given a user defined function, parse values
sub bondFuncParser
{
	my($bondFunc) = @_;
	my $fType;my @paramArr;my $directive;
	my $funcName = ""; my $params = "";
	if(exists $bondParseSeen{$bondFunc}{"fType"}){
		# if we have parsed this before, just write it.  Don't mess with everything else.
		return ($bondParseSeen{$bondFunc}{"fType"},@{$bondParseSeen{$bondFunc}{"paramArr"}});
	}

 	($bondFunc =~ /^([^(]+)\((.*)\)$/);
	$funcName = $1;
	$params = $2;
	($fType,$directive) = returnFunction($funcName); ## Obtain Gromacs function type
	$params =~ s/\s+//g; 
	@paramArr = split(",",$params); ## Parse all parameters
	$bondParseSeen{$bondFunc}{"fType"}=$fType;
	$bondParseSeen{$bondFunc}{"paramArr"}=\@paramArr;
	return ($fType,@paramArr);
}

# Combined bond calculation,sorting, and printing
sub printOrderedAngles
{
	my($AngleData,$bondPDL,$indexhandle,$allatoms) = @_;
	my @angleCache; ## CACHE BONDS TO ORDER

	## Cache Bonds ##
	CalculateAngles($AngleData,$bondPDL,\@angleCache,$indexhandle,$allatoms);

	## Sort angles by i,j then k ## 
	@angleCache = sort {($a->{"i"} <=> $b->{"i"}) || ($a->{"j"} <=> $b->{"j"}) || ($a->{"k"} <=> $b->{"k"})} @angleCache;

	## Print our sorted bonds ##
  	foreach my $p(@angleCache){
  		addToTop("angles",$p->{"v"});
	}
}

# CalculateAnglesHelper() calculates the angles for each chain
sub CalculateAngles
{
	my($angleFunctHandle,$whichPDL,$angleCache,$indexhandle,$allatoms) = @_;
 
	foreach my $chain(keys %{$angleFunctHandle}){
		CalculateAnglesHelper($angleFunctHandle->{$chain},$whichPDL->{$chain},$angleCache,$indexhandle,$allatoms);
	}
}

sub CalculateAnglesHelper
{
	my($angleArr,$inputPDL,$angleCache,$indexhandle,$allatoms) = @_;
	my $size = $angleArr->dim(1);
	for(my $i=0;$i<$size;$i++)
	{
		my ($atom1,$atom2,$atom3,$func) = $angleArr->slice(":,$i:$i")->list;
		my $A1=slice($inputPDL,"0:2,$atom1,:");
		my $A2=slice($inputPDL,"0:2,$atom2,:");
		my $A3=slice($inputPDL,"0:2,$atom3,:");		
		my $atomi1 = sclr(slice($inputPDL,"3:3,$atom1,:"));
		my $atomi2 = sclr(slice($inputPDL,"3:3,$atom2,:"));
		my $atomi3 = sclr(slice($inputPDL,"3:3,$atom3,:"));
		my $left = norm($A1-$A2);
		my $right = norm($A3-$A2);
		my $outer = norm($A3-$A1);
				
		my $acos = mathFunctions::rad_to_deg(mathFunctions::acos(sclr(inner($left,$right))));
		
		if($atomi1 > $atomi3) { my $temp = $atomi1; $atomi1 = $atomi3; $atomi3 = $temp; }
		my $val=angleOutput(intToFunc("angles",$func,""),$atomi1,$atomi2,$atomi3,$acos,$indexhandle,$allatoms);
		if(!$val) {next;}
			# i,j,k are meta data
	 	push @{$angleCache}, {'i' => $atomi1,'j' => $atomi2,'k' =>$atomi3, 'v' => $val};
	}
}

# Convert internal angle function format to gromacs function format
sub angleOutput
{
 	my($inputFunc,$i,$j,$k,$values,$indexhandle,$allatoms) = @_;
 ## Remove white spaces from string ##
 	$inputFunc =~ s/^\s+|\s+$//g;
 ## If $input contains a + ##
	my @funcs = split(/\+/,$inputFunc);
	my $outputString="";
	my $value="";my $kd="";
	my $fType="";my @paramArr;
	my $formattedString="";
	foreach my $fun(@funcs)
	{
		my $paramFormat="";
		($fType,@paramArr) = angleFuncParser($fun);

		if($fType ==-1){
			 ## don't write angle and constant. Make gromacs use angletype
			&checkangletype($i,$j,$k,$allatoms); 
			$formattedString = sprintf("%d\t%d\t%d",$i,$j,$k);
			$outputString = "$outputString$formattedString\n";

	 		if($values < $interactionThreshold->{"angles"}->{"smallAngles"} || $values > $interactionThreshold->{"angles"}->{"largeAngles"}){ 
				my $THETA=int($values*100)/100.0;
				my %reflist=%{$indexhandle};
				my $i1=$reflist{$i};
				my $j1=$reflist{$j};
				my $k1=$reflist{$k};
				smog_note("Angle formed by atoms $i $j $k (PDB lines $i1 $j1 $k1) outside of the range set by smallAngles and largeAngles (see .sif): theta=$THETA degrees\n\tWhile the interaction parameters will be defined by angletypes, this warning means there may be something strange about your input configuration.");
			}
	 		
		}else{

			if($fType != 0){
				$paramArr[0]=evalsub($paramArr[0],$values);
				## non-native option used
		
				## Check angles threshold ##
		 		if($paramArr[0] < $interactionThreshold->{"angles"}->{"smallAngles"}){ 
					my $THETA=int($paramArr[0]*100)/100.0;
					my %reflist=%{$indexhandle};
					my $i1=$reflist{$i};
					my $j1=$reflist{$j};
					my $k1=$reflist{$k};
					smog_quit("Angle assigned to atoms $i $j $k (PDB lines $i1 $j1 $k1) smaller than smallAngles (see .sif): theta=$THETA degrees\n\tBe careful! Depending on the angles adopted during the simulation, this may lead to numerical instabilities.",1);
				}
		 		if($paramArr[0] > $interactionThreshold->{"angles"}->{"largeAngles"}){
					my $THETA=int($paramArr[0]*100)/100.0;
					my %reflist=%{$indexhandle};
					my $i1=$reflist{$i};
					my $j1=$reflist{$j};
					my $k1=$reflist{$k};
					smog_quit("Angle assigned to atoms $i $j $k (PDB lines $i1 $j1 $k1) greater than largeAngles (see .sif): theta=$THETA degrees\n\tBe careful!  This can lead to numerical instability of your simulations.",1);
				}
	 		## Format output <i j k function p1 p2 ... pn>
	 			foreach(@paramArr){$paramFormat="$paramFormat %12.9e";}
				$formattedString = sprintf("%d\t%d\t%d\t%d\t$paramFormat",$i,$j,$k,$fType,@paramArr);
				$outputString = "$outputString$formattedString\n";
			}else{
				$freeangles{"$i-$j-$k"}=1;
				$freeangles{"$k-$j-$i"}=1;
			}
		}
	}
	return $outputString; 
}

# Given a user defined angle function parse values
sub angleFuncParser
{
	my($angFunc) = @_;
	my $fType;my @paramArr;my $directive;
	my $funcName = ""; my $params = "";

	if(exists $angleParseSeen{$angFunc}{"fType"}){
		# if we have parsed this before, just write it.  Don't mess with everything else.
		return ($angleParseSeen{$angFunc}{"fType"},@{$angleParseSeen{$angFunc}{"paramArr"}});
	}
 	($angFunc =~ /^([^(]+)\((.*)\)$/);
	$funcName = $1;
	$params = $2;
	$params =~ s/\s+//g; 
	($fType,$directive) = returnFunction($funcName); ## Obtain Gromacs function type
 	@paramArr = split(",",$params); ## Parse all parameters
	$angleParseSeen{$angFunc}{"fType"}=$fType;
	$angleParseSeen{$angFunc}{"paramArr"}=\@paramArr;
	return ($fType,@paramArr);
}

# Combined dihedral calculation,sorting, and printing
sub printOrderedDihedrals
{
	my($DihedralData,$bondPDL,$allatoms) = @_;
	my @diheCache; ## CACHE BONDS TO ORDER
	## Cache Bonds ##
	CalculateDihedrals($DihedralData,$bondPDL,\@diheCache,$allatoms);
	## Sort dihedrals by i, then j then k then l ## 
	@diheCache = sort {($a->{"i"} <=> $b->{"i"}) || ($a->{"j"} <=> $b->{"j"}) || ($a->{"k"} <=> $b->{"k"}) || ($a->{"l"} <=> $b->{"l"}) } @diheCache;
	
	## Print our sorted bonds ##
	foreach my $p(@diheCache){
		addToTop("dihedrals",$p->{"v"});
	}
}

# Setup the calculation of dihedral angles of all combined residues,
sub CalculateDihedrals
{
	my($diheFunctHandle,$whichPDL,$diheCache,$allatoms) = @_;
	foreach my $chain(keys %{$diheFunctHandle}){
		CalculateDihedralsHelper($diheFunctHandle->{$chain},$whichPDL->{$chain},$diheCache,$allatoms);
	}
}

sub CalculateDihedralsHelper
{
	 my($diheArr,$inputPDL,$diheCache,$allatoms) = @_;
	 my $size = $diheArr->dim(1);
	 for(my $i=0;$i<$size;$i++)
	 {
			my @TMP=$diheArr->slice(":,$i:$i")->list;
			if(@TMP < 7){next;}
			my ($atom1,$atom2,$atom3,$atom4,$func,$cD,$eG) = $diheArr->slice(":,$i:$i")->list;
		
		  	my $A1=slice($inputPDL,"0:2,$atom1,:"); 
		  	my $A2=slice($inputPDL,"0:2,$atom2,:"); 
		  	my $A3=slice($inputPDL,"0:2,$atom3,:"); 
		  	my $A4=slice($inputPDL,"0:2,$atom4,:"); 

			my $b1=$A2-$A1;
			my $b2=$A3-$A2;
			my $b3=$A4-$A3;
		
			my $n1 = norm(crossp($b1,$b2));
			my $n2 = norm(crossp($b2,$b3));
			my $m1 = crossp($n1,norm($b2));
		
			my $cos = atan2(inner($m1,$n2),inner($n1,$n2));
                        my $negcos = $cos;#$cos->where($cos < 0);
       
                        $negcos*=-1;$negcos+=mathFunctions::pi();
			my $acos = sclr(mathFunctions::rad_to_deg($cos))+180;
		
			my $atomi1 = sclr(slice($inputPDL,"3:3,$atom1,:"));
			my $atomi2 = sclr(slice($inputPDL,"3:3,$atom2,:"));
			my $atomi3 = sclr(slice($inputPDL,"3:3,$atom3,:"));
			my $atomi4 = sclr(slice($inputPDL,"3:3,$atom4,:"));
			if($atomi1 > $atomi4) { #then reverse order
				my $temp = $atomi1; $atomi1 = $atomi4; $atomi4 = $temp;
				$temp = $atomi2; $atomi2 = $atomi3; $atomi3 = $temp;
			}
			## $eG >=0 dihedral is proper dihedral of any functional form
	        if($eG >= 0)
			{
				my $val = dihedralOutput(intToFunc("dihedrals",$func,$eG),$atomi1,$atomi2,$atomi3,$atomi4,$acos,$cD,$eG,$allatoms);
				if(!$val) {next;}
				# i,j,k,l are meta data
				push @{$diheCache}, {'i' => $atomi1,'j' => $atomi2,'k' =>$atomi3, 'l' => $atomi4, 'v' => $val};
			}
			## Improper dihedral
			else
			{
				push @{$diheCache}, {'i' => $atomi1,'j' => $atomi2,'k' =>$atomi3, 'l' => $atomi4, 'v' => dihedralOutput(intToFunc("impropers",$func,$eG),$atomi1,$atomi2,$atomi3,$atomi4,$acos,$cD,-1)};
	 	   }
	 }
}

sub dihedralOutput
{
 	my($inputFunc,$ai,$aj,$ak,$al,$values,$ratio,$eG,$allatoms) = @_;
 	## Remove white spaces from string ##
 	$inputFunc =~ s/^\s+|\s+$//g;
 	## If $input contains a + ##
 	my @funcs = split(/\+/,$inputFunc);
	my $outputString="";
	my $fType="";       
 	my $formattedString="";
	my @paramArr;
	my $funci=0; my @fTypei;
	foreach my $fun(@funcs)
	{
		my $paramFormat="";
		($fType,@paramArr) = diheFuncParser($fun);
		if($fType ==-1){
			 ## don't write angle. Make gromacs use dihedraltype
			&checkdihedraltype($ai,$aj,$ak,$al,$allatoms);
			$formattedString = sprintf("%d\t%d\t%d\t%d",$ai,$aj,$ak,$al);
			$outputString = "$outputString$formattedString\n";
		}else{

	 		if($fType !=0 && !exists $freeangles{"$ai-$aj-$ak"} && !exists $freeangles{"$ak-$aj-$ai"} && !exists $freeangles{"$aj-$ak-$al"} && !exists $freeangles{"$al-$ak-$aj"}  ){
				# If there is a ?, then substitute the angle value and apply the multiplicity.  If there is no wild card, then simply use the angle provided
				$paramArr[0]=evalsub($paramArr[0],$values);
				if( $fType == 1 || $fType == 4){
			            	# Angle will be scaled by multiplicity factor n, if they are cosine functions
			        	$paramArr[0] *= $paramArr[2];
					$paramArr[0] += 180;
				}

				$funci++;
				## If dihedral kd is normalized or has scaling&normalize ##
			 	$paramArr[1]*=$ratio;
				## Format output <i j k function p1 p2 ... pn>
			 	for(my $I=0;$I<=$#paramArr;$I++){$paramFormat="$paramFormat %12.9e";}
			 	#foreach(@paramArr){$paramFormat="$paramFormat %12.9e";}

				if($fType == 1 || $fType == 4) {
					$paramFormat=" %12.9e %12.9e %u";
				}elsif($fType == 2){    
                               ### CONVERT FIX RIGID/IMPROPER DIHEDRALS ANGLES TO GROMACS CONVENTION ###
                                       if($paramArr[0]>180){$paramArr[0]-=360;}elsif($paramArr[0]<-180){$paramArr[0]+=360;}
				}
				$formattedString = sprintf("%d\t%d\t%d\t%d\t%d\t$paramFormat",$ai,$aj,$ak,$al,$fType,@paramArr);
				$outputString = "$outputString$formattedString\n";
			}
		}
	}
		return $outputString;
}
 
# Given a user defined dihedral function, parse values
sub diheFuncParser
{
	my($diheFunc) = @_;
	if(exists $dihParseSeen{$diheFunc}{"fType"}){
		# if we have parsed this before, just write it.  Don't mess with everything else.
		return ($dihParseSeen{$diheFunc}{"fType"},@{$dihParseSeen{$diheFunc}{"paramArr"}});
	}
 	my $fType;my @paramArr; my $directive;
	my $funcName = "";my $params = "";
 	($diheFunc =~ /^([^(]+)\((.*)\)$/);
	$funcName = $1; $params = $2;
	$params =~ s/\s+//g; 

	($fType,$directive) = returnFunction($funcName); ## Obtain Gromacs function type
	if($directive ne "dihedrals"){smog_quit ("$funcName is not a valid dihedrals function");}
	@paramArr = split(",",$params); ## Parse all parameters;
	$dihParseSeen{$diheFunc}{"fType"}=$fType;
	$dihParseSeen{$diheFunc}{"paramArr"}=\@paramArr;
	return ($fType,@paramArr);
}

sub calculateContacts
{
	my($contactPDL,$inputPDL,$atomTypes,$numCon,$numAtom) = @_;
	my $atoma; my $atomb; my $dist;
	my $pairtypea; my $pairtypeb;
	my $resTypea; my $resTypeb;
	my $multFactor = 1;
	my $c0;  
	my $epsilon;my $cG;my $funct;
 	my $totalStrength; 
	my $contactIntraScale;
	my $count=0;

	my @funct_array;
	my @normalize_array;
	my @atoma_array;
	my @atomb_array;
	my @dist_array;
	my @epsilon_array;

	## Sum all initial contact strengths ##	
	my %conttypeseen;
	for(my $i=0;$i<$numCon;$i++)
	{
		my $normalize;
		my $deltaMin=-1;my $scale=-1;my $deltaMax=-1;
		my $resIdxA=0;my $resIdxB=0;
		$atoma = sclr(slice($contactPDL,"1:1,$i:$i"));
		$atomb = sclr(slice($contactPDL,"2:2,$i:$i"));
		$pairtypea = $atomTypes->{$atoma}->[10];
		$pairtypeb = $atomTypes->{$atomb}->[10];
		$resTypea = $atomTypes->{$atoma}->[1];
		$resTypeb = $atomTypes->{$atomb}->[1];
		my $resnamea = $atomTypes->{$atoma}->[5];
		my $resnameb = $atomTypes->{$atomb}->[5];
		($funct,$cG) = getContactFunctionals($pairtypea,$pairtypeb);
		$conttypeseen{$funct}=1;
		if(!$funct || !$cG){smog_quit("No contact Function defined for nbType contacts $pairtypea-$pairtypeb");}
		$normalize = $termRatios->{"contactGroup"}->{$cG}->{"normalize"};
	
		$funct_array[$i] = $funct;
		$normalize_array[$i] = $normalize;
		$atoma_array[$i] = $atoma;
		$atomb_array[$i] = $atomb;
		$dist_array[$i]	=  sclr(slice($contactPDL,"3:3,$i:$i"));

		## Stacking scaling ##
		$epsilon = 1;
		if(exists $contactSettings->{"contactScaling"}->{$resTypea}
		&& exists $contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb})
		{
			$deltaMin=$contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"deltaMin"};
			$deltaMax=$contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"deltaMax"};
			
			$scale = $contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"scale"};
			$scale = eval($scale);
			$resIdxA = $allAtoms{$atoma}->[2];
			$resIdxB = $allAtoms{$atomb}->[2];
			
			my $atomA = $allAtoms{$atoma}->[3];
			my $atomB = $allAtoms{$atomb}->[3];
			##Atom to boolean##
			$atomA = exists($contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"atomList"}->{$atomA});
			$atomB = exists($contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"atomList"}->{$atomB});
			
			
			if(abs($resIdxB-$resIdxA)>=$deltaMin 
			&& abs($resIdxB-$resIdxA)<=$deltaMax
			&& $atomA && $atomB && $allAtoms{$atoma}[4]==$allAtoms{$atomb}[4]){
				$epsilon*=$scale;
			}
		}

		$epsilon_array[$i] =$epsilon;

		if(!$normalize){next;}
		
		$contactIntraScale = $termRatios->{"contactGroup"}->{$cG}->{"intraRelativeStrength"};
		$epsilon_array[$i] *= $contactIntraScale;

		unless($residues{$resnamea}->{'atomCount'}==0 || $residues{$resnameb}->{'atomCount'}==0){
			$count+=$epsilon_array[$i];
		}
	}

	# determine any global energy redistribution

	if(defined $termRatios->{"interRelativeTotal"} && defined $termRatios->{"energyRelative"}){
       		my $totalStrength = $termRatios->{"interRelativeTotal"};
       		my $diheTotal = $termRatios->{"energyRelative"};
       		my $contactLeftOver = $numAtom - $numAtom*($diheTotal/$totalStrength);
		if($count != 0 ){
       			$contactLeftOver = $contactLeftOver/$count;
			$multFactor = $contactLeftOver;
		}
	}

	# print everything

	for(my $i=0;$i<$numCon;$i++){
		my $outputString;
		my $directive;my $addExclusions;
		my $normalize=$normalize_array[$i];	
		## Non-normalize option for contacts ##
		if($normalize) {
			## DIHE TO CONTACT SCALING ##
			$epsilon_array[$i] *= $multFactor;
		}
		($directive,$addExclusions,$outputString) = contactOutput($funct_array[$i],$atoma_array[$i],$atomb_array[$i],$dist_array[$i],$epsilon_array[$i],$normalize_array[$i]);
		addToTop($directive,$outputString);
		if($addExclusions) { addToTop("exclusions",$atoma_array[$i]."	".$atomb_array[$i]."\n"); }
	}

	if(scalar keys %conttypeseen >1){
		my $L;
		foreach my $CT(keys %conttypeseen){
			$L .= $CT;
			$L .= " ";
		}
		smog_note("More than one type of contact being used at the same time. Not all combinations of contacts are supported by Gromacs. List of used contact types: $L");
 	}
}

# Convert internal contact function format to gromacs function format,
# internal format is f()+g()
sub contactOutput
{
	my($inputFunc,$i,$j,$c0,$epsilon,$normalize) = @_;
	if(!$inputFunc){smog_quit ("CONTACTOUTPUT::NO FUNCTION DEFINED");}
	$inputFunc =~ s/^\s+|\s+$//g;
	## If $input contains a + ##
	my @funcs = split(/\+/,$inputFunc); ## split combination of functions
	my $outputString="";
	my @paramArr;
	my $fname;
	my $directive;
	my $addExclusions;
	my $fType=""; my $formattedString;
	my $addNewline = "";
	## Parse each part of the function ##
	foreach my $fun(@funcs){
		my $paramFormat="";
		($fType,$fname,$directive,$addExclusions,@paramArr) = contactFuncParser($fun);
		## LJ CONTACTS N-M polynomial, sigma and epsilon usage ##	
		if($fType != 0) {
			$addNewline = "\n";
			if($fname eq "contact_1"){
				contactParseNM1(\@paramArr,$c0,$epsilon,$normalize);
				if($fType != 1){smog_quit ("Only fType=1 is supported with contacts contact_1")}
			}
			## LJ CONTACTS N-M polynomial, CN, CM usage ##	
			elsif($fname eq "contact_2"){
				contactParseNM2(\@paramArr,$c0,$epsilon,$normalize);
				if($fType != 1){smog_quit ("Only fType=1 is supported with contacts contact_2")}
			}
			    ## Gaussian ##
			elsif($fname eq "contact_gaussian"){
				contactParseGaussian(\@paramArr,$c0,$epsilon,$normalize);
				if($fType != 6){smog_quit ("Only fType=6 is supported with contacts contact_gaussian")}
			}
			## harmonic bond type 6 ##
			elsif($fname eq "bond_type6"){
				contactParseBond6(\@paramArr,$c0,$epsilon);
    				if($fType != 6){smog_quit ("Only fType=6 is supported with contacts of bond_type6")}

			}else{smog_quit("Contact function name $fname is not supported");}

 	## Format output <i j function p1 p2 ... pn>
		 	foreach(@paramArr){$paramFormat="$paramFormat %12.9e";}
			$formattedString = sprintf("%d\t%d\t%d\t$paramFormat",$i,$j,$fType,@paramArr);
			$outputString = "$outputString$formattedString";
		}
	}
	return ($directive,$addExclusions,$outputString.$addNewline);
}

# Parse LJ NM sigma eps usage
sub contactParseNM1
{
	my($paramArr,$r0,$epsilon,$normalize) = @_;
	##pararArr holds N, M, and whether native distances and weights should be used.
	##epsilon
	##r0 is native distance##
	#
	my $A; my $B;
	my $N; my $M;
	$M=$paramArr->[0];
	$N=$paramArr->[1];
	my $length=scalar @{$paramArr};


	if($interactions->{"gmx-combination-rule"}==1){
	
		$B=-1.0/($M/$N-1.0);
		$A=$M/$N*$B;
		# replace ? with native distance expression
        	$r0=evalsub($paramArr->[2],$r0);
		   
		$A *= $epsilon*$r0**$N;
		$B *= $epsilon*$r0**$M;
		
		## normalized option used
		if($paramArr->[3] =~ /^\?$/)
		{
			if(!$normalize){smog_quit("contact type can not have normalization turned off with epsilon=?")}
			$paramArr->[3]=$A;
			$paramArr->[2]=$B;
		}
		## additional rescaling used
		elsif($paramArr->[3] =~ /\?/)
		{
			smog_quit("Epsilon value used in contact_1 interaction can not be an expression that includes ?.\n");
		}
		else{
			if($normalize){smog_quit("Can\'t normalize a contact since the weight is not defined by a ? mark.")}
			$A *= $paramArr->[3];
			$B *= $paramArr->[3];
			$paramArr->[3]=$A;
			$paramArr->[2]=$B;
		} 
	}elsif($interactions->{"gmx-combination-rule"}==2){

		# replace ? with native distance expression
        	$paramArr->[2]=evalsub($paramArr->[2],$r0);
		$paramArr->[2] /= (2.0)**(1.0/6.0);   
		## normalized option used
		if($paramArr->[3] =~ /^\?$/)
		{
			if(!$normalize){smog_quit("contact type can not have normalization turned off with epsilon=?")}
			$paramArr->[3]=$epsilon;
		}
		## additional rescaling used
		elsif($paramArr->[3] =~ /\?/){
			smog_quit("Epsilon value used in contact_1 interaction can not be an expression that includes ?.\n");
		}else{
			if($normalize){smog_quit("Can\'t normalize a contact since the weight is not defined by a ? mark.")}
		} 
	}else{
		smog_quit("Only gmx-combination-rule equal to 1 or 2 is supported with contact_1");
	}

	## Shift first value off ##
	shift @{$paramArr};
	shift @{$paramArr};
}

# Parse LJ: F_N(sigma), G_M(sigma), sigma, epsilon format
sub contactParseNM2
{
	my($paramArr,$r0,$epsilon,$normalize) = @_;
	##pararArr holds f(r), g(r), and whether native distances and weights should be used.
	##epsilon  
	##r0 is native distance##
	#
	my $A; my $B;
	my $length=scalar @{$paramArr};

	# replace ? with native distance expression
	$paramArr->[2]=evalsub($paramArr->[2],$r0);
	
	# substitute value of r into f(r) and g(r)
	$A=evalsub($paramArr->[1],$paramArr->[2]);	
	$B=evalsub($paramArr->[0],$paramArr->[2]);	

	$A *= $epsilon; 
	$B *= $epsilon; 
	
	## standard normalization used
	if($paramArr->[3] =~ /^\?$/)
	{
		if(!$normalize){smog_quit("contact type can not have normalization turned off with epsilon=?")}
		$paramArr->[3]=$A;
		$paramArr->[2]=$B;
	}else{
	## additional rescaling used
		if($normalize){smog_quit("Can\'t normalize a contact since the weight is not defined by a ? mark.")}
		$A *= $paramArr->[3];
		$B *= $paramArr->[3];
		$paramArr->[3]=$A;
		$paramArr->[2]=$B;
	} 
	## Shift first value off ##
	shift @{$paramArr};
	shift @{$paramArr};
}

# Parse Gaussian Params
sub contactParseGaussian
{

	my($paramArr,$r0,$epsilon,$normalize) = @_;
	my $A=0;my $sigma_G=0;my $a=0;
	##i=0 is epsilon_c##
	##i=1 is epsilon_nc#
	##i=2 is sigma_gaussian##
	##i=3 is r ##
	
	
	## Epsilon_c ##
	if($paramArr->[0] =~ /^\?$/){
		$paramArr->[0]=$epsilon;
	}else{
		$paramArr->[0]=$epsilon*($paramArr->[0]);
	}
	
	## Check if sigma_G has r0 dependency ##
	if($paramArr->[2] =~ /\?/)
	{
		#Replace ? with $r0
		$paramArr->[2] = evalsub($paramArr->[2],$r0); 
		#Eval expression
	}
	if($paramArr->[3] =~ /^?$/){$paramArr->[3]=$r0;}
	
	($A,$r0,$sigma_G,$a) = ($paramArr->[0],$paramArr->[3],$paramArr->[2],$paramArr->[1]);
	@{$paramArr}=($A,$r0,$sigma_G,$a);

}

# Parse Bond type 6
sub contactParseBond6
{
my($paramArr,$r0,$epsilon) = @_;
my $k;
	##i=0 is r##
	##i=1 is k#
	
	## k ##
	$paramArr->[1] = eval($paramArr->[1]);
	
	## r ##
	$paramArr->[0] = evalsub($paramArr->[0],$r0);

	($r0,$k) = ($paramArr->[0],$paramArr->[1]);
	@{$paramArr}=($r0,$k);

}

# Given a user defined contact function parse values
sub contactFuncParser
{
	my($contactFunc) = @_;
	my $fType;my @paramArr;my $directive;my $addExclusions;
	my $funcName = ""; my $params = "";

	if(exists $contactParseSeen{$contactFunc}{"fType"}){
		# if we have parsed this before, just write it.  Don't mess with everything else.
		return ($contactParseSeen{$contactFunc}{"fType"},
			$contactParseSeen{$contactFunc}{"funcName"},
			$contactParseSeen{$contactFunc}{"directive"},
			$contactParseSeen{$contactFunc}{"addExclusions"},
			@{$contactParseSeen{$contactFunc}{"paramArr"}});
	}
 	($contactFunc =~ /^([^(]+)\((.*)\)$/);
 	$funcName = $1;
	$params = $2;
	$params =~ s/\s+//g; 
	($fType,$directive,$addExclusions) = returnFunction($funcName); ## Obtain Gromacs function type
 	@paramArr = split(",",$params); ## Parse all parameters

	$contactParseSeen{$contactFunc}{"fType"}=$fType;
	$contactParseSeen{$contactFunc}{"funcName"}=$funcName;
	$contactParseSeen{$contactFunc}{"directive"}=$directive;
	$contactParseSeen{$contactFunc}{"addExclusions"}=$addExclusions;
	$contactParseSeen{$contactFunc}{"paramArr"}=\@paramArr;

	return ($fType,$funcName,$directive,$addExclusions,@paramArr);
}

sub getAtomTypes
{
	my($uniqueHandle) = @_;
	
	## OBTAIN UNIQUE ATOM TYPES ##
	my $nbtype ="";
	
	foreach my $atoms(sort { $a <=> $b } keys %{$uniqueHandle})
	{
		$nbtype = $uniqueHandle->{$atoms}->[0];
  		if(!$uniqueHandle->{$atoms}->[0])
        	{
          		smog_quit("Atom $atoms has no nbType");
        	}
		$presentatomtypes{$nbtype}=1;
	}
}

sub saveAtomTypes
{
	my $formattedString = "";	
	my $c2;my $c1;my $sigma;my $epsilon;my $ptype;my $charge;my $mass;
	 
	foreach my $nbtype(sort keys %presentatomtypes){
		my $tmptype;
		if(exists $interactions->{"nonbonds"}->{$nbtype}){
			if(exists $extraatomtypes{$nbtype}){
				smog_quit("Non-bonded parameters for atomtype $nbtype are defined in the .nb and extras file");
			}
			$tmptype=$nbtype;
		}elsif(exists $extraatomtypes{$nbtype}){
			# dump the extras information.  Don't match to a wild card, below
			addToTop("atomtypes",$extraatomtypes{$nbtype}."\n");
			next;
		}elsif(exists $interactions->{"nonbonds"}->{"*"}){
			$tmptype="*";
		}else{
			smog_quit("No matching nb parameters found for nbtype $nbtype");
		}
		if($interactions->{"gmx-combination-rule"}==1){ 
			$c1 = $interactions->{"nonbonds"}->{$tmptype}->{"c6"};
			$c2 = $interactions->{"nonbonds"}->{$tmptype}->{"c12"};
		}elsif($interactions->{"gmx-combination-rule"}==2){
			$c1 = $interactions->{"nonbonds"}->{$tmptype}->{"sigma"};
			$c1 /= (2.0)**(1.0/6.0);
			$c2 = $interactions->{"nonbonds"}->{$tmptype}->{"epsilon"};
		}
			$ptype = $interactions->{"nonbonds"}->{$tmptype}->{"ptype"};
			$mass = $interactions->{"nonbonds"}->{$tmptype}->{"mass"};
			$charge = $interactions->{"nonbonds"}->{$tmptype}->{"charge"};
			
			$formattedString = sprintf(" %-4s %8.4f %10.6f  %1s     %-13.5e %-13.5e",$nbtype,$mass,$charge,$ptype,$c1,$c2);
		addToTop("atomtypes",$formattedString."\n");
	}
}

sub readAtoms
{
	my($inputPDB) = @_;
	my %reflist;
	open(PDB,$inputPDB);
	my $line = "";
	my $atomName;my $atomNum; my $resName; my $resNum;
	my $charge = 0; my $mass = 1; my $atomType="none";
	my $counter=0; my $resCounter=1;my $resNumCurr="null";
	my $endreached=0;
	my $totalcharge=0;
	my $systemcharge=0;
	my $chainindex=1;
	my $linenumber=0;
	my $atomindex=0;
	my $lastTER=0;
	while($line = <PDB>)
	{
		$linenumber++;
		if($line =~ m/^TER|^END/) {

			my $TCr=round($totalcharge);
			if(abs($totalcharge-$TCr) > 0.001){
				smog_quit("Non-integer charge ($totalcharge) for chain $chainindex. This typically means something is wrong with the .bif file.");
			}
			print "Charge of chain $chainindex: $TCr\n";
			$systemcharge+=$totalcharge;
			$totalcharge=0;
			$chainindex++;
			$resCounter++;
			$lastTER=1;
		}
		if($line =~ m/^END/) {$endreached=1;last;}
		if($line =~ m/^ATOM/ || $line =~ m/^HETATM/)
		{
			$atomindex++;
			$reflist{$atomindex}=$linenumber;
			$atomName = substr($line, 12, 4);
			$atomName =~ s/^\s+|\s+$//g;
			#$atomNum = substr($line,6,5);
			
			$resName = substr($line,17,4);
			$resName =~ s/^\s+|\s+$//g;
			$resNum = substr($line,22,4);
			$resNum =~ s/^\s+|\s+$//g;
			if($resNumCurr eq "null"){
				$resNumCurr=$resNum;
			}
   			if($resNum ne $resNumCurr)
			{
				$resNumCurr=$resNum;
				if($lastTER ==0){
					$resCounter++;
				}
			}
			if(!$residues{$resName}->{"atoms"}->{$atomName}){next;}
			$counter++;$atomNum=$counter;
			$atomType = $residues{$resName}->{"atoms"}->{$atomName}->{"nbType"};
			addToTop("atoms",sprintf("%6d %10s %6d %6s %6s %6d", $atomNum, $atomType, $resCounter, $resName, $atomName, $atomNum));
			if(defined $residues{$resName}->{"atoms"}->{$atomName}->{"charge"}){
				#if charge is defined for an atom in a  specific residue, then write it
				addToTop("atoms",sprintf(" %9.6f", $residues{$resName}->{"atoms"}->{$atomName}->{"charge"}));
				# this residue has a charge on that atom, add that value to the total
				$totalcharge += $residues{$resName}->{"atoms"}->{$atomName}->{"charge"};
			}elsif(defined $interactions->{"nonbonds"}->{$atomType}->{"charge"}){
				# since there is not residue-specific charge assigned, use the atomtype value.
				$totalcharge += $interactions->{"nonbonds"}->{$atomType}->{"charge"};
			}
			addToTop("atoms",sprintf("\n"));
			$lastTER=0;
		}
	}

	if(abs($systemcharge-round($systemcharge)) > 0.001){
		smog_quit("Non-integer system charge ($systemcharge). This typically means something is wrong with the .bif file.");
	}else{
		printf("\nTotal charge of system: %8.3f\n\n",$systemcharge);
	}
	unless($endreached){smog_quit("PDB format error. END must appear at the end of the ATOM lines.")};
	return(%reflist);
}

# Convert PDB to GRO
# Store chain info to ndx file
sub convertPDBToGroNdx
{
	my ($inputPDB,$outputGRO,$outputGRO4SCM,$outputNDX,$userProvidedMap) = @_;
	my $counter = 0 ;	
	my $line = "";
	my $resName="";
	my $resNum="";
	my $atomName="";
	my $atomNum="";
 	my $x="";my $y="";my $z="";
 	my $output = "";
 	my $chain = "";
 	my $chainCounter = 1;
 	my %chainHash;
	my $resNumCurr=1;my $resCounter=1;
	my $boundflag=0;
	my $lastTER=0;
	my ($xmin, $xmax, $ymin,$ymax,$zmin,$zmax);
 	open(PDB,"$inputPDB") or smog_quit("can not open $inputPDB"); ## INPUT PDB
	my $atominfo="";
	my $atominfo4SCM="";
	while($line=<PDB>)
	{
		
	 if($line =~ m/^END/) {last;}
  	 if($line =~ m/^TER/) {
		$chainCounter++;
		$resCounter++;
		$lastTER=1;
		next;
	}
         if($line =~ m/^ATOM|^HETATM/)
         {
		$atomName = substr($line, 12, 4);
		$atomName =~ s/^\s+|\s+$//g;
		$resName = substr($line,17,4);
		$resName =~ s/^\s+|\s+$//g;
        if(!exists $residues{$resName}->{"atoms"}->{$atomName})
		{next;}
		
		$x = substr($line, 30, 8);$x*=0.10;
		$y = substr($line, 38, 8);$y*=0.10;
		$z = substr($line, 46, 8);$z*=0.10;
		
		if($boundflag == 0){
			$xmin=$x;
			$xmax=$x;
			$ymin=$y;
			$ymax=$y;
			$zmin=$z;
			$zmax=$z;
			$boundflag=1;
		}else{
			if($x > $xmax){$xmax=$x;}
			if($x < $xmin){$xmin=$x;}
			if($y > $ymax){$ymax=$y;}
			if($y < $ymin){$ymin=$y;}
			if($z > $zmax){$zmax=$z;}
			if($z < $zmin){$zmin=$z;}
		}
	
  		$chain = $chainCounter;
		$counter++;$atomNum=$counter;
		$resNum = substr($line,22,4);
		$resNum =~ s/^\s+|\s+$//g;
		if($atomNum == 1){$resNumCurr=$resNum;}
		if($resNum ne $resNumCurr)
			{
				$resNumCurr=$resNum;
				if($lastTER==0){
					$resCounter++;
				}
			}

  		## Save atom index to chain ##
  		push(@{$chainHash{$chain}},$atomNum);
		if($atomNum >= 100000){$atomNum = $atomNum%100000;}
	        if($resCounter >= 100000){$resCounter = $resCounter%100000;}
		$atominfo .= sprintf("%5d%-5s%5s%5d%8.3f%8.3f%8.3f\n",$resCounter,$resName,$atomName,$atomNum,$x,$y,$z);
		$atominfo4SCM .= sprintf("%5d%-5s%5s%5d%9.4f%9.4f%9.4f\n",$resCounter,$resName,$atomName,$atomNum,$x,$y,$z);
		$lastTER=0;
		
	 }
	}

## default box size if 1nm larger than system size in each direction
	my $xrange=($xmax-$xmin)+2.0;
	my $yrange=($ymax-$ymin)+2.0;
	my $zrange=($zmax-$zmin)+2.0;

 ## ADJUST GRO FILE ##
	close(PDB);
	open(GRO,">$outputGRO") or smog_quit("can not open $outputGRO for writing");
	print GRO "Gro file for a structure based model, generated with SMOG Version $VERSION\n";
	print GRO $counter,"\n";

	print GRO "$atominfo";
	print GRO "$xrange $yrange $zrange\n";
	close(GRO);

	if($userProvidedMap==0){
	# we are generating a map, so save full PDB-precision gro
		open(GRO,">$outputGRO4SCM") or smog_quit("can not open $outputGRO4SCM for writing");
		print GRO "Temp Gro file with PDB precision for SCM calculations.\n";
		print GRO $counter,"\n";

		print GRO "$atominfo4SCM";
		print GRO "$xrange $yrange $zrange\n";
		close(GRO);
	}

	
 ## CREATE NDX FILE ##
	open(NDX,">$outputNDX");
	
	foreach my $chain (sort {$a <=> $b} keys %chainHash) 
	{
	       print NDX "[ $chain ]\n";
	       print NDX join("\n",@{$chainHash{$chain}});
	       print NDX "\n\n";
	}
	close(NDX);
}

sub evalsub
{
	my ($expression,$value)=@_;
	$expression =~ s/\?/$value/g;
	$expression = eval($expression);
	return $expression;
}

sub validateTemplate
{
	my ($file,$type) = @_;
	my $validator = XML::Validator::Schema->new(file => "$ENV{SMOG_PATH}/share/schemas/$type.xsd");
	my $parser = XML::SAX::ParserFactory->parser(Handler => $validator);
	eval { $parser->parse_uri($file) };
 smog_quit("Failed at validating $file: $@ \nThis is due to an XML formatting issue.  The most common issue is that an element is missing a tagline. For example, something like this may appear in your file,
  <child>
    <subchild>.....
  </child>

whereas the following would be appropriate:
  <child>
    <subchild>.....

    </subchild>
  </child>") if $@;

}

sub parseInputFolder
{
	my ($folderName) = @_;
	$folderName = $1 if($folderName=~/(.*)\/$/);
	opendir(my $folder,$folderName);
	my $bif;my $sif;my $b;my $nb;my $extras;
	my $bifexists=0;
	my $sifexists=0;
	my $nbexists=0;
	my $bexists=0;
	my $extrasexists=0;
	while(my $file = readdir($folder)){
		if($file =~ m/\.bif$/){
			$bifexists++;
			$bif = $file;$bif = "$folderName/$bif";
			print "Found .bif file $bif\n";
			print "Validating XML format of $bif\n";
			validateTemplate($bif,"bif");
			next;
		}elsif($file =~ m/\.sif$/){
			$sifexists++;
			$sif = $file;$sif = "$folderName/$sif";
			print "Found .sif file $sif\n";
			print "Validating XML format of $sif\n";
			validateTemplate($sif,"sif");
			next;
		}elsif($file =~ m/\.b$/){
			$bexists++;
			$b = $file;$b = "$folderName/$b";
			print "Found .b file $b\n";
			print "Validating XML format of $b\n";
			validateTemplate($b,"b");
			next;
		}elsif($file =~ m/\.nb$/){
			$nbexists++;
			$nb = $file;$nb = "$folderName/$nb";
			print "Found .nb file $nb\n";
			print "Validating XML format of $nb\n";
			validateTemplate($nb,"nb");
			next;
		}elsif($file =~ m/extras$/) {
			$extrasexists++;
			$extrasfile = "$folderName/$file";
			print "Found extras file $extrasfile\n";
			checkExtras($extrasfile);
			next;
		}elsif($file !~ m/^[Rr][Ee][Aa][Dd][Mm][Ee]$/ && $file !~ m/^\./) {
			# note that READMEs are ignored
			smog_note("Found unused file \"$file\" in the template directory");	
		}
	}
	$bifForSCM = $bif;

	if($bifexists >1){
		smog_quit ("Found multiple .bif files in directory $folderName");
	}elsif($bifexists ==0){
		smog_quit (" .bif file not found in directory $folderName");
	}
	if($sifexists >1){
		smog_quit ("Found multiple .sif files in directory $folderName");
	}elsif($sifexists ==0){
		smog_quit (" .sif file not found in directory $folderName");
	}
	if($bexists >1){
		smog_quit ("Found multiple .b files in directory $folderName");
	}elsif($bexists ==0){
		smog_quit (" .b file not found in directory $folderName");
	}
	if($nbexists >1){
		smog_quit ("Found multiple .nb files in directory $folderName");
	}elsif($nbexists ==0){
		smog_quit (" .nb file not found in directory $folderName");
	}
	if($extrasexists >1){
		smog_quit ("Found multiple extras (or .extras) files in directory $folderName");
	}
	
	setInputFileName($bif,$sif,$b,$nb);
	
}

sub header
{
	my $header="******* ******* ******* ******* ******* SMOG v$VERSION ******* ******* ******* ******* *******";
	my $headw=length($header);
	printdashed($headw);
	print "\n$header\n";

	my $tmpstring = <<"EOT";

Thank you for using the Structure-based Model (SMOG) software

This package is the product of contributions from a number of people, including:
Jeffrey Noel, Mariana Levi, Mohit Raghunathan, Joyce Yang           
Prasad Bandarkar, Udayan Mohanty, Ailun Wang        
Ryan Hayes, Jose Onuchic & Paul Whitford         

Copyright (c) 2015, The SMOG development team at
Rice University and Northeastern University

SMOG v$VERSION & Shadow are available at http://smog-server.org

You can direct questions to info\@smog-server.org, or the smog-users forum, 
which can be found at https://mailman.rice.edu/mailman/listinfo/smog-users

EOT

	printcenter($headw,$tmpstring);
	printdashed($headw);
	print "\nSMOG 2 called with the command:\n";
	print "smog2 ";
	foreach my $filen(@ARGV){
		print "$filen ";
	}	
	print "\n";
}

sub usage
{
	print <<EOT;

usage: smog2 .. options ..

   Options
     I/O flags  
       -i [molecule.pdb]       : input PDB to generate Hamiltonian
       -g [smog.gro]           : output .gro file name
       -o [smog.top]           : output .top file name
       -s [smog.contacts]      : output .contacts file name
       -n [smog.ndx]           : output .ndx file name
       -c <file name>          : input contact map file
       -SCMorig                : directly save SCM contact map (i.e. not PBD numbering).  useful for debugging
       -dname [smog]           : default name to use for all output files
       -backup [yes]           : back up any pre-existing output files

     Force Field Designation
       -AA                     : use default All-atom model
       -AAgaussian             : use default All-atom model with gaussian contacts
       -CA                     : use default Calpha protein model
       -CAgaussian             : use default Calpha protein model with gaussian contacts
       -t [templateFolder]     : folder containing templates of molecular and interaction definitions. required when defaults are not used
       -tCG [templateFolder]   : folder containing templates Coarse Graining. indicates that the program should coarse grain
       -nocheck                : turn off template cross-validation checks.  This can be useful
                                       when using old templates with new versions of SMOG

     Force Field Modifications/exceptions
       -limitbondlength        : if a bond length is outside of the allowable range, set it to limiting value
       -limitcontactlength     : if a contact length is too short, set it to the minimal value
       -deleteshortcontact     : if a contact length is too short, don't include it in the model

     Misc. Options
       -ignH                   : ignore any atoms with name starting with 'H' in the internal contact algorithm
       -gen_map <out map file> : read the .bif file, generate a mapping file for smog_adjustPDB and exit 

       -warn [0]               : convert the first N fatal errors to warnings  
                                       Convert all if N=-1 (Caution: Consult manual before using this option)
       -help                   : show options 
EOT
	if ( @_ ){
		smog_quit("Flag \"@_\" not recognized, or is missing arguments.");
	}else{
		exit(0);
	}
}

sub setContactParams
{
	my $method = $contactSettings->{"method"};
	my $params = "";
	my $proteinDelta = 3;
	if(exists $contactSettings->{"proteinDelta"}) { $proteinDelta = $contactSettings->{"proteinDelta"}}
	if($method =~ m/shadow/)
	{
		my $radius = $contactSettings->{"shadowRadius"};
		my $radiusBonded = $contactSettings->{"shadowRadiusBonded"};
		my $dist = $contactSettings->{"contactDistance"};
		$params="-m shadow -c $dist -s $radius -br $radiusBonded -bif $bifForSCM -pd $proteinDelta --smog2output --showProgress";
	}
	elsif($method =~ m/cutoff/) 
	{
		my $dist = $contactSettings->{"contactDistance"};
		my $radius = 0.0;
		my $radiusBonded = 0.0;
		$params="-m shadow -c $dist -s $radius -br $radiusBonded -bif $bifForSCM -pd $proteinDelta --smog2output --showProgress";
	}
	else {smog_quit ("Contact map method $method is not supported.");}
	if($ignoreHydrogen == 1) { $params = $params." --ignoreH "; }
	return $params;
}


sub printCitation
{
	my $citationFile = "";
	## CHECK FOR .citation meta file ##
	if($coarseFolder && -e "$coarseFolder/.citation")
	{
		open(CITE,"$coarseFolder/.citation");
		$citationFile = join("",<CITE>);
		close(CITE);
	}
	elsif(-e "$inputFolder/.citation")
	{
		open(CITE,"$inputFolder/.citation");
		$citationFile = join("",<CITE>);
		close(CITE);
	}
	else
	{
		$citationFile = "";
	}
       

print <<EOT;

########################################################################################

              We kindly ask that you cite the appropriate primary references
             when using SMOG models. See http://www.smog-server.org/refs.html

--Software-- 
Noel JK, Levi M, Raghunathan M, Lammert H, Hayes R, Onuchic JN, and Whitford PC. (2016)
SMOG V2, A Versatile Software Package for Generating Structure-Based Models.
PLoS Comput Biol 12(3): e1004794. doi:10.1371/journal.pcbi.1004794

$citationFile
########################################################################################

EOT

}

sub freeMemoryForShadow
{
	undef %resPDL;undef %bondPDL;
	undef %AngleData;undef %DihedralData;
	undef %BondData;undef $contactPDL;undef %foundBtype; undef %foundAtype, undef %foundDtype;
}

sub parseTemplatesAndPDB
{
	my ($inputFolder,$inputPDB,$allowCG) = @_;
    
    	## TEST IF SMOG PATH EXISTS ##
    	if(!$ENV{"SMOG_PATH"}){smog_quit("SMOG_PATH environment variable not set");}
	$| = 1;
	parseInputFolder($inputFolder); 

	
	#####################
    	## PARSE TEMPLATES ##
    	#####################
	## parse .sif File ##
	parseSif();
	## parse .nb file  ##
	parseNonBonds();
	## parse .b file   ##
	parseBonds();
	## parse .bif File ##
	parseBif();
	print "\nDone parsing templates.\n";

	unless($nocheck eq "yes"){ 
	    	print "\nChecking template definitions for consistency.\n";
		my $checkmessage=checkenergygroups();
		$checkmessage.=checkNONBONDnames();
		$checkmessage.=checkBONDnames();
		$checkmessage.=checkPAIRnames();
		$checkmessage.=checkREScharges();
		$checkmessage.=checkRESimpropers();
		$checkmessage.=compareFuncs();
		if($checkmessage ne ""){
			smog_quit("Cross-comparison of templates failed. See messages below:\n\n$checkmessage");
		}
	}

	# simply generate a map for adjustPDB and exit
	if(defined $gen_map){
		parseBif($inputFolder,$gen_map);
		exit(0);
	}else{
		# no need to initialize these things if we are only making a map file
		initializeDirectives($inputFolder,$inputPDB);
	}

	print "\nPre-processing templates\n";
	## Find Bonds ##
	createBondFunctionals();
	## Find Angles ##
	createDihedralAngleFunctionals();
	###############
    	## PARSE PDB ##
    	###############
	print "\nReading $inputPDB\n\n";
	checkPDB($inputPDB,$allowCG);
	parsePDBATOMS($inputPDB,$allowCG);
	catPDL();
}

sub printBondedTopOutput {

	my ($inputPDB,$groFile,$groFile4SCM,$ndxFile,$userProvidedMap) = @_;
        if($countDihedrals){
		print "Counting dihedrals\n";
		getSetDiheCounts(\%DihedralData,\%bondPDL);
        }else{
        	print "Will not count/rescale dihedrals with common middle bonds.\n";
        }
	## SET DIHEDRAL RATIOS ##
	if($normalizevals){
		# only set ratios if normalization is on.  It is faster to not use it.
		print "Setting energetic ratios\n";
		setRatios(\%DihedralData,\%bondPDL,$totalAtoms,\%allAtoms);
	}
	print "Processing atoms\n";
	getAtomTypes(\%allAtoms);
 	# adding extras at this point is a bit out of place.  but, it is important, in order to verify that all bonds have bondtypes, etc.
	addExtras($extrasfile);
	saveAtomTypes();
	my %atomIndex2Line=readAtoms($inputPDB);

	## CALCULATE BONDS/CONNECTED BONDS ##
	print "Checking and saving bonds\n";
	printOrderedBonds(\%bondFunctionals,\%resPDL,\%BondData,\%bondPDL,\%atomIndex2Line,\%allAtoms);

	## CALCULATE ANGLES ##
	print "Checking and saving angles\n";
	printOrderedAngles(\%AngleData,\%bondPDL,\%atomIndex2Line,\%allAtoms);

	## CALCULATE DIHEDRALS ##
	print "Checking and saving dihedrals\n";
	printOrderedDihedrals(\%DihedralData,\%bondPDL,\%allAtoms);

	## CREATE GRO FILE ##
	convertPDBToGroNdx($inputPDB,$groFile,$groFile4SCM,$ndxFile,$userProvidedMap);
	## print intermediate top for SCM.jar to read ##
}

sub generateContactMap {
	my ($groFile4SCM,$ndxFile,$shadowFile,$topFile) = @_;
	## CALL SHADOW/PARSE CONTACTS ##
	print "Starting contact calculations ...\n  ";
	my $SCMparams = setContactParams();
    	my $memoryMax = "";
	my $absAtomCount = keys(%allAtoms);
	#AKE lattice with 6e5 atoms needs 70 MB. Use 80MB for safety...
	my $megabytesNeeded = int($absAtomCount / 60000 * 80);
	if( $megabytesNeeded > 100 ) #default java heapsize is 1/4 physical memory. Don't think anyone will have <400MB these days 
    	{
		print "JAVA HEAP SIZE INCREASED to $megabytesNeeded Mb\n";
		$memoryMax = "-Xmx$megabytesNeeded"."m";
    	} 
	
	## Delete Preexisting contact file ##
	if(-e $shadowFile){unlink($shadowFile);}
	
	## Free Memory for Shadow ##
	freeMemoryForShadow();
	
	if((!exists $ENV{SMOG_PATH}) || !(-e "$ENV{SMOG_PATH}/src/tools/SCM.jar")){smog_quit ("Can't find Shadow executable. Make sure SMOG_PATH is set correctly.")}
	print "Calling $ENV{SMOG_PATH}/src/tools/SCM.jar \n";
	system("java $memoryMax -jar $ENV{SMOG_PATH}/src/tools/SCM.jar -g $groFile4SCM -ndec 4 -t $topFile -o $shadowFile -ch $ndxFile $SCMparams ");
}

sub appendDefaults
{
	my $combrule = $interactions->{"gmx-combination-rule"};
	my $nbfunc = $interactions->{"nbfunc"};
	my $genpairs = $interactions->{"gen-pairs"};
	my $fudgeLJ = $interactions->{"fudgeLJ"};
	my $fudgeQQ = $interactions->{"fudgeQQ"};

	if($fudgeLJ == -1 && $fudgeQQ == -1){
		addToTop("defaults", "; nbfunc comb-rule gen-pairs\n");
		addToTop("defaults", "  $nbfunc      $combrule         $genpairs\n");
	}
	if($fudgeLJ != -1 && $fudgeQQ == -1){
		addToTop("defaults", "; nbfunc comb-rule gen-pairs fudgeLJ\n");
		addToTop("defaults", "  $nbfunc      $combrule         $genpairs        $fudgeLJ\n");
	}
	if($fudgeQQ != -1){
		addToTop("defaults", "; nbfunc comb-rule gen-pairs fudgeLJ fudgeQQ\n");
		addToTop("defaults", "  $nbfunc      $combrule         $genpairs        $fudgeLJ       $fudgeQQ\n");
	}
}

sub appendContacts {
	my($fileName,$fileName2,$userProvidedMap,$saveSCMorig) = @_;
	#Parse the contact map, either the generated one or the user provided one
	$numContacts = parseCONTACT($shadowFile,$ContactFile,$userProvidedMap,$CGenabled,$saveSCMorig);
	if($numContacts == 0){smog_quit ("There are 0 contacts.  See earlier messages for possible errors");}
	my $absAtomCount = keys(%allAtoms);
	print "If normalization is used, the total number of atoms included in normalization will be $totalAtoms, while $absAtomCount atoms are in the system.\n";
	print "Completing final details...\n";
	## CALCULATE PAIRS and EXCLUSIONS ##
 	calculateContacts($contactPDL,\%resPDL,\%allAtoms,$numContacts,$totalAtoms);
}



