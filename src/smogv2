#########################################################################################
# smog2 contains the main routines
#
#                          Structure-based Model (SMOG) software
#    This package is the product of contributions from a number of people, including:
#                 Jeffrey Noel, Mariana Levi, Mohit Raghunathan, Joyce Yang           
#                       Prasad Bandarkar, Udayan Mohanty, Ailun Wang
#                 Heiko Lammert, Ryan Hayes, Jose Onuchic & Paul Whitford
#
#                     Copyright (c) 2015, The SMOG development team at
#                        Rice University and Northeastern University
#
#              SMOG 2 & Shadow are available at http://smog-server.org
#
#          You can direct questions to info@smog-server.org, or the smog-users forum, 
#          which you can find at https://mailman.rice.edu/mailman/listinfo/smog-users
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#########################################################################################

#####################
## COMPILE HEADERS ##
#####################
use strict;
use warnings;
####################
## MODULE HEADERS ##
####################
&checkForModules;
use XML::Simple;
use templateParser;
use PDB_Bonded;
use PDL;
use mathFunctions;
use setRatios;
use Getopt::Long;
Getopt::Long::Configure("pass_through");
use Data::Dumper;
use XML::SAX::ParserFactory;
use XML::Validator::Schema; 
use IPC::Open3;
use smog_common;
######################
## GLOBAL VARIABLES ##
######################
my $VERSION="2.2beta";
my $angToNano = 0.1;
my $OUTPUT;
my $help;
my $inputPDB="molecule.pdb"; 
my $inputFolder=""; my $bifForSCM;
my $userProvidedMap=0;
my $topFile = "";
my $groFile = "";
my $ContactFile;
my $shadowFile = "";
my $ndxFile = "";
my $mapOpt = "shadow";
my $numContacts = 0;
my $rescaleCD = 1.0; ## rescale all contacts and dihedrals ##
my $coarseFolder = ""; ## Coarse Grain Folder ##
my $AAdefault = 0; 
my $CAdefault = 0;
my $AAGdefault = 0; 
my $CAGdefault = 0;
my $absolutecontactindex=0;
our %freebonds;
our %freeangles;
our $CGenabled=0; ## enable coarse-graining
our $setBondtoLimit=0;
our $setContacttoLimit=0;
our %funtypechecked;
our %presentatomtypes;
our %foundBtype;
our %foundAtype;
our %foundDtype;
my $printversion;
my $ignoreHydrogen=0; #variable that is set when you don't want contact map generation to consider hydrogens
## this is the array that defines how function names are converted to gromacs function types
our %fTypes = (	'bond_harmonic' => '1',
		'bond_bytype' => '-1',
		'bond_type6' => '6',
		'bond_free' => '0',
		'angle_harmonic' => '1',
		'angle_bytype' => '-1',
		'angle_free' => '0',
		'dihedral_cosine'=>'1',
		'dihedral_harmonic' => '2',
		'dihedral_bytype' => '-1',
		'dihedral_free' => '0',
		'contact_free'=>'0',
		'contact_1'=>'1',
		'contact_2'=>'1',
		'contact_gaussian'=>'6'
		);

## this is the topfile buffer stuff
our %directives = ("comments",1,"defaults",2,"atomtypes",3,"bondtypes",4,"angletypes",5,"dihedraltypes",6,"nonbond_params",7,"moleculetype",8,"atoms",9,"bonds",10,"angles",11,"dihedrals",12,"pairs",13,"exclusions",14,"position_restraints",15,"system",16,"molecules",17);
our @directivesList=("comments","defaults","atomtypes","bondtypes","angletypes","dihedraltypes","nonbond_params","moleculetype","atoms","bonds","angles","dihedrals","pairs","exclusions","position_restraints","system","molecules");
our @topFileBuffer;
our @linesInDirectives;
our @linesInDirectivesWithContent;
our $inputArguments=join(' ',@ARGV);
our %Btypespresent;
our %NBtypespresent;
our %PAIRtypespresent;
our %pairtypesused;
quit_init();

checkForModules();

####################
## OUTPUT TOPFILE ##
####################
sub printTop {
	my ($topFile) = @_;
	open($OUTPUT, ">$topFile");
	my $i;
	my $directive;
	foreach $directive (@directivesList) { #order of list defines order in top
		if($linesInDirectivesWithContent[$directives{$directive}] > 1 or $directive eq "comments") { # print if the section has more than a header and comments
			foreach $i (0 .. scalar @{$topFileBuffer[$directives{$directive}]}-1) { 
				print $OUTPUT $topFileBuffer[$directives{$directive}][$i][0];
			}
		}
	}
	close($OUTPUT);
}

# utility method to set all the initial directive comments
sub initializeDirectives {
	my($inputFolder,$inputPDB) = @_;
	for (keys %directives) { 
		$linesInDirectives[$directives{$_}]=0; 
		$linesInDirectivesWithContent[$directives{$_}]=0; 
		#need this because we are going to output a top without pairs but want it to not die when it is not initialized
		push @{$topFileBuffer[$directives{$_}][$linesInDirectives[$directives{$_}]++]}, ""; 
	}
	addToTop("comments", "; Structure-based \"SMOG\" model for use with GROMACS, NAMD, or AMBER\n");
	addToTop("comments", "; Generated by the SMOG tool version $VERSION\n");
	addToTop("comments", "; Called with PDB: $inputPDB\n");
	addToTop("comments", "; Created using templates found in directory: $inputFolder\n");
	addToTop("comments", "; Your input arguments were: $inputArguments\n");	
	addToTop("defaults", "\n[ defaults ]\n");
	addToTop("defaults", "; nbfunc comb-rule gen-pairs\n");
	addToTop("bonds","\n[ bonds ]\n");
	addToTop("bonds",";ai\taj\tfunc\t r0(nm)\t         Kb\n");
	addToTop("angles","\n[ angles ]\n");
	addToTop("angles",";ai\taj\tak\tfunc\t th0(deg)        Ka\n");
  	addToTop("dihedrals","\n[ dihedrals ]\n");
  	addToTop("dihedrals",";ai\taj\tak\tal\tfunc\t phi0(deg)       Kd              mult\n");
	addToTop("pairs","\n[ pairs ]\n");
	addToTop("pairs",";ai\taj\ttype\t A               B\n");
	addToTop("exclusions","\n[ exclusions ]\n");
	addToTop("exclusions",";ai	aj\n");
	addToTop("atomtypes","\n[ atomtypes ] \n");
	addToTop("atomtypes","; name  mass     charge    ptype c6            c12\n");
	addToTop("bondtypes","\n[ bondtypes ] \n");
	addToTop("angletypes","\n[ angletypes ] \n");
	addToTop("dihedraltypes","\n[ dihedraltypes ] \n");
	addToTop("nonbond_params","\n[ nonbond_params ]\n");
	addToTop("nonbond_params",";ai     aj    func    c6       c12\n");
	addToTop("position_restraints","\n[ position_restraints ]\n");
	addToTop("position_restraints",";ai    func    kx    ky   kz\n");
	addToTop("atoms","\n[ atoms ]\n");
	addToTop("atoms",";  nr        type   resnr residue atom   cgnr   charge\n");
	addToTop("moleculetype","\n[ moleculetype ]\n");
	addToTop("moleculetype","; name            nrexcl\n");
	addToTop("moleculetype","  Macromolecule   3\n");
	addToTop("system","\n[ system ]\n");
	addToTop("system","; name\n");
	addToTop("system","  Macromolecule\n");
	addToTop("molecules","\n[ molecules ]\n");
	addToTop("molecules","; name            #molec\n");
	addToTop("molecules","  Macromolecule   1\n");
}

#adds something to the topfile at the bottom of a directive
sub addToTop {
	my($directive,$stuff) = @_;
	$linesInDirectivesWithContent[$directives{$directive}]+= hascontent($stuff);
	push  @{$topFileBuffer[$directives{$directive}][$linesInDirectives[$directives{$directive}]++]}, $stuff;
}

#read file "extras" in template directory
sub addExtras {
	my $filename = "$inputFolder/extras";
	my %foundNBe;
	if( -e $filename){
		print "\nAdding extras information.\n";
		open(EXTRA,"$filename");
		my $line = "";
		my $directive;my $stuff;my @tokens;
		while($line = <EXTRA>)
		{
			chomp($line);
			my ($A,$B)=checkcomment($line);
			if($A eq ""){next;}  # skip the line if it is only a comment
		    	@tokens = split('<',$line);
			$directive = $tokens[0];
			$directive =~ s/^\s+|\s+$//g;
			$stuff = $tokens[1];
			$stuff =~ s/^\s+|\s+$//g;
			# check that nonbonded params are only added if the atom types are present
			if($directive eq "nonbond_params"){
		    		my @ltokens = split('<',$A);
				if(@ltokens ==1){
					# if it is just a comment, save.
					addToTop($directive,$stuff."\n");
					next;	
				}
				my @tarray=split(/\s+/,$ltokens[1]);
				if(@tarray < 5){
					smog_quit("nonbond_params defined in extras file, but too few parameters are given. Offending line:$line");
				}
				unless($tarray[3]  =~ /^[1-3]$/){
					smog_quit("In extras file, only nonbond_param types 1-3 are supported. Offending line:$line");
				}
				if($tarray[3]==1 && @tarray!=6){
					smog_quit("In extras file, nonbond_param defined with nbtype 1. Must have 5 parameters. Offending line:$line");
				}
				if($tarray[3]==3 && @tarray!=21){
					smog_quit("In extras file, nonbond_param defined with nbtype 3. Must have 20 parameters. Offending line:$line");
				}
				my $f;
				if($tarray[0] lt $tarray[1]){
					$f = $tarray[0] . "-" . $tarray[1];
				}else{
					$f = $tarray[1] . "-" . $tarray[0];
				}
				$foundNBe{$f}=1;
				if(!defined $presentatomtypes{$tarray[0]} || !defined $presentatomtypes{$tarray[1]}){
					next;
				}	
				# since they are both defined, we will keep a record of them.
			}
			if($directive eq "bondtypes"){
		    		my @ltokens = split('<',$A);
				if(@ltokens ==1){
					# if it is just a comment, save.
					addToTop($directive,$stuff."\n");
					next;	
				}
				my $lstuff=$ltokens[1];
				$lstuff =~ s/^\s+|\s+$//g;
				my @tarray=split(/\s+/,$lstuff);
				if(@tarray < 5 ){
					smog_quit("bondtypes defined in extras file, but too few parameters are given. Offending line:$line");
				}
				unless($tarray[2]  =~ /^[1-9]$|^10$/){
					smog_quit("In extras file, only bondtypes types 1-10 are supported. Offending line:$line");
				}
				if($tarray[2]==1 && @tarray!=5){
					smog_quit("In extras file, bondtypes defined with nbtype 1. Must have 5 parameters. Offending line:$line");
				}
				if((!defined $presentatomtypes{$tarray[0]} && $tarray[0] ne "X") || (!defined $presentatomtypes{$tarray[1]} && $tarray[1] ne "X")  ){
					next;
				}	
				# since they are both defined, we will keep a record of them.
				# save the type hash
				$foundBtype{"$tarray[0]-$tarray[1]"}=1;
				$foundBtype{"$tarray[1]-$tarray[0]"}=1;
			}
			if($directive eq "angletypes"){
		    		my @ltokens = split('<',$A);
				if(@ltokens ==1){
					# if it is just a comment, save.
					addToTop($directive,$stuff."\n");
					next;	
				}
				my $lstuff=$ltokens[1];
				$lstuff =~ s/^\s+|\s+$//g;
				my @tarray=split(/\s+/,$lstuff);
				if(@tarray < 6 ){
					smog_quit("angletypes defined in extras file, but too few parameters are given. Offending line:$line");
				}
				unless($tarray[3]  =~ /^[1-6]$|^8$|^10$/){
					smog_quit("In extras file, only angletypes types 1-6, 8 and 10 are supported. Offending line:$line");
				}
				if($tarray[3]==1 && @tarray!=6){
					smog_quit("In extras file, angletypes defined with nbtype 1. Must have 6 parameters. Offending line:$line");
				}
				if((!defined $presentatomtypes{$tarray[0]} && $tarray[0] ne "X") || (!defined $presentatomtypes{$tarray[1]} && $tarray[1] ne "X") || (!defined $presentatomtypes{$tarray[2]} && $tarray[2] ne "X") ){
					next;
				}	
				# since they are both defined, we will keep a record of them.

				$foundAtype{"$tarray[0]-$tarray[1]-$tarray[2]"}=1;
				$foundAtype{"$tarray[2]-$tarray[1]-$tarray[0]"}=1;
			}
			if($directive eq "dihedraltypes"){
		    		my @ltokens = split('<',$A);
				if(@ltokens ==1){
					# if it is just a comment, save.
					addToTop($directive,$stuff."\n");
					next;	
				}
				my $lstuff=$ltokens[1];
				$lstuff =~ s/^\s+|\s+$//g;
				my @tarray=split(/\s+/,$lstuff);
				if(@tarray < 7 ){
					smog_quit("dihedraltypes defined in extras file, but too few parameters are given. Offending line:$line");
				}
				unless($tarray[4]  =~ /^[1-5]$|^[89]$|^1[01]$/){
					smog_quit("In extras file, only angletypes types 1-5, 8, 9, 10 and 11 are supported. Offending line:$line");
				}
				if((!defined $presentatomtypes{$tarray[0]} && $tarray[0] ne "X") || (!defined $presentatomtypes{$tarray[1]} && $tarray[1] ne "X") || (!defined $presentatomtypes{$tarray[2]} && $tarray[2] ne "X") || (!defined $presentatomtypes{$tarray[3]} && $tarray[3] ne "X") ){
					next;
				}	
				# since they are both defined, we will keep a record of them.
				$foundDtype{"$tarray[0]-$tarray[1]-$tarray[2]-$tarray[3]"}=1;
				$foundDtype{"$tarray[3]-$tarray[2]-$tarray[1]-$tarray[0]"}=1;
			}



			addToTop($directive,$stuff."\n");
		}
	}
	if(exists $interactions->{"nbfunc"} && $interactions->{"nbfunc"} == 3){
	# type 3 is not defined for official versions of gromacs. We have added routines in a SMOG-supported version, in which effective potentials are defined for nonbonded interactions. These effective potentials are defined as type 3. Since there are no known combination rules for the effective potentials, the nonbonded params need to be given for every possible type of combination.  We will check that this condition is satisfied, here.
		foreach my $t1(keys %presentatomtypes){	
			foreach my $t2(keys %presentatomtypes){	
				my $f;
				if($t1 lt $t2){
					$f = $t1 . "-" . $t2;
				}else{
					$f = $t2 . "-" . $t1;
				}
				if(!exists $foundNBe{$f}){
					smog_quit("nbtype 3 is being used, yet not all possible nonbond_params are given in extras file. Did not find params for atomtype pair $f");
				}
			}
		}
	}
}


sub checkExtras {
	my ($filename) = @_;
	open(EXTRA,"$filename");
	my $line = "";
	my $directive;my $stuff;my @tokens;
	while($line = <EXTRA>)
	{
		chomp($line);
		my ($A,$B)=checkcomment($line);
		if($A eq ""){next;}  # skip the line if it is only a comment
	    	@tokens = split('<',$line);
		if(scalar @tokens > 2) {
			smog_quit("Line in extras file: $filename contains more than one instance of character '<'. Offending line:\n $line");
		}
		$directive = $tokens[0];
		$directive =~ s/^\s+|\s+$//g;
		if(!exists $directives{$directive}) {
			smog_quit("extras file: $filename has a non-valid directive \"$directive\". Check for typos or add directive to directivesList in src/smogv2.");			
		}
	}
}


#####################
## CALCULATE BONDS ##
#####################

##

# Combined bond calculation,sorting, and printing
sub printOrderedBonds
{

	my($bondFunctHandle1,$whichPDL1,$bondHandle2,$whichPDL2,$indexhandle,$allatoms) = @_;
	my @bondCache; ## CACHE BONDS TO ORDER

	## Cache Bonds ##
	calculateBonds1($bondFunctHandle1,$whichPDL1,\@bondCache,$indexhandle,$allatoms);
	calculateBonds2($bondHandle2,$whichPDL2,\@bondCache,$indexhandle);
	## Sort bonds by i then j ## 
	@bondCache = sort {($a->{"i"} <=> $b->{"i"}) || ($a->{"j"} <=> $b->{"j"}) } @bondCache;

	## Print our sorted bonds ##
	foreach my $p(@bondCache)
	{
		addToTop("bonds",$p->{"v"});
	}
}

##
# call  calculateBondsHelper1() for each residue defined in templates
sub calculateBonds1
{
	my($bondFunctHandle,$whichPDL,$bondCache,$indexhandle,$allatoms) = @_;
	foreach my $res(keys %{$bondFunctHandle}){
	       if(!exists $whichPDL->{$res}){next;}
	       calculateBondsHelper1($bondFunctHandle->{$res},$whichPDL->{$res},$bondCache,$indexhandle,$allatoms);
	}
}


##
#call connCalculateBondsHelper() for each chain in PDB
sub calculateBonds2
{
	my($bondHandle,$whichPDL,$bondCache,$indexhandle) = @_;
	foreach my $chain(keys %{$bondHandle})
	{
		calculateBondsHelper2($bondHandle->{$chain},$whichPDL->{$chain},$bondCache,$indexhandle);
	
	}
}

sub calculateBondsHelper1
{
	my($bondHash,$inputPDL,$bondCache,$indexhandle,$allatoms) = @_;
	my $bondArr = $bondHash->{"bonds"};
	my $bondFunc =$bondHash->{"functions"};
	my $bondIndex = 0;
	foreach my $bonds(@{$bondArr})
	{
	       my ($atomOne,$atomTwo) = split("-",$bonds);
	       my $outer = slice($inputPDL,"0:2,$atomOne,:")-slice($inputPDL,"0:2,$atomTwo,:");
	       my @bondList = (sqrt(inner($outer,$outer))*$angToNano)->flat()->list();
	       my @indexList1 = slice($inputPDL,"3:3,$atomOne,:")->flat()->list();
	       my @indexList2 = slice($inputPDL,"3:3,$atomTwo,:")->flat()->list();
	       for(my $i=0;$i<scalar(@bondList);$i++)
	       {
			my $I1=$indexList1[$i];
			my $I2=$indexList2[$i];
			my $val=bondOutput($bondFunc->[$bondIndex],$I1,$I2,$bondList[$i],$indexhandle,$allatoms);
			if(!$val){next;}
			# i,j are meta data
	 		push @{$bondCache}, {'i' => $I1,'j' => $I2, 'v' => $val};
		}
	       	$bondIndex++;
	
	}
}

sub calculateBondsHelper2
{
	my($bondInfo,$inputPDL,$bondCache,$indexhandle) = @_;
	my $size = $bondInfo->dim(1);
	for(my $i=0;$i<$size;$i++)
	{
		my $atomOne = sclr(slice($bondInfo,"0:0,$i:$i"));
		my $atomTwo = sclr(slice($bondInfo,"1:1,$i:$i")); 
		my $func = sclr(slice($bondInfo,"2:2,$i:$i"));
		my $outer = slice($inputPDL,"0:2,$atomOne,:")-slice($inputPDL,"0:2,$atomTwo,:");
		my $output = sclr(sqrt(inner($outer,$outer))*$angToNano);
		$atomOne = sclr(slice($inputPDL,"3:3,$atomOne,:"));
		$atomTwo = sclr(slice($inputPDL,"3:3,$atomTwo,:"));
		my $val=bondOutput(intToFunc("bonds",$func,""),$atomOne, $atomTwo,$output,$indexhandle,0);
		if(!$val){next;}
		push @{$bondCache}, {'i' => $atomOne,'j' => $atomTwo, 'v' => $val};
	}
}


##
# Convert internal bond function format to gromacs function format,
sub bondOutput
{
	my($inputFunc,$i,$j,$values,$indexhandle,$allatoms) = @_;
	if(!$inputFunc){smog_quit ("BONDOUTPUT::NO FUNCTION DEFINED");}
	## Remove white spaces from string ##
	$inputFunc =~ s/^\s+|\s+$//g;
	## If $input contains a + ##
	my @funcs = split(/\+/,$inputFunc); ## split combination of functions
	my $outputString="";
	my @paramArr;
	my $fType=""; my $formattedString;
	       ## Parse each part of the function ##
	foreach my $fun(@funcs){
		my $paramFormat="";
		($fType,@paramArr) = bondFuncParser($fun);
		## $paramArr[0] is bond length
		if($fType != 0){
	       
			
			if($fType == -1){
				# this mean bond_bytype was used
				# don't write distances or strengths. Make gromacs use bondtype
				# since we are not writing a distance, let's check and make sure this pair has a bondtype provided
				&checkbondtype($i,$j,$allatoms); 
				$formattedString = sprintf("%d\t%d\t%d",$i,$j,$paramArr[0]);
				$outputString = "$outputString$formattedString\n";
			}else{
	        		if($paramArr[0] =~ /\?/){
					$paramArr[0]=$values; # native option used
				} 
	        		## Check bonds threshold ##
	        		if($paramArr[0] < $interactionThreshold->{"bonds"}->{"shortBond"}
	        		|| $paramArr[0] > $interactionThreshold->{"bonds"}->{"longBond"}){
					my $DIST=int($paramArr[0]*100)/100.0;
					my %reflist=%{$indexhandle};
					if($setBondtoLimit){
						if(!exists $reflist{$i} || !exists $reflist{$j}){
							smog_quit("Internal error 2.  Please inform smog team");
						}
						my $i1=$reflist{$i};
						my $j1=$reflist{$j};
						print("\n\nNOTE: Distance of $DIST nm calculated for atom pair $i $j (gro indices.  Or, lines $i1 and $j1 of PDB file). This is outside of bond threshold range.\n\n");
						print "-limitbondlength is being used, will set length to ";
		 				if($paramArr[0] < $interactionThreshold->{"bonds"}->{"shortBond"}){
		  					$paramArr[0]=$interactionThreshold->{"bonds"}->{"shortBond"};
		  					print "$paramArr[0] nm\n\n";
		 				}elsif($paramArr[0] > $interactionThreshold->{"bonds"}->{"longBond"}){
		  					$paramArr[0]=$interactionThreshold->{"bonds"}->{"longBond"};
		  					print "$paramArr[0] nm\n\n";
		 				}
					}else{
						if(!exists $reflist{$i} || !exists $reflist{$j}){
							smog_quit("Internal error 3.  Please inform smog team");
						}
						my $i1=$reflist{$i};
						my $j1=$reflist{$j};
						smog_quit("Distance of $DIST nm calculated for atom pair $i $j (gro indices.  Or, lines $i1 and $j1 of PDB file). This is outside of bond threshold range.");
					}
	        		}	
	## Format output <i j function p1 p2 ... pn>
				foreach(@paramArr){$paramFormat="$paramFormat %12.9e";}
				$formattedString = sprintf("%d\t%d\t%d\t$paramFormat",$i,$j,$fType,@paramArr);
				$outputString = "$outputString$formattedString\n";
	       		}
		}else{
			$freebonds{"$i-$j"}=1;
			$freebonds{"$j-$i"}=1;
		}
	}
	return $outputString;
}

sub checkbondtype
{
	my ($i,$j,$allatoms)=@_;
	my $found=0;
	# only check that the pair has a bondtype, if the hash is defined
	if($allatoms ne "0"){
		my $typei=$allatoms->{$i}->[0];
		my $typej=$allatoms->{$j}->[0];
		foreach my $I("X",$typei)
		{
			foreach my $J("X",$typej)
			{
				my $nm="$I-$J";
				if(defined $foundBtype{$nm})
				{
					$found=1;
					return;
				}
			}
		}
		if($found ==0){
			smog_quit("Default bond interaction not provided for pair $i-$j (types $typei and $typej)");
		}
	}
}

sub checkangletype
{
	my ($i,$j,$k,$allatoms)=@_;
	my $found=0;
	# only check that the pair has a bondtype, if the hash is defined
	my $typei=$allatoms->{$i}->[0];
	my $typej=$allatoms->{$j}->[0];
	my $typek=$allatoms->{$k}->[0];
	foreach my $I("X",$typei)
	{
		foreach my $J("X",$typej)
		{
			foreach my $K("X",$typek)
			{
				my $nm="$I-$J-$K";
				if(defined $foundAtype{$nm})
				{
					$found=1;
					return;
				}
			}
		}
	}
	if($found ==0){
		smog_quit("Default angle interaction not provided for pair $i-$j-$k (types $typei, $typej, $typek)");
	}
}


sub checkdihedraltype
{
	my ($i,$j,$k,,$l,$allatoms)=@_;
	# only check that the pair has a bondtype, if the hash is defined
	my $typei=$allatoms->{$i}->[0];
	my $typej=$allatoms->{$j}->[0];
	my $typek=$allatoms->{$k}->[0];
	my $typel=$allatoms->{$l}->[0];
	my $found=0;
	foreach my $I("X",$typei)
	{
		foreach my $J("X",$typej)
		{
			foreach my $K("X",$typek)
			{
				foreach my $L("X",$typel)
				{
					my $nm="$I-$J-$K-$L";
					if(defined $foundDtype{$nm})
					{
						$found=1;
						return;
					}
				}
			}
		}
	}
	if($found ==0){
		smog_quit("Default dihedral interaction not provided for pair $i-$j-$k-$l (types $typei, $typej, $typek, $typel)");
	}
}


##
# Given a user defined function, parse values
sub bondFuncParser
{
	my($bondFunc) = @_;
	my $fType;my @paramArr;my $directive;
	my $funcName = ""; my $params = "";
 	($bondFunc =~ m/(.*)\((.*)\)/);
	$funcName = $1;
	$params = $2;
	($fType,$directive) = returnFunction($funcName); ## Obtain Gromacs function type
	if($directive ne "bonds"){smog_quit ("$funcName is not a valid bonds function");}
 	@paramArr = split(",",$params); ## Parse all parameters
 	foreach $params(@paramArr){$params =~ s/^\s+|\s+$//g;}
	return ($fType,@paramArr);
}

######################
## CALCULATE ANGLES ##
######################

##
# Combined bond calculation,sorting, and printing
sub printOrderedAngles
{
	my($AngleData,$bondPDL,$indexhandle,$allatoms) = @_;
	my @angleCache; ## CACHE BONDS TO ORDER

	## Cache Bonds ##
	CalculateAngles($AngleData,$bondPDL,\@angleCache,$indexhandle,$allatoms);

	## Sort angles by i,j then k ## 
	@angleCache = sort {($a->{"i"} <=> $b->{"i"}) || ($a->{"j"} <=> $b->{"j"}) || ($a->{"k"} <=> $b->{"k"})} @angleCache;

	## Print our sorted bonds ##
  	foreach my $p(@angleCache){
  		addToTop("angles",$p->{"v"});
	}
}

##

##
# CalculateAnglesHelper() calculates the angles for each chain
sub CalculateAngles
{
	my($angleFunctHandle,$whichPDL,$angleCache,$indexhandle,$allatoms) = @_;
 
	foreach my $chain(keys %{$angleFunctHandle}){
		CalculateAnglesHelper($angleFunctHandle->{$chain},$whichPDL->{$chain},$angleCache,$indexhandle,$allatoms);
	}
}

##
sub CalculateAnglesHelper
{
	my($angleArr,$inputPDL,$angleCache,$indexhandle,$allatoms) = @_;
	my $size = $angleArr->dim(1);
	for(my $i=0;$i<$size;$i++)
	{
		my ($atom1,$atom2,$atom3,$func) = $angleArr->slice(":,$i:$i")->list;
		my $A1=slice($inputPDL,"0:2,$atom1,:");
		my $A2=slice($inputPDL,"0:2,$atom2,:");
		my $A3=slice($inputPDL,"0:2,$atom3,:");		
		my $atomi1 = sclr(slice($inputPDL,"3:3,$atom1,:"));
		my $atomi2 = sclr(slice($inputPDL,"3:3,$atom2,:"));
		my $atomi3 = sclr(slice($inputPDL,"3:3,$atom3,:"));
		my $left = norm($A1-$A2);
		my $right = norm($A3-$A2);
		my $outer = norm($A3-$A1);
				
		my $acos = mathFunctions::rad_to_deg(mathFunctions::acos(sclr(inner($left,$right))));
		
		if($atomi1 > $atomi3) { my $temp = $atomi1; $atomi1 = $atomi3; $atomi3 = $temp; }
		my $val=angleOutput(intToFunc("angles",$func,""),$atomi1,$atomi2,$atomi3,$acos,$indexhandle,$allatoms);
		if(!$val) {next;}
			# i,j,k are meta data
	 	push @{$angleCache}, {'i' => $atomi1,'j' => $atomi2,'k' =>$atomi3, 'v' => $val};
	}
}

## 
# Convert internal angle function format to gromacs function format
sub angleOutput
{
 	my($inputFunc,$i,$j,$k,$values,$indexhandle,$allatoms) = @_;
	if(!$inputFunc){smog_quit ("ANGLEOUTPUT::NO FUNCTION DEFINED");}
 ## Remove white spaces from string ##
 	$inputFunc =~ s/^\s+|\s+$//g;
 ## If $input contains a + ##
	my @funcs = split(/\+/,$inputFunc);
	my $outputString="";
	my $value="";my $kd="";
	my $fType="";my @paramArr;
	my $formattedString="";
	foreach my $fun(@funcs)
	{
		my $paramFormat="";
		($fType,@paramArr) = angleFuncParser($fun);

		if($fType ==-1){
			 ## don't write distance. Make gromacs use angletype
			&checkangletype($i,$j,$k,$allatoms); 
			$formattedString = sprintf("%d\t%d\t%d\t%d",$i,$j,$k,$paramArr[0]);
			$outputString = "$outputString$formattedString\n";
		}else{

			if($fType != 0 && !exists $freebonds{"$i-$j"} && !exists $freebonds{"$j-$i"} && !exists $freebonds{"$k-$j"} && !exists $freebonds{"$j-$k"}){
				if($paramArr[0] =~ /\?/){$paramArr[0]=$values;} ## non-native option used
		
				## Check angles threshold ##
		 		if($paramArr[0] < $interactionThreshold->{"angles"}->{"smallAngles"}){ 
					my $THETA=int($paramArr[0]*100)/100.0;
					my %reflist=%{$indexhandle};
					my $i1=$reflist{$i};
					my $j1=$reflist{$j};
					my $k1=$reflist{$k};
					smog_quit("Angle between atoms $i $j $k (PDB lines $i1 $j1 $k1) smaller than smallAngles (see .sif): theta=$THETA degrees\n\tBe careful! Depending on the angles adopted during the simulation, this may lead to numerical instabilites.",1);
				}
		 		if($paramArr[0] > $interactionThreshold->{"angles"}->{"largeAngles"}){
					my $THETA=int($paramArr[0]*100)/100.0;
					my %reflist=%{$indexhandle};
					my $i1=$reflist{$i};
					my $j1=$reflist{$j};
					my $k1=$reflist{$k};
					smog_quit("Angle between atoms $i $j $k (PDB lines $i1 $j1 $k1) greater than largeAngles (see .sif): theta=$THETA degrees\n\tBe careful!  This can lead to numerical instability of your simulations.",1);
				}
	 		## Format output <i j k function p1 p2 ... pn>
	 			foreach(@paramArr){$paramFormat="$paramFormat %12.9e";}
				$formattedString = sprintf("%d\t%d\t%d\t%d\t$paramFormat",$i,$j,$k,$fType,@paramArr);
				$outputString = "$outputString$formattedString\n";
			}else{
				$freeangles{"$i-$j-$k"}=1;
				$freeangles{"$k-$j-$i"}=1;
			}
		}
	}
	return $outputString; 
}

##
# Given a user defined angle function parse values
sub angleFuncParser
{
	my($angFunc) = @_;
	my $fType;my @paramArr;my $directive;
	my $funcName = ""; my $params = "";
 	($angFunc =~ m/(.*)\((.*)\)/);
	$funcName = $1;
	$params = $2;
	($fType,$directive) = returnFunction($funcName); ## Obtain Gromacs function type
	if($directive ne "angles"){smog_quit ("$funcName is not a valid angles function");}
 	@paramArr = split(",",$params); ## Parse all parameters
 	foreach $params(@paramArr){$params =~ s/^\s+|\s+$//g;}
	return ($fType,@paramArr);
}

#########################
## CALCULATE DIHEDRALS ##
#########################

##
# Combined dihedral calculation,sorting, and printing
sub printOrderedDihedrals
{
	my($DihedralData,$bondPDL,$allatoms) = @_;
	my @diheCache; ## CACHE BONDS TO ORDER
	## Cache Bonds ##
	CalculateDihedrals($DihedralData,$bondPDL,\@diheCache,$allatoms);
	## Sort dihedrals by i, then j then k then l ## 
	@diheCache = sort {($a->{"i"} <=> $b->{"i"}) || ($a->{"j"} <=> $b->{"j"}) || ($a->{"k"} <=> $b->{"k"}) || ($a->{"l"} <=> $b->{"l"}) } @diheCache;
	
	## Print our sorted bonds ##
	foreach my $p(@diheCache){
		addToTop("dihedrals",$p->{"v"});
	}
	addToTop("dihedrals","\n");
}

##
# Setup the calculation of dihedral angles of all combined residues,
sub CalculateDihedrals
{
	my($diheFunctHandle,$whichPDL,$diheCache,$allatoms) = @_;
	foreach my $chain(keys %{$diheFunctHandle}){
		CalculateDihedralsHelper($diheFunctHandle->{$chain},$whichPDL->{$chain},$diheCache,$allatoms);
	}
}

sub CalculateDihedralsHelper
{
	 my($diheArr,$inputPDL,$diheCache,$allatoms) = @_;
	 my $size = $diheArr->dim(1);
	 for(my $i=0;$i<$size;$i++)
	 {
			my @TMP=$diheArr->slice(":,$i:$i")->list;
			if(@TMP < 7){next;}
			my ($atom1,$atom2,$atom3,$atom4,$func,$cD,$eG) = $diheArr->slice(":,$i:$i")->list;
		
		  	my $A1=slice($inputPDL,"0:2,$atom1,:"); 
		  	my $A2=slice($inputPDL,"0:2,$atom2,:"); 
		  	my $A3=slice($inputPDL,"0:2,$atom3,:"); 
		  	my $A4=slice($inputPDL,"0:2,$atom4,:"); 

			my $b1=$A2-$A1;
			my $b2=$A3-$A2;
			my $b3=$A4-$A3;
		
			my $n1 = norm(crossp($b1,$b2));
			my $n2 = norm(crossp($b2,$b3));
			my $m1 = crossp($n1,norm($b2));
		
			my $cos = atan2(inner($m1,$n2),inner($n1,$n2));
			my $negcos = $cos;#$cos->where($cos < 0);
	
			$negcos*=-1;$negcos+=mathFunctions::pi();
			my $acos = sclr(mathFunctions::rad_to_deg($cos));
		
			my $atomi1 = sclr(slice($inputPDL,"3:3,$atom1,:"));
			my $atomi2 = sclr(slice($inputPDL,"3:3,$atom2,:"));
			my $atomi3 = sclr(slice($inputPDL,"3:3,$atom3,:"));
			my $atomi4 = sclr(slice($inputPDL,"3:3,$atom4,:"));
			if($atomi1 > $atomi4) { #then reverse order
				my $temp = $atomi1; $atomi1 = $atomi4; $atomi4 = $temp;
				$temp = $atomi2; $atomi2 = $atomi3; $atomi3 = $temp;
			}
			## $eG >=0 dihedral is proper dihedral of any functional form
	        if($eG >= 0)
			{
				my $val = dihedralOutput(intToFunc("dihedrals",$func,$eG),$atomi1,$atomi2,$atomi3,$atomi4,$acos,$cD,$eG,$allatoms);
				if(!$val) {next;}
				# i,j,k,l are meta data
				push @{$diheCache}, {'i' => $atomi1,'j' => $atomi2,'k' =>$atomi3, 'l' => $atomi4, 'v' => $val};
			}
			## Improper dihedral
			else
			{
				push @{$diheCache}, {'i' => $atomi1,'j' => $atomi2,'k' =>$atomi3, 'l' => $atomi4, 'v' => dihedralOutput(intToFunc("impropers",$func,$eG),$atomi1,$atomi2,$atomi3,$atomi4,$acos,$cD,-1)};
	 	   }
	 }
}

sub dihedralOutput
{
 	my($inputFunc,$ai,$aj,$ak,$al,$values,$ratio,$eG,$allatoms) = @_;
 	## Remove white spaces from string ##
 	$inputFunc =~ s/^\s+|\s+$//g;
 	## If $input contains a + ##
 	my @funcs = split(/\+/,$inputFunc);
	my $outputString="";
	my $fType="";       
 	my $formattedString="";
	my @paramArr;
	my $funci=0; my @fTypei;
	foreach my $fun(@funcs)
	{
		my $paramFormat="";
		# since this is only used here, we may remove the call and sub in the code
		($fType,@paramArr) = diheFuncParser($fun);
		if($fType ==-1){
			 ## don't write angle. Make gromacs use dihedraltype
			&checkdihedraltype($ai,$aj,$ak,$al,$allatoms);
			$formattedString = sprintf("%d\t%d\t%d\t%d",$ai,$aj,$ak,$al);
			$outputString = "$outputString$formattedString\n";
		}else{

	 		if($fType !=0 && !exists $freeangles{"$ai-$aj-$ak"} && !exists $freeangles{"$ak-$aj-$ai"} && !exists $freeangles{"$aj-$ak-$al"} && !exists $freeangles{"$al-$ak-$aj"}  ){
				# If there is a ?, then substitute the angle value and apply the multiplicity.  If there is no wild card, then simply use the angle provided
				if($paramArr[0] =~ /\?/){
			         # replace ? with native angles
			   	 $paramArr[0] =~ s/\?/$values/g;
				 # evaluate
				 $paramArr[0] = eval($paramArr[0]);
				 }
				 if( $fType == 1){
			            # Angle will be scaled by multiplicity factor n, if they are cosine functions
			            $paramArr[0] *= $paramArr[2];
				 }
			
	
				# Perform checks of dihedral parameters (only do this once, then set funtypechecked)
				unless(exists $funtypechecked{$fun}){
					$funtypechecked{$fun}=1;		
			        	if($paramArr[1] =~ /[*?^&!@#%()]/){smog_quit ("Dihedral weight can only contain numbers, but $paramArr[1] found.")};
			
					if($fType == 0 and $energyGroups->{$eGTable{$eG}}->{"normalize"} != 0){
						smog_quit("Function type dihedral_free is being used for an energy group with normalize != 0.  This can lead to unpredictable results.");
					}
			
					if($funci == 0){
					  $fTypei[0]= $fType;
			
					  if($fType==1 and $paramArr[1] != 1 and $energyGroups->{$eGTable{$eG}}->{"normalize"} != 0){
					   smog_quit ("Since normalization is turned on, the first cosine dihedral in a sum should have weight of 1.\n In order to adjust overall weight of dihedral, while also imposing normalization, use intraRelativeStrength in .sif file");
					  }
					}elsif($funci != 0 and $fTypei[0] != $fType){
			        	  smog_quit ("Sums of dihedrals of different types is not supported.");
					}
				}
				# end of consistency checks
	
	
				$funci++;
				## If dihedral kd is normalized or has scaling&normalize ##
			 	$paramArr[1]*=$ratio;
				## Format output <i j k function p1 p2 ... pn>
			 	for(my $I=0;$I<=$#paramArr;$I++){$paramFormat="$paramFormat %12.9e";}
			 	#foreach(@paramArr){$paramFormat="$paramFormat %12.9e";}

				if($fType == 1) {
					$paramFormat=" %12.9e %12.9e %u";
				}elsif($fType == 2){	
				### CONVERT FIX RIGID/IMPROPER DIHEDRALS ANGLES TO GROMACS CONVENTION ###
					if($paramArr[0]>180){$paramArr[0]-=180;}else{$paramArr[0]+=180;}
				}	
				$formattedString = sprintf("%d\t%d\t%d\t%d\t%d\t$paramFormat",$ai,$aj,$ak,$al,$fType,@paramArr);
				$outputString = "$outputString$formattedString\n";
			}
		}
	}
		return $outputString;
 }
 
##
# Given a user defined dihedral function, parse values
sub diheFuncParser
{
	my($diheFunc) = @_;
 	my $fType;my @paramArr; my $directive;
	my $funcName = "";my $params = "";
	($diheFunc =~ m/(.*)\((.*)\)/);
	$funcName = $1; $params = $2;

	($fType,$directive) = returnFunction($funcName); ## Obtain Gromacs function type
	if($directive ne "dihedrals"){smog_quit ("$funcName is not a valid dihedrals function");}
	@paramArr = split(",",$params); ## Parse all parameters;
	foreach $params(@paramArr){$params =~ s/^\s+|\s+$//g;}
	return ($fType,@paramArr);
}


########################
## CALCULATE CONTACTS ##
########################

sub calculateContacts
{
	my($contactPDL,$inputPDL,$atomTypes,$numCon,$numAtom) = @_;
	my $atoma; my $atomb; my $dist;
	my $pairtypea; my $pairtypeb;
	my $resTypea; my $resTypeb;
	my $multFactor = 1;
	my $c0;  
	my $epsilon;my $cG;my $funct;
 	my $totalStrength; 
	my $contactIntraScale;
	my $count;


	## Sum all initial contact strengths ##	
	my %conttypeseen;
	for(my $i=0;$i<$numCon;$i++)
	{
		my $normalize;
		$atoma = sclr(slice($contactPDL,"1:1,$i:$i"));
		$atomb = sclr(slice($contactPDL,"2:2,$i:$i"));
		$pairtypea = $atomTypes->{$atoma}->[10];
		$pairtypeb = $atomTypes->{$atomb}->[10];
		$resTypea = $atomTypes->{$atoma}->[1];
		$resTypeb = $atomTypes->{$atomb}->[1];
		my $resnamea = $atomTypes->{$atoma}->[5];
		my $resnameb = $atomTypes->{$atomb}->[5];
		($funct,$cG) = getContactFunctionals($pairtypea,$pairtypeb);
		$conttypeseen{$funct}=1;
		if(!$funct || !$cG){smog_quit("No contact Function defined for nbType contacts $pairtypea-$pairtypeb");}
		$normalize = $termRatios->{"contactGroup"}->{$cG}->{"normalize"};
		if(!$normalize){next;}		
		$contactIntraScale = $termRatios->{"contactGroup"}->{$cG}->{"intraRelativeStrength"};

		my ($fType,$fname,$directive,$addExclusions,@paramArr) = contactFuncParser($funct);
		unless($residues{$resnamea}->{'atomCount'}==0 || $residues{$resnameb}->{'atomCount'}==0){
			$count+=$contactIntraScale;
		}
	}
	if(scalar keys %conttypeseen >1){
		my $L;
		foreach my $CT(keys %conttypeseen){
			$L .= $CT;
			$L .= " ";
		}
		smog_quit("More than one type of contact being used at the same time. Not all combinations of contacts are supported by Gromacs. List of used contact types: $L",1);
 	}
	## Adjust ratio ##
	for(my $i=0;$i<$numCon;$i++){
		my $contactLeftOver;my $diheTotal; my $normalize;
		my $deltaMin=-1;my $scale=-1;my $deltaMax=-1;
		my $resIdxA=0;my $resIdxB=0;
		my $atomA="";my $atomB="";
		my $outputString;
		my $directive;my $addExclusions;
		$atoma = sclr(slice($contactPDL,"1:1,$i:$i"));
		$atomb = sclr(slice($contactPDL,"2:2,$i:$i"));
		$pairtypea = $atomTypes->{$atoma}->[10];
		$pairtypeb = $atomTypes->{$atomb}->[10];
		$resTypea = $atomTypes->{$atoma}->[1];
		$resTypeb = $atomTypes->{$atomb}->[1];
		($funct,$cG) = getContactFunctionals($pairtypea,$pairtypeb);
		if(!$funct || !$cG){smog_quit("No contact Function defined for nbType contacts $pairtypea-$pairtypeb");} 
		
		$normalize = $termRatios->{"contactGroup"}->{$cG}->{"normalize"};
		## Stacking scaling ##
		$epsilon = 1;
		if(exists $contactSettings->{"contactScaling"}->{$resTypea}
		&& exists $contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb})
		{
			$deltaMin=$contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"deltaMin"};
			$deltaMax=$contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"deltaMax"};
			
			$scale = $contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"scale"};
			$scale = eval($scale);
			$resIdxA = $allAtoms{$atoma}->[2];
			$resIdxB = $allAtoms{$atomb}->[2];
			
			$atomA = $allAtoms{$atoma}->[3];
			$atomB = $allAtoms{$atomb}->[3];
			##Atom to boolean##
			$atomA = exists($contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"atomList"}->{$atomA});
			$atomB = exists($contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"atomList"}->{$atomB});
			
			
			if(abs($resIdxB-$resIdxA)>=$deltaMin 
			&& abs($resIdxB-$resIdxA)<=$deltaMax
			&& $atomA && $atomB){
				$epsilon*=$scale;
			}else{
				$epsilon=1;
			}
		}

		## Non-normalize option for contacts ##
		if(!$normalize) {
			$dist = sclr(slice($contactPDL,"3:3,$i:$i"));
			$c0=$dist;
			($directive,$addExclusions,$outputString) = contactOutput($funct,$atoma,$atomb,$c0,$epsilon,$normalize);
			addToTop($directive,$outputString);
			if($addExclusions) { addToTop("exclusions",$atoma."	".$atomb."\n"); }
		}else{	
			## DIHE TO CONTACT SCALING ##
			## DIHEDRAL TO CONTACT RATIO IS GLOBAL IRREGARDLESS OF RESIDE TYPE ##
			$totalStrength = $termRatios->{"interRelativeTotal"};
			$diheTotal = $termRatios->{"energyRelative"};
			$contactLeftOver = $numAtom - $numAtom*($diheTotal/$totalStrength);
			$contactLeftOver = $contactLeftOver/$count;
	   		$multFactor = $contactLeftOver;
	
			## CONTACT TO CONTACT SCALING ##			
			$contactIntraScale = $termRatios->{"contactGroup"}->{$cG}->{"intraRelativeStrength"};
			$multFactor = $multFactor*$contactIntraScale;
	
			$epsilon = $epsilon*$multFactor*$rescaleCD;
			$dist = sclr(slice($contactPDL,"3:3,$i:$i"));
			$c0=$dist;
			($directive,$addExclusions,$outputString) = contactOutput($funct,$atoma,$atomb,$c0,$epsilon,$normalize);
			addToTop($directive,$outputString);
			if($addExclusions) { addToTop("exclusions",$atoma."	".$atomb."\n"); }
		}
	}
}

##
# Convert internal contact function format to gromacs function format,
# internal format is f()+g()
sub contactOutput
{
	my($inputFunc,$i,$j,$c0,$epsilon,$normalize) = @_;
	if(!$inputFunc){smog_quit ("CONTACTOUTPUT::NO FUNCTION DEFINED");}
	$inputFunc =~ s/^\s+|\s+$//g;
	## If $input contains a + ##
	my @funcs = split(/\+/,$inputFunc); ## split combination of functions
	my $outputString="";
	my @paramArr;
	my $fname;
	my $directive;
	my $addExclusions;
	my $fType=""; my $formattedString;
	my $addNewline = "";
	## Parse each part of the function ##
	foreach my $fun(@funcs){
		my $paramFormat="";
		($fType,$fname,$directive,$addExclusions,@paramArr) = contactFuncParser($fun);
		## LJ CONTACTS N-M polynomial, sigma and epsilon usage ##	
		if($fType != 0) {
			$addNewline = "\n";
			if($fname eq "contact_1"){
				contactParseNM1(\@paramArr,$c0,$epsilon,$normalize);
				if($fType != 1){smog_quit ("Only fType=1 is supported with contacts contact_1")}
			}
			## LJ CONTACTS N-M polynomial, CN, CM usage ##	
			elsif($fname eq "contact_2"){
				contactParseNM2(\@paramArr,$c0,$epsilon,$normalize);
				if($fType != 1){smog_quit ("Only fType=1 is supported with contacts contact_2")}
			}
			    ## Gaussian ##
			elsif($fname eq "contact_gaussian"){
				contactParseGaussian(\@paramArr,$c0,$epsilon,$normalize);
				if($fType != 6){smog_quit ("Only fType=6 is supported with contacts contact_gaussian")}
			}
			## harmonic bond type 6 ##
			elsif($fname eq "bond_type6"){
				contactParseBond6(\@paramArr,$c0,$epsilon);
    				if($fType != 6){smog_quit ("Only fType=6 is supported with contacts of bond_type6")}

			}else{smog_quit("Contact function name $fname is not supported");}

 	## Format output <i j function p1 p2 ... pn>
		 	foreach(@paramArr){$paramFormat="$paramFormat %12.9e";}
			$formattedString = sprintf("%d\t%d\t%d\t$paramFormat",$i,$j,$fType,@paramArr);
			$outputString = "$outputString$formattedString";
		}
	}
	return ($directive,$addExclusions,$outputString.$addNewline);
}

##
# Parse LJ NM sigma eps usage
sub contactParseNM1
{
	my($paramArr,$r0,$epsilon,$normalize) = @_;
	##pararArr holds N, M, and whether native distances and weights should be used.
	##epsilon
	##r0 is native distance##
	#
	my $A; my $B;
	my $N; my $M;
	$M=$paramArr->[0];
	$N=$paramArr->[1];
	my $length=scalar @{$paramArr};

	if($length != 4){ smog_quit ("Incorrect number of parameters provided for contact_1. Expecting 4, found $length."); }
	if($N =~ /^\?$/ or $M =~ /^\?$/ or $N  !~ /^\d+$/ or $M  !~ /^\d+$/){smog_quit ("Must provide integers for exponents of function contact_1");}
	if($M>=$N){smog_quit ("When using contact_1, the first exponent provided should be smaller.")}
	
	$B=-1.0/($M/$N-1.0);
	$A=$M/$N*$B;
	# replace ? with native distance expression
	$paramArr->[2] =~ s/\?/$r0/g;
	#Eval expression
	$r0 = eval($paramArr->[2]);
	   
	$A *= $epsilon*$r0**$N;
	$B *= $epsilon*$r0**$M;
	
	## normalized option used
	if($paramArr->[3] =~ /^\?$/)
	{
		if(!$normalize){smog_quit("contact type can not have normalization turned off with epsilon=?")}
		$paramArr->[3]=$A;
		$paramArr->[2]=$B;
	}
	## additional rescaling used
	elsif($paramArr->[3] =~ /\?/)
	{
		smog_quit("Epsilon value used in contact_1 interaction can not be an expression that includes ?.\n");
	}
	else{
		if($normalize){smog_quit("Can\'t normalize a contact since the weight is not defined by a ? mark.")}
		$A *= $paramArr->[3];
		$B *= $paramArr->[3];
		$paramArr->[3]=$A;
		$paramArr->[2]=$B;
	} 
	## Shift first value off ##
	shift @{$paramArr};
	shift @{$paramArr};
}

# Parse LJ: F_N(sigma), G_M(sigma), sigma, epsilon format
sub contactParseNM2
{
	my($paramArr,$r0,$epsilon,$normalize) = @_;
	##pararArr holds f(r), g(r), and whether native distances and weights should be used.
	##epsilon  
	##r0 is native distance##
	#
	my $A; my $B;
	my $F; my $G;
	$F=$paramArr->[1];
	$G=$paramArr->[0];
	my $length=scalar @{$paramArr};

	if($length != 4){ smog_quit ("Incorrect number of parameters provided for contact_2. Expecting 4, found $length."); }
	
	# replace ? with native distance expression
	$paramArr->[2] =~ s/\?/$r0/g;
	$paramArr->[2] = eval($paramArr->[2]);
	
	# substitute value of r into f(r) and g(r)
	$F =~ s/\?/$paramArr->[2]/g;
	$G =~ s/\?/$paramArr->[2]/g;
	
	#Eval expression
	$A = eval($F);
	$B = eval($G);
	$A *= $epsilon; 
	$B *= $epsilon; 
	
	## standard normalization used
	if($paramArr->[3] =~ /^\?$/)
	{
		if(!$normalize){smog_quit("contact type can not have normalization turned off with epsilon=?")}
		$paramArr->[3]=$A;
		$paramArr->[2]=$B;
	}
	elsif($paramArr->[3] =~ /\?/)
	{
		smog_quit("Epsilon value used in contact_2 interaction can not be an expression that includes ?.\n");
	}
	## additional rescaling used
	else{
		if($normalize){smog_quit("Can\'t normalize a contact since the weight is not defined by a ? mark.")}
		$A *= $paramArr->[3];
		$B *= $paramArr->[3];
		$paramArr->[3]=$A;
		$paramArr->[2]=$B;
	} 
	## Shift first value off ##
	shift @{$paramArr};
	shift @{$paramArr};
}


##
# Parse Gaussian Params
sub contactParseGaussian
{

	my($paramArr,$r0,$epsilon,$normalize) = @_;
	my $A=0;my $sigma_G=0;my $a=0;
	##i=0 is epsilon_c##
	##i=1 is epsilon_nc#
	##i=2 is sigma_gaussian##
	##i=3 is r ##
	
	if($paramArr->[1] =~ /\?/ && !($paramArr->[2] =~ /^\?$/)){smog_quit("CONTACT FUNCTION PARSING:: CONFLICTING INPUTS");}
	
	## Epsilon_c ##
	if($paramArr->[0] =~ /^\?$/){
		if(!$normalize){smog_quit("contact type can not have normalization turned off with epsilon=?")}
		$paramArr->[0]=$epsilon;
	}
	elsif($paramArr->[0] =~ /\?/)
	{
		smog_quit("Epsilon value used in gaussian interaction can not be an expression that includes ?.\n");
	}
	else{
		if($normalize){smog_quit("Can\'t normalize a contact since the weight is not defined by a ? mark.")}
		$paramArr->[0]=$epsilon*($paramArr->[0]);
	}
	## Epsilon_nc ##
	if($paramArr->[1] =~ /\?/){smog_quit("value of a in gaussian can not be a ? mark");}
	
	## Check if sigma_G has r0 dependency ##
	if($paramArr->[2] =~ /\?/)
	{
		#Replace ? with $r0 
		$paramArr->[2] =~ s/\?/$r0/g;
		#Eval expression
		$paramArr->[2] = eval($paramArr->[2]);
	}
	if($paramArr->[3] =~ /^?$/){$paramArr->[3]=$r0;}
	
	($A,$r0,$sigma_G,$a) = ($paramArr->[0],$paramArr->[3],$paramArr->[2],$paramArr->[1]);
	@{$paramArr}=($A,$r0,$sigma_G,$a);

}
##
# Parse Bond type 6
sub contactParseBond6
{
my($paramArr,$r0,$epsilon) = @_;
my $k;
	##i=0 is r##
	##i=1 is k#
	
	## k ##
	if($paramArr->[1] =~ /\?/){smog_quit("CONTACT FUNCTION PARSING:: contact bond_type6 can't have ? in the stiffness.");}
	$paramArr->[1] = eval($paramArr->[1]);
	
	## r ##
	if($paramArr->[0] =~ /\?/)
	{
		#Replace ? with $r0 
		$paramArr->[0] =~ s/\?/$r0/g;
	}
	#Eval expression
	$paramArr->[0] = eval($paramArr->[0]);
	
	($r0,$k) = ($paramArr->[0],$paramArr->[1]);
	@{$paramArr}=($r0,$k);

}

##
# Given a user defined contact function parse values
sub contactFuncParser
{
	my($contactFunc) = @_;
	my $fType;my @paramArr;my $directive;my $addExclusions;
	my $funcName = ""; my $params = "";
 	($contactFunc =~ /^([^(]+)\((.*)\)$/);
 	$funcName = $1;
	$params = $2;
	($fType,$directive,$addExclusions) = returnFunction($funcName); ## Obtain Gromacs function type
	if($directive ne "pairs" && $directive ne "bonds"){smog_quit ("$funcName is a contact type function and should only go into pairs or bonds directives");}
 	@paramArr = split(",",$params); ## Parse all parameters
 	foreach $params(@paramArr){$params =~ s/^\s+|\s+$//g;}
	return ($fType,$funcName,$directive,$addExclusions,@paramArr);
}



##########################
## CALCULATE EXCLUSIONS ##
##########################


sub calculateAtomTypes
{
	my($uniqueHandle) = @_;
	my $formattedString = "";	
	
	## OBTAIN UNIQUE ATOM TYPES ##
	my $nbtype ="";
	my $c12;my $c6;my $ptype;my $charge;my $mass;
	
	foreach my $atoms(sort { $a <=> $b } keys %{$uniqueHandle})
	{
		$nbtype = $uniqueHandle->{$atoms}->[0];
  		if(!$uniqueHandle->{$atoms}->[0])
        	{
          		smog_quit("Atom $atoms has no nbType");
        	}
		my $tmptype;
		if(exists $interactions->{"nonbonds"}->{$nbtype}){
			$tmptype=$nbtype;
		}elsif(exists $interactions->{"nonbonds"}->{"*"}){
			$tmptype="*";
		}else{
			smog_quit("No matching nb parameters found for nbtype $nbtype");
		}
		if(exists $presentatomtypes{$nbtype}){next;}
		$c6 = $interactions->{"nonbonds"}->{$tmptype}->{"c6"};
		$c12 = $interactions->{"nonbonds"}->{$tmptype}->{"c12"};
		$ptype = $interactions->{"nonbonds"}->{$tmptype}->{"ptype"};
		$mass = $interactions->{"nonbonds"}->{$tmptype}->{"mass"};
		$charge = $interactions->{"nonbonds"}->{$tmptype}->{"charge"};
		
		$formattedString = sprintf(" %-4s %8.4f %10.6f  %1s     %-13.5e %-13.5e",$nbtype,$mass,$charge,$ptype,$c6,$c12);
		addToTop("atomtypes",$formattedString."\n");
		$presentatomtypes{$nbtype}=1;
	}
}

sub readAtoms
{
	my($inputPDB) = @_;
	my %reflist;
	open(PDB,$inputPDB);
	my $line = "";
	my $atomName;my $atomNum; my $resName; my $resNum;
	my $charge = 0; my $mass = 1; my $atomType="none";
	my $counter=0; my $resCounter=1;my $resNumCurr="null";
	my $endreached=0;
	my $totalcharge=0;
	my $systemcharge=0;
	my $chainindex=1;
	my $linenumber=0;
	my $atomindex=0;
	my $lastTER=0;
	while($line = <PDB>)
	{
		$linenumber++;
		if($line =~ m/^TER|^END/) {

			my $TCr=round($totalcharge);
			if(abs($totalcharge-$TCr) > 0.001){
				smog_quit("Non-integer charge ($totalcharge) for chain $chainindex. This typically means something is wrong with the .bif file.");
			}
			print "Charge of chain $chainindex: $TCr\n";
			$systemcharge+=$totalcharge;
			$totalcharge=0;
			$chainindex++;
			$resCounter++;
			$lastTER=1;
		}
		if($line =~ m/^END/) {$endreached=1;last;}
		if($line =~ m/^ATOM/ || $line =~ m/^HETATM/)
		{
			$atomindex++;
			$reflist{$atomindex}=$linenumber;
			$atomName = substr($line, 12, 4);
			$atomName =~ s/^\s+|\s+$//g;
			#$atomNum = substr($line,6,5);
			
			$resName = substr($line,17,4);
			$resName =~ s/^\s+|\s+$//g;
			$resNum = substr($line,22,4);
			$resNum =~ s/^\s+|\s+$//g;
			if($resNumCurr eq "null"){
				$resNumCurr=$resNum;
			}
   			if($resNum ne $resNumCurr)
			{
				$resNumCurr=$resNum;
				if($lastTER ==0){
					$resCounter++;
				}
			}
			if(!$residues{$resName}->{"atoms"}->{$atomName}){next;}
			$counter++;$atomNum=$counter;
			$atomType = $residues{$resName}->{"atoms"}->{$atomName}->{"nbType"};
			addToTop("atoms",sprintf("%6d %10s %6d %6s %6s %6d", $atomNum, $atomType, $resCounter, $resName, $atomName, $atomNum));
			if(defined $residues{$resName}->{"atoms"}->{$atomName}->{"charge"}){
				#if charge is defined for an atom in a  specific residue, then write it
				addToTop("atoms",sprintf(" %9.6f", $residues{$resName}->{"atoms"}->{$atomName}->{"charge"}));
				# this residue has a charge on that atom, add that value to the total
				$totalcharge += $residues{$resName}->{"atoms"}->{$atomName}->{"charge"};
			}elsif(defined $interactions->{"nonbonds"}->{$atomType}->{"charge"}){
				# since there is not residue-specific charge assigned, use the atomtype value.
				$totalcharge += $interactions->{"nonbonds"}->{$atomType}->{"charge"};
			}
			addToTop("atoms",sprintf("\n"));
			$lastTER=0;
		}
	}

	if(abs($systemcharge-round($systemcharge)) > 0.001){
		smog_quit("Non-integer system charge ($systemcharge). This typically means something is wrong with the .bif file.");
	}else{
		printf("\nTotal charge of system: %8.3f\n\n",$systemcharge);
	}
	unless($endreached){smog_quit("PDB format error. END must appear at the end of the ATOM lines.")};
	return(%reflist);
}

##
# Convert PDB to GRO
# Store chain info to ndx file
sub convertPDBToGroNdx
{
	my ($inputPDB,$outputGRO,$outputNDX) = @_;
	my $counter = 0 ;	
	my $line = "";
	my $resName="";
	my $resNum="";
	my $atomName="";
	my $atomNum="";
 	my $x="";my $y="";my $z="";
 	my $output = "";
 	my $chain = "";
 	my $chainCounter = 1;
 	my %chainHash;
	my $resNumCurr=1;my $resCounter=1;
	my $boundflag=0;
	my $lastTER=0;
	my ($xmin, $xmax, $ymin,$ymax,$zmin,$zmax);
 	open(PDB,"$inputPDB") or smog_quit("can not open $inputPDB"); ## INPUT PDB
	if(-e "meta.Gro"){
		smog_quit("meta.Gro is a reserved file name.  It appears to already exist.  Please move and try again\n");
	}
	open(GRO,">meta.Gro") or smog_quit("can not open meta.Gro for writing");
	while($line=<PDB>)
	{
		
	 if($line =~ m/^END/) {last;}
  	 if($line =~ m/^TER/) {
		$chainCounter++;
		$resCounter++;
		$lastTER=1;
		next;
	}
         if($line =~ m/^ATOM|^HETATM/)
         {
		$atomName = substr($line, 12, 4);
		$atomName =~ s/^\s+|\s+$//g;
		$resName = substr($line,17,4);
		$resName =~ s/^\s+|\s+$//g;
        if(!exists $residues{$resName}->{"atoms"}->{$atomName})
		{next;}
		
		$x = substr($line, 30, 8);$x*=0.10;
		$y = substr($line, 38, 8);$y*=0.10;
		$z = substr($line, 46, 8);$z*=0.10;
		
		if($boundflag == 0){
			$xmin=$x;
			$xmax=$x;
			$ymin=$y;
			$ymax=$y;
			$zmin=$z;
			$zmax=$z;
			$boundflag=1;
		}else{
			if($x > $xmax){$xmax=$x;}
			if($x < $xmin){$xmin=$x;}
			if($y > $ymax){$ymax=$y;}
			if($y < $ymin){$ymin=$y;}
			if($z > $zmax){$zmax=$z;}
			if($z < $zmin){$zmin=$z;}
		}
	
  		$chain = $chainCounter;
		$counter++;$atomNum=$counter;
		$resNum = substr($line,22,4);
		$resNum =~ s/^\s+|\s+$//g;
		if($atomNum == 1){$resNumCurr=$resNum;}
		if($resNum ne $resNumCurr)
			{
				$resNumCurr=$resNum;
				if($lastTER==0){
					$resCounter++;
				}
			}

  		## Save atom index to chain ##
  		push(@{$chainHash{$chain}},$atomNum);
		if($atomNum >= 100000){$atomNum = $atomNum%100000;}
	        if($resCounter >= 100000){$resCounter = $resCounter%100000;}
		$output = sprintf("%5d%-5s%5s%5d%8.3f%8.3f%8.3f\n",$resCounter,$resName,$atomName,$atomNum,$x,$y,$z);
		print GRO $output;
		$lastTER=0;
		
	 }
	}

## default box size if 1nm larger than system size in each direction
	my $xrange=($xmax-$xmin)+2.0;
	my $yrange=($ymax-$ymin)+2.0;
	my $zrange=($zmax-$zmin)+2.0;

 ## ADJUST GRO FILE ##
	close(PDB);
	close(GRO);
        open(GROIN,"meta.Gro") or smog_quit("can not open meta.Gro for reading");
	open(GRO,">$outputGRO") or smog_quit("can not open $outputGRO for writing");
	print GRO "Gro file for a structure based model, generated with SMOG Version $VERSION\n";
	print GRO $counter,"\n";
	while(<GROIN>) { print GRO $_;}
	print GRO "$xrange $yrange $zrange\n";
	close(GRO); close(GROIN);
	unlink("meta.Gro");
	
 ## CREATE NDX FILE ##
	open(NDX,">$outputNDX");
	
	foreach my $chain (sort {$a <=> $b} keys %chainHash) 
	{
	       print NDX "[ $chain ]\n";
	       print NDX join("\n",@{$chainHash{$chain}});
	       print NDX "\n";
	}
	close(NDX);
}

sub validateTemplate
{
	my ($file,$type) = @_;
	my $validator = XML::Validator::Schema->new(file => "$ENV{SMOG_PATH}/share/schemas/$type.xsd");
	my $parser = XML::SAX::ParserFactory->parser(Handler => $validator);
	eval { $parser->parse_uri($file) };
 smog_quit("Failed at validating $file: $@ \nThis is due to an XML formatting issue.  The most common issue is that an element is missing a tagline. For example, something like this may appear in your file,
  <child>
    <subchild>.....
  </child>

whereas the following would be appropriate:
  <child>
    <subchild>.....

    </subchild>
  </child>") if $@;

}

sub parseInputFolder
{
	my ($folderName) = @_;
	$folderName = $1 if($folderName=~/(.*)\/$/);
	opendir(my $folder,$folderName);
	my $bif;my $sif;my $b;my $nb;my $extras;
	my $bifexists=0;
	my $sifexists=0;
	my $nbexists=0;
	my $bexists=0;
	while(my $file = readdir($folder)){
		if($file =~ m/\.bif$/){
			$bifexists++;
			$bif = $file;$bif = "$folderName/$bif";
			print "Found .bif file $bif\n";
			print "Validating XML format of $bif\n";
			validateTemplate($bif,"bif");next;}
		if($file =~ m/\.sif$/){
			$sifexists++;
			$sif = $file;$sif = "$folderName/$sif";
			print "Found .sif file $sif\n";
			print "Validating XML format of $sif\n";
			validateTemplate($sif,"sif");next;}
		if($file =~ m/\.b$/){
			$bexists++;
			$b = $file;$b = "$folderName/$b";
			print "Found .b file $b\n";
			print "Validating XML format of $b\n";
			validateTemplate($b,"b");next;}
		if($file =~ m/\.nb$/){
			$nbexists++;
			$nb = $file;$nb = "$folderName/$nb";
			print "Found .nb file $nb\n";
			print "Validating XML format of $nb\n";
			validateTemplate($nb,"nb");next;}
		if($file =~ m/^extras$/) {
			$extras = "$folderName/extras";
			print "Found extras file $extras\n";
			checkExtras($extras);
			next;}
	}
	$bifForSCM = $bif;

	if($bifexists >1){
		smog_quit ("Found multiple .bif files in directory $folderName");
	}elsif($bifexists ==0){
		smog_quit (" .bif file not found in directory $folderName");
	}
	if($sifexists >1){
		smog_quit ("Found multiple .sif files in directory $folderName");
	}elsif($sifexists ==0){
		smog_quit (" .sif file not found in directory $folderName");
	}
	if($bexists >1){
		smog_quit ("Found multiple .b files in directory $folderName");
	}elsif($bexists ==0){
		smog_quit (" .b file not found in directory $folderName");
	}
	if($nbexists >1){
		smog_quit ("Found multiple .nb files in directory $folderName");
	}elsif($nbexists ==0){
		smog_quit (" .nb file not found in directory $folderName");
	}
	
	setInputFileName($bif,$sif,$b,$nb);
	
}


sub header
{
	my $header="******* ******* ******* ******* ******* SMOG v$VERSION ******* ******* ******* ******* *******";
	my $headw=length($header);
	printdashed($headw);
	print "\n$header\n";

	my $tmpstring = <<"EOT";

Thank you for using the Structure-based Model (SMOG) software

This package is the product of contributions from a number of people, including:
Jeffrey Noel, Mariana Levi, Mohit Raghunathan, Joyce Yang           
Prasad Bandarkar, Udayan Mohanty, Ailun Wang        
Ryan Hayes, Jose Onuchic & Paul Whitford         

Copyright (c) 2015, The SMOG development team at
Rice University and Northeastern University

SMOG v$VERSION & Shadow are available at http://smog-server.org

You can direct questions to info\@smog-server.org, or the smog-users forum, 
which can be found at https://mailman.rice.edu/mailman/listinfo/smog-users

EOT

	printcenter($headw,$tmpstring);
	printdashed($headw);

}
sub usage
{
  print <<EOT;

usage: smog2 .. options ..

   Options
	-i [molecule.pdb]	: input PDB to generate Hamiltonian
	-AA			: use default All-atom model
	-AAgaussian		: use default All-atom model with gaussian contacts
	-CA			: use default Calpha protein model
	-CAgaussian		: use default Calpha protein model with gaussian contacts
	-t [templateFolder]	: folder containing templates of molecular and interaction definitions. Required when defaults are not used.
	-tCG [templateFolder]	: folder containing templates Coarse Graining. Indicates that the program should coarse grain.
	-g [smog.gro]		: output .gro file name
	-o [smog.top]		: output .top file name
	-s [smog.contacts]	: output .contacts file name
	-n [smog.ndx]		: output .ndx file name
	-c [contacts.txt]	: input contact map file
	-c_global 		: Use global numbering for input contact map (atoms start with 1)
	-dname [smog]		: default name to use for all output files
	-backup [yes]		: back up any pre-existing output files
	-warn [0]		: convert the first N fatal errors to warnings.  
					Convert all errors if N=-1 (Caution: Consult manual 
					before using this option)
	-limitbondlength	: if a bond length is outside of the allowable range, set it to limiting value
	-limitcontactlength	: if a contact length is too short, set it to the minimal value
	-ignH			: ignore any atoms with name starting with 'H' in the internal contact algorithm
	-rescaleCD [1.0]	: override total energy normalization and rescale all contacts/dihedrals by a factor
	-help 			: show options 
EOT
  if ( @_ ){
   smog_quit("Command-line argument \"@_\" not recognized.");
  }else{
   exit(0);
  }
}

sub setContactParams
{
	my $method = $contactSettings->{"method"};
	my $params = "";
	my $proteinDelta = 3;
	if(exists $contactSettings->{"proteinDelta"}) { $proteinDelta = $contactSettings->{"proteinDelta"}}
	if($method =~ m/shadow/)
	{
		my $radius = $contactSettings->{"shadowRadius"};
		my $radiusBonded = $contactSettings->{"shadowRadiusBonded"};
		my $dist = $contactSettings->{"contactDistance"};
		$params="-m shadow -c $dist -s $radius -br $radiusBonded -bif $bifForSCM -pd $proteinDelta --smog2output --showProgress";
	}
	elsif($method =~ m/cutoff/) 
	{
		my $dist = $contactSettings->{"contactDistance"};
		my $radius = 0.0;
		my $radiusBonded = 0.0;
		$params="-m shadow -c $dist -s $radius -br $radiusBonded -bif $bifForSCM -pd $proteinDelta --smog2output --showProgress";
	}
	else {smog_quit ("Contact map method $method is not supported.");}
	if($ignoreHydrogen == 1) { $params = $params." --ignoreH "; }
	return $params;
}


sub printCitation
{
	my $citationFile = "";
	## CHECK FOR .citation meta file ##
	if($coarseFolder && -e "$coarseFolder/.citation")
	{
		open(CITE,"$coarseFolder/.citation");
		$citationFile = join("",<CITE>);
		close(CITE);
	}
	elsif(-e "$inputFolder/.citation")
	{
		open(CITE,"$inputFolder/.citation");
		$citationFile = join("",<CITE>);
		close(CITE);
	}
	else
	{
		$citationFile = "";
	}
       

print <<EOT;

########################################################################################

              We kindly ask that you cite the appropriate primary references
             when using SMOG models. See http://www.smog-server.org/refs.html

--Software-- 
Noel JK, Levi M, Raghunathan M, Lammert H, Hayes R, Onuchic JN, and Whitford PC. (2016)
SMOG V2, A Versatile Software Package for Generating Structure-Based Models.
PLoS Comput Biol 12(3): e1004794. doi:10.1371/journal.pcbi.1004794

$citationFile
########################################################################################

EOT

}

##
## MEMORY MANAGEMENT ROUTINES
##

sub freeMemoryForShadow
{
	undef %resPDL;undef %bondPDL;
	undef %AngleData;undef %DihedralData;
	undef %BondData;undef $contactPDL;undef %foundBtype; undef %foundAtype, undef %foundDtype;
}


sub parseTemplatesAndPDB
{
	my ($inputFolder,$inputPDB,$allowCG) = @_;
    
    	## TEST IF SMOG PATH EXISTS ##
    	if(!$ENV{"SMOG_PATH"}){smog_quit("SMOG_PATH environment variable not set");}
	$| = 1;
	## OPEN .top handle ## don't do this here since we buffered the output now
	#open($OUTPUT, ">$topFile"); 
	parseInputFolder($inputFolder); ## PARSE FOLDER --> FILE

	#####################
    	## PARSE TEMPLATES ##
    	#####################
	initializeDirectives($inputFolder,$inputPDB);
	## parse .sif File ##
	parseSif();
	## parse .nb file  ##
	parseNonBonds();
	## parse .b file   ##
	parseBonds();
	## parse .bif File ##
	parseBif();
	    	print "\nDone parsing templates.\n";

    	print "\nChecking template definitions for consistency.\n";
	my $checkmessage=checkenergygroups();
	$checkmessage.=checkNONBONDnames();
	$checkmessage.=checkBONDnames();
	$checkmessage.=checkPAIRnames();
	$checkmessage.=checkREScharges();
	if($checkmessage ne ""){
		smog_quit("Cross-comparison of templates failed. See messages below:\n\n$checkmessage");
	}

	print "\nPre-processing templates.\n";
	## Find Bonds ##
	createBondFunctionals();
	## Find Angles ##
	createDihedralAngleFunctionals();
	###############
    	## PARSE PDB ##
    	###############
	print "\nReading $inputPDB\n\n";
	checkPDB($inputPDB,$allowCG);
	parsePDBATOMS($inputPDB,$allowCG);
	catPDL();
}

sub printBondedTopOutput {


	my ($inputPDB,$groFile,$ndxFile) = @_;
        if($countDihedrals){
	 print "Counting dihedrals\n";
	 getSetDiheCounts(\%DihedralData,\%bondPDL);
        }else{
         print "Will not count/rescale dihedrals with common middle bonds.";
        }
	## SET DIHEDRAL RATIOS ##
	print "Setting energetic ratios\n";
	setRatios(\%DihedralData,\%bondPDL,$totalAtoms,\%allAtoms,$rescaleCD);
	print "Processing atoms\n";
	calculateAtomTypes(\%allAtoms);
 	# adding extras at this point is a bit out of place.  but, it is important, in order to verify that all bonds have bondtypes, etc.
	addExtras();
	my %atomIndex2Line=readAtoms($inputPDB);

	## CALCULATE BONDS/CONNECTED BONDS ##
	print "Checking and saving bonds\n";
	printOrderedBonds(\%bondFunctionals,\%resPDL,\%BondData,\%bondPDL,\%atomIndex2Line,\%allAtoms);

	## CALCULATE ANGLES ##
	print "Checking and saving angles\n";
	printOrderedAngles(\%AngleData,\%bondPDL,\%atomIndex2Line,\%allAtoms);

	## CALCULATE DIHEDRALS ##
	print "Checking and saving dihedrals\n";
	printOrderedDihedrals(\%DihedralData,\%bondPDL,\%allAtoms);

	## CREATE GRO FILE ##
	convertPDBToGroNdx($inputPDB,$groFile,$ndxFile);
	## print intermediate top for SCM.jar to read ##
}

sub generateContactMap {
	my ($groFile,$ndxFile,$shadowFile,$topFile) = @_;
	## CALL SHADOW/PARSE CONTACTS ##
	print "Starting contact calculations ...\n  ";
	my $SCMparams = setContactParams();
    	my $memoryMax = "";
	my $absAtomCount = keys(%allAtoms);
		#AKE lattice with 6e5 atoms needs 70 MB. Use 80MB for safety...
		my $megabytesNeeded = int($absAtomCount / 60000 * 80);
		if( $megabytesNeeded > 100 ) #default java heapsize is 1/4 physical memory. Don't think anyone will have <400MB these days 
    	{
		print "JAVA HEAP SIZE INCREASED to $megabytesNeeded Mb\n";
		$memoryMax = "-Xmx$megabytesNeeded"."m";
    	} 
	
	## Delete Preexisting contact file ##
	if(-e $shadowFile){unlink($shadowFile);}
	
	## Free Memory for Shadow ##
	freeMemoryForShadow();
	
	if((!exists $ENV{SMOG_PATH}) || !(-e "$ENV{SMOG_PATH}/tools/SCM.jar")){smog_quit ("Can't find Shadow executable. Make sure SMOG_PATH is set correctly.")}
	print "Calling $ENV{SMOG_PATH}/tools/SCM.jar \n";
	system("java $memoryMax -jar $ENV{SMOG_PATH}/tools/SCM.jar -g $groFile -t $topFile -o $shadowFile -ch $ndxFile $SCMparams ");
}

sub appendContacts {
	my($fileName,$fileName2,$userProvidedMap,$absolutecontactindex) = @_;
	#Parse the contact map, either the generated one or the user provided one
	$numContacts = parseCONTACT($shadowFile,$ContactFile,$userProvidedMap,$CGenabled,$absolutecontactindex);
	if($numContacts == 0){smog_quit ("There are 0 contacts.  See earlier messages for possible errors");}
	my $absAtomCount = keys(%allAtoms);
	print "NOTE: Total number of atoms included in normalization is $totalAtoms, and $absAtomCount atoms are in the system.\n";
	print "Completing final details...\n";
	## CALCULATE PAIRS and EXCLUSIONS ##
 	calculateContacts($contactPDL,\%resPDL,\%allAtoms,$numContacts,$totalAtoms);
	#print defaults
	my $nbfunc=1;my $combrule = 1; my $genpairs = "no";
	if(exists $interactions->{"gmx-combination-rule"}) { 
		$combrule = $interactions->{"gmx-combination-rule"};
	}
	if(exists $interactions->{"nbfunc"}) { 
		$nbfunc = $interactions->{"nbfunc"};
	}
	if(exists $interactions->{"gen-pairs"} && $interactions->{"gen-pairs"} == 1) { $genpairs = "yes"; }
	addToTop("defaults", "  $nbfunc      $combrule         $genpairs\n");
}

##################
## PARSE INPUTS ##
##################

my $DNAME="smog";
my $backup="yes";

header();
print "\nSMOG 2 called with the command:\n";
print "smog2 ";
foreach my $filen(@ARGV){
	print "$filen ";
}	
print "\n";

## parse command line options ##
# -o output top file name, default is smog.top
usage() if (@ARGV < 1 || !GetOptions('help|?' => \$help, 'o=s' => \$topFile, 't=s' => \$inputFolder, 'i=s' => \$inputPDB, 'g=s' => \$groFile,
	'c=s' => \$ContactFile, 'c_global' => \$absolutecontactindex, 's=s' => \$shadowFile, 'n=s' => \$ndxFile, 'ignH' => \$ignoreHydrogen,
	 'tCG=s' => \$coarseFolder, 'CA'=> \$CAdefault, 'AA' => \$AAdefault, 'CAgaussian'=> \$CAGdefault, 'AAgaussian' => \$AAGdefault, 'dname=s' => \$DNAME, 'warn=i' => \$maxwarn, 
         'backup=s' => \$backup, 'limitbondlength' => \$setBondtoLimit, 'limitcontactlength' => \$setContacttoLimit, 
         'rescaleCD=s' => \$rescaleCD, '<>' => \&usage, 'v' => \$printversion)
          or defined $help 
          or !defined $inputPDB 
          or (!defined $inputFolder  && !defined $coarseFolder));

if($printversion){
	print "Version $VERSION\n";
	exit;
}

unless ($rescaleCD =~ /^-?(?:\d+(?:\.\d*)?|\.\d+)$/){ ;
	smog_quit("$rescaleCD is not a valid value for -rescaleCD.  Must be an integer, or decimal.");
}

warninfo();

if($coarseFolder ne "" and $inputFolder eq ""){
	smog_quit("When using a CG model with -tCG, you must also specify the model to be used when calculating the contact map by invoking the option -t. Check -help for usage information. ");
}

my $numdefaults=$CAdefault+$AAdefault+$AAGdefault+$CAGdefault;
if($inputFolder eq "" && $numdefaults==0){
	smog_quit("No model specified. You must use either -t, -AA, or -CA. Try -help for usage information.");
}

if($coarseFolder ne "") { $CGenabled = 1; }

if($backup ne "yes" and $backup ne "no"){
	smog_quit("Can not understand -backup flag. Usage -bu [yes/no]");
}elsif($backup eq "no"){
	print "-backup no issued.  Will overwrite any existing output files.\n";
}

if($numdefaults > 1){
	smog_quit('Can not select more than one default model at a time.');
}
if($CAdefault == 1 and defined $ContactFile){
	smog_quit('Can not use -c and -CA options at the same time.');
}
if(defined $ContactFile and $CGenabled == 1){
	smog_quit('Can not use -tCG and -c options at the same time.');
}
if($CAdefault == 1 and $CGenabled == 1){
	smog_quit('Can not use -tCG and -CA options at the same time.');
}
if($CAGdefault == 1 and $CGenabled == 1){
	smog_quit('Can not use -tCG and -CAgaussian options at the same time.');
}
if($CAdefault == 1 and $inputFolder ne ""){
	smog_quit('Can not use -CA and -t options at the same time.');
}
if($CAGdefault == 1 and $inputFolder ne ""){
	smog_quit('Can not use -CAgaussian and -t options at the same time.');
}

if($AAdefault == 1 and $inputFolder ne ""){
	smog_quit('Can not use -AA and -t options at the same time.');
}
if($AAGdefault == 1 and $inputFolder ne ""){
	smog_quit('Can not use -AAgaussian and -t options at the same time.');
}
if($numdefaults and $coarseFolder ne ""){
	smog_quit('Can not use a default model with -tCG.');
}


if($CAdefault == 1){
	print "\n -CA given. Will use the default Calpha SMOG model provided with the distribution.\n";
	my $SMOGDIR=$ENV{'SMOG_PATH'};
	$inputFolder="$SMOGDIR/SBM_AA";
	$coarseFolder="$SMOGDIR/SBM_calpha";
	print "Will try to use templates found in \n$inputFolder\n and\n$coarseFolder\n\n";
	if(! -d $inputFolder){
		smog_quit("$inputFolder is not a valid template directory.");
	}
	if(! -d $coarseFolder){
		smog_quit("$coarseFolder is not a valid template directory.");
	}
	$CGenabled=1;
}
if($AAdefault == 1){
	print "\n-AA given. Will use the default All-Atom SMOG model provided with the distribution.\n";
	my $SMOGDIR=$ENV{'SMOG_PATH'};
	$inputFolder="$SMOGDIR/SBM_AA";
	print "Will try to use templates found in \n$inputFolder\n\n";
	if(! -d $inputFolder){
		smog_quit("$inputFolder is not a valid template directory.");
	}
}

if($CAGdefault == 1){
	print "\n -CAgaussian given. Will use the default Calpha SMOG model with gaussian contacts, as provided with the distribution.\n";
	my $SMOGDIR=$ENV{'SMOG_PATH'};
	$inputFolder="$SMOGDIR/SBM_AA";
	$coarseFolder="$SMOGDIR/SBM_calpha+gaussian";
	print "Will try to use templates found in \n$inputFolder\n and\n$coarseFolder\n\n";
	if(! -d $inputFolder){
		smog_quit("$inputFolder is not a valid template directory.");
	}
	if(! -d $coarseFolder){
		smog_quit("$coarseFolder is not a valid template directory.");
	}
	$CGenabled=1;
}
if($AAGdefault == 1){
	print "\n-AAgaussian given. Will use the default All-Atom SMOG model with gaussian contacts, as provided with the distribution.\n";
	my $SMOGDIR=$ENV{'SMOG_PATH'};
	$inputFolder="$SMOGDIR/SBM_AA+gaussian";
	print "Will try to use templates found in \n$inputFolder\n\n";
	if(! -d $inputFolder){
		smog_quit("$inputFolder is not a valid template directory.");
	}
}


# if a contact file is provided, then don't calculate contacts
if(defined $ContactFile){
	$userProvidedMap=1;
}

## Ensure we only write out files with gromacs-compatible suffices
my $maxbu=10;
if($topFile eq ""){$topFile=$DNAME};
if($groFile eq ""){$groFile=$DNAME};
if($shadowFile eq ""){$shadowFile=$DNAME};
if($ndxFile eq ""){$ndxFile=$DNAME};

$topFile=checksuffix($topFile,".top");
$groFile=checksuffix($groFile,".gro");
$shadowFile=checksuffix($shadowFile,".contacts");
$ndxFile=checksuffix($ndxFile,".ndx");


## check if files exist
# things we don't want to overwrite
if($backup eq "yes"){
	foreach my $filen($topFile, $groFile, $shadowFile, $ndxFile){
		my ($ext) = $filen =~ /(\.[^.]+)$/;
		if($filen ne "" && -e $filen){
			for(my $bu=1;$bu<=$maxbu;$bu++){
				my $buname="$filen.bu$bu";
				if( ! -e $buname){	
				print "$filen already exists.  Backing up to $buname\n";
				system("mv $filen $buname");
				last;
				}
				if($bu == $maxbu){
			 	smog_quit ("Already backed up $maxbu copies of $filen."); 
				}
			}
		}
	}
}

# files we will read
foreach my $filen($inputPDB,$ContactFile){
	if(defined $filen  && ! -f $filen){
		smog_quit("Can't find file $filen !! ");
	}
}

# directories we will access
foreach my $filen($inputFolder,$coarseFolder){
	if($filen ne "" && ! -d $filen){
		smog_quit ("Can't find directory $filen !! ");
	}
}


####################
## PROGRAM DRIVER ##
####################

if($CGenabled == 0) {
	print "\n*****************************************************\n";
	print   "******* ALL-ATOM SMOG MODEL WILL BE GENERATED *******";
	print "\n*****************************************************\n";
} else {
	print "\n*****************************************************\n";
	print   "**** COARSE-GRAINED SMOG MODEL WILL BE GENERATED ****";
	print "\n*****************************************************\n";
}
my $allowCG = 0;
print "Parsing templates files...\n";
parseTemplatesAndPDB($inputFolder,$inputPDB,$allowCG);
if($CGenabled == 0) {
	printBondedTopOutput($inputPDB,$groFile,$ndxFile);
} elsif ($CGenabled == 1 && $userProvidedMap == 0) { #CG but we still need full .top to make a map
	print "Creating topology for contact calculation.....\n";
	printBondedTopOutput($inputPDB,$groFile,$ndxFile);
}
if($userProvidedMap == 0) { #use SCM.jar if user doesn't provide a map
	printTop($topFile);
	generateContactMap($groFile,$ndxFile,$shadowFile,$topFile);
}
if($CGenabled == 1) { #Coarse graining, do everything over with new templates
    	clearBifMemory();clearPDBMemory();
	undef %presentatomtypes;
	$allowCG = 1;
	print "\nParsing templates for coarse graining... ";
	$inputFolder = $coarseFolder;
	parseTemplatesAndPDB($coarseFolder,$inputPDB,$allowCG);
	printBondedTopOutput($inputPDB,$groFile,$ndxFile);
}

appendContacts($shadowFile,$ContactFile,$userProvidedMap,$absolutecontactindex);


printTop($topFile);
print "\nYour Structure-based Model is ready!\n\nFiles generated: \n\t$topFile\n\t$groFile\n\t$ndxFile\n";
	if(!$userProvidedMap) { print "\t$shadowFile\n"; }
	if($CGenabled && !$userProvidedMap) { print "\t$shadowFile.CG\n"; }
	printCitation();

warnsummary();
##exit(0);

## END ##
