#########################################################################################
# smogv2 contains the main routines
#
#                          Structure-based Model (SMOG) software
#    This package is the product of contributions from a number of people, including:
#                      Jeffrey Noel, Mariana Levi, Mohit Raghunathan,
#                 Heiko Lammert, Ryan Hayes, Jose Onuchic & Paul Whitford
#
#                     Copyright (c) 2015, The SMOG development team at
#                        Rice University and Northeastern University
#
#              SMOG v2 & Shadow are available at http://smog-server.org
#
#                        Direct questions to: info@smog-server.org
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#########################################################################################

#####################
## COMPILE HEADERS ##
#####################
use strict;
use warnings;
####################
## MODULE HEADERS ##
####################
&checkForModules;
use XML::Simple;
use templateParser;
use pdbParser;
use PDL;
use mathFunctions;
use setRatios;
use Getopt::Long;
use XML::SAX::ParserFactory;
use XML::Validator::Schema; 
use IPC::Open3;

######################
## GLOBAL VARIABLES ##
######################
my $VERSION="2.0";
my $angToNano = 0.1;
my @diheArr;
my $OUTPUT;
my $help;
my $inputPDB="molecule.pdb"; 
my $inputFolder=""; my $bifForSCM;
my $userProvidedMap=0;
my $topFile = "";
my $groFile = "";
my $ContactFile = "";
my $shadowFile = "";
my $ndxFile = "";
my $mapOpt = "shadow";my $contactOpt = "6 1";
my $numContacts = 0;
my $coarseFolder = ""; ## Coarse Grain Folder ##
my $AAdefault = 0; ## Duplicate ##
my $CAdefault = 0; ## Duplicate ##
our $noexit=0;
our $CGenabled=0; ## enable coarse-graining
our $setBondtoLimit=0;
our $setContacttoLimit=0;
my $ignoreHydrogen=0; #if you don't want contact map generation to consider hydrogens
## this is the array that defines how function names are converted to gromacs function types
our %fTypes = (	'bond_harmonic' => '1',
		'bond_type6' => '6',
		'angle_harmonic' => '1',
		'angle_free' => '0',
		'dihedral_cosine'=>'1',
		'dihedral_harmonic' => '2',
		'dihedral_free' => '0',
		'contact_1'=>'1',
		'contact_2'=>'1',
		'contact_gaussian'=>'6'
		);
## this is the topfile buffer stuff
our %directives = ("defaults",1,"atomtypes",2,"moleculetype",3,"atoms",4,"bonds",5,"angles",6,"dihedrals",7,"pairs",8,"exclusions",9,"system",10,"molecules",11);
our @directivesList=("defaults","atomtypes","moleculetype","atoms","bonds","angles","dihedrals","pairs","exclusions","system","molecules");
our @topFileBuffer;
our @linesInDirectives;
our $inputArguments=join(' ',@ARGV);


sub checkForModules {
	my $checkPackage; my $sum=0;
	$checkPackage=`echo \$perl4smog | wc | awk '{print \$3}'`;
	if($checkPackage < 2) { print "Environment variable perl4smog not set, maybe you need to edit the configure.smog2 script and run it with \"source configure.smog2\"\n"; $sum++;}
	$checkPackage=`\$perl4smog -e "use XML::Simple" 2>&1 | wc -l | awk '{print \$1}'`;
	if($checkPackage > 0) { print "Perl module XML::Simple not installed!\n"; $sum++;}
	$checkPackage=`\$perl4smog -e "use XML::Validator::Schema" 2>&1 | wc -l | awk '{print \$1}'`;
	if($checkPackage > 0) { print "Perl module XML::Validator::Schema not installed!\n"; $sum++;}
	$checkPackage=`\$perl4smog -e "use Exporter" 2>&1 | wc -l | awk '{print \$1}'`;
	if($checkPackage > 0) { print "Perl module Exporter not installed!\n"; $sum++;}
	$checkPackage=`\$perl4smog -e "use String::Util" 2>&1 | wc -l | awk '{print \$1}'`;
	if($checkPackage > 0) { print "Perl module String::Util not installed!\n"; $sum++;}
	$checkPackage=`\$perl4smog -e "use PDL" 2>&1 | wc -l | awk '{print \$1}'`;
	if($checkPackage > 0) { print "Perl Data Language not installed!\n"; $sum++;}
	$checkPackage=`which java | wc -l | awk '{print \$1}'`;
	if($checkPackage < 1) { print "Java might not be installed. This package assumes Java 1.7 or greater is in the path as 'java'.\n"; $sum++;}
	if($sum > 0) { print "Need above packages before smog-check (and smog2) can run. Some hints may be in the SMOG2 manual.\n"; exit(1); }
}


####################
## OUTPUT TOPFILE ##
####################
sub printTop {
	my($topFile) = @_;
	open($OUTPUT, ">$topFile");
	my $i;
	my $j;
	my $directive;
	foreach $directive (@directivesList) { #order of list defines order in top
		foreach $i (0 .. scalar @{$topFileBuffer[$directives{$directive}]}-1) {
			foreach $j (0 .. scalar @{$topFileBuffer[$directives{$directive}][$i]}-1) {
				print $OUTPUT $topFileBuffer[$directives{$directive}][$i][$j];
			}
		}
	}
	close($OUTPUT);
}
# utility method to set all the initial directive comments
sub initializeDirectives {
	my($inputFolder,$inputPDB) = @_;
	for (keys %directives) { 
		$linesInDirectives[$directives{$_}]=0; 
		#need this because we are going to output a top without pairs but want it to not die when it is not initialized
		push @{$topFileBuffer[$directives{$_}][$linesInDirectives[$directives{$_}]++]}, ""; 
	}
	#add any comments to defaults since it is written first
	addToTop("defaults", "; Structure-based \"SMOG\" model for use with GROMACS, or NAMD\n");
	addToTop("defaults", "; Generated by the SMOG tool version $VERSION\n");
	addToTop("defaults", "; Called with PDB: $inputPDB\n");
	addToTop("defaults", "; Created using templates found in directory: $inputFolder\n");
	addToTop("defaults", "; Your input arguments were: $inputArguments\n");
	addToTop("defaults", "\n[ defaults ]\n");
	addToTop("defaults", "; nbfunc comb-rule gen-pairs\n");
	addToTop("bonds","\n[ bonds ]\n");
	addToTop("bonds",";ai     aj      func    r0(nm)  Kb\n");
	addToTop("angles","\n[ angles ]\n");
	addToTop("angles",";ai  aj   ak  func  th0(deg)   Ka\n");
  	addToTop("dihedrals","\n[ dihedrals ]\n");
  	addToTop("dihedrals",";ai  aj  ak  al  func  phi0(deg) kd mult\n");
	addToTop("pairs","\n[ pairs ]\n");
	addToTop("pairs","; ai aj type, A, B\n");
	addToTop("exclusions","\n[ exclusions ]\n");
	addToTop("exclusions","; ai	aj\n");
	addToTop("atomtypes","\n [ atomtypes ] \n");
	addToTop("atomtypes","; name mass   charge ptype c6            c12\n");
	addToTop("atoms","\n[ atoms ]\n");
	addToTop("atoms",";nr  type  resnr residue atom  cgnr\n");
	addToTop("moleculetype","\n[ moleculetype ]\n");
	addToTop("moleculetype","; name            nrexcl\n");
	addToTop("moleculetype","  Macromolecule   3\n");
	addToTop("system","\n[ system ]\n");
	addToTop("system","; name\n");
	addToTop("system","  Macromolecule\n");
	addToTop("molecules","\n[ molecules ]\n");
	addToTop("molecules","; name            #molec\n");
	addToTop("molecules","  Macromolecule   1\n");
}
#adds something to the topfile at the bottom of a directive
sub addToTop {
	my($directive,$stuff) = @_;
	push  @{$topFileBuffer[$directives{$directive}][$linesInDirectives[$directives{$directive}]++]}, $stuff;
}


#####################
## CALCULATE BONDS ##
#####################

##
# Combined bond calculation,sorting, and printing
sub printOrderedBonds
{

	my($bondFunctHandle1,$whichPDL1,$bondHandle2,$whichPDL2) = @_;
	my @bondCache; ## CACHE BONDS TO ORDER

	## Cache Bonds ##
	calculateBonds1($bondFunctHandle1,$whichPDL1,\@bondCache);
	calculateBonds2($bondHandle2,$whichPDL2,\@bondCache);

	## Sort bonds by i then j ## 
	@bondCache = sort {($a->{"i"} <=> $b->{"i"}) || ($a->{"j"} <=> $b->{"j"}) } @bondCache;

	## Print our sorted bonds ##
	foreach my $p(@bondCache)
	{
		addToTop("bonds",$p->{"v"});
	}
}


##
# calculate bond angle of a specific residue  PDL
sub calculateBondsHelper1
{
 my($bondHash,$inputPDL,$bondCache) = @_;
 my $bondArr = $bondHash->{"bonds"};
 my $bondFunc =$bondHash->{"functions"};
 my $bondIndex = 0;
 foreach my $bonds(@{$bondArr})
 {
	my ($atomOne,$atomTwo) = split("-",$bonds);
	my $outer = slice($inputPDL,"0:2,$atomOne,:")-slice($inputPDL,"0:2,$atomTwo,:");
	my @bondList = (sqrt(inner($outer,$outer))*$angToNano)->flat()->list();
	my @indexList1 = slice($inputPDL,"3:3,$atomOne,:")->flat()->list();
	my @indexList2 = slice($inputPDL,"3:3,$atomTwo,:")->flat()->list();
	for(my $i=0;$i<scalar(@bondList);$i++)
	{
		#print $OUTPUT bondOutput($bondFunc->[$bondIndex],$indexList1[$i],$indexList2[$i],$bondList[$i]);} 
  push @{$bondCache}, {'i' => $indexList1[$i],'j' => $indexList2[$i], 'v' => bondOutput($bondFunc->[$bondIndex],$indexList1[$i],$indexList2[$i],$bondList[$i])};
 }
		$bondIndex++;

 }
}

##
# Setup the calculation of bond angles of all the residues,
#	then call calculateBondsHelper() with a specific residue
sub calculateBonds1
{
 my($bondFunctHandle,$whichPDL,$bondCache) = @_;
  foreach my $res(keys %{$bondFunctHandle})
 {
	if(!exists $whichPDL->{$res}){next;}
	calculateBondsHelper1($bondFunctHandle->{$res},$whichPDL->{$res},$bondCache);
 }
}


##
#Setup the calculate of bond angles of all combined residues,
#then call connCalculateBondsHelper() with a specific residue
sub calculateBonds2
{
 my($bondHandle,$whichPDL,$bondCache) = @_;
 foreach my $counter(keys %{$bondHandle})
 {
	calculateBondsHelper2($bondHandle->{$counter},$whichPDL->{$counter},$bondCache);

 }
}
##
#calculate bond angle of a specific combined residue PDL
sub calculateBondsHelper2
{
 my($bondInfo,$inputPDL,$bondCache) = @_;
 my $size = $bondInfo->dim(1);
 for(my $i=0;$i<$size;$i++)
 {
 my $atomOne = sclr(slice($bondInfo,"0:0,$i:$i"));
 my $atomTwo = sclr(slice($bondInfo,"1:1,$i:$i")); 
 my $func = sclr(slice($bondInfo,"2:2,$i:$i"));
 my $outer = slice($inputPDL,"0:2,$atomOne,:")-slice($inputPDL,"0:2,$atomTwo,:");
 my $output = sclr(sqrt(inner($outer,$outer))*$angToNano);
 $atomOne = sclr(slice($inputPDL,"3:3,$atomOne,:"));
 $atomTwo = sclr(slice($inputPDL,"3:3,$atomTwo,:"));
  #print $OUTPUT bondOutput(intToFunc("bonds",$func,""),$atomOne,$atomOne,$output);
 push @{$bondCache}, {'i' => $atomOne,'j' => $atomTwo, 'v' => bondOutput(intToFunc("bonds",$func,""),$atomOne, $atomTwo,$output)};
 }
}

##
# Convert internal bond function format to gromacs function format,
# internal format is f()+g()
sub bondOutput
{
 my($inputFunc,$i,$j,$values) = @_;
 if(!$inputFunc){smog_quit ("BONDOUTPUT::NO FUNCTION DEFINED");}
 ## Remove white spaces from string ##
 $inputFunc =~ s/^\s+|\s+$//g;
 ## If $input contains a + ##
 my @funcs = split(/\+/,$inputFunc); ## split combination of functions
 my $outputString="";
 my @paramArr;
 my $fType=""; my $formattedString;
	## Parse each part of the function ##
 foreach my $fun(@funcs)
 {
	my $paramFormat="";
	($fType,@paramArr) = bondFuncParser($fun);
     	## $paramArr[0] is bond length
	if($paramArr[0] =~ /\?/){$paramArr[0]=$values;} ## native option used
	 
	 ## Check bonds threshold ##
	 if($paramArr[0] < $interactionThreshold->{"bonds"}->{"shortBond"}
	 || $paramArr[0] > $interactionThreshold->{"bonds"}->{"longBond"})
	 {
	  my $DIST=int($paramArr[0]*100)/100.0;
	  if($setBondtoLimit){
	  print("\n\nNOTE: Distance of $DIST nm calculated for atom pair $i and $j. This is outside of bond threshold range.\n\n");
	   print "-limitbondlength is being used, will set length to ";
	   if($paramArr[0] < $interactionThreshold->{"bonds"}->{"shortBond"}){
	    $paramArr[0]=$interactionThreshold->{"bonds"}->{"shortBond"};
	    print "$paramArr[0] nm\n\n";
	   }elsif($paramArr[0] > $interactionThreshold->{"bonds"}->{"longBond"}){
	    $paramArr[0]=$interactionThreshold->{"bonds"}->{"longBond"};
	    print "$paramArr[0] nm\n\n";
           }
          }else{
	    smog_quit("Distance of $DIST nm calculated for atom pair $i and $j. This is outside of bond threshold range.");
	  }
	 }
	
 ## Format output <i j function p1 p2 ... pn>
 foreach(@paramArr){$paramFormat="$paramFormat %12.9e";}
	$formattedString = sprintf("%9d%9d%6d$paramFormat",$i,$j,$fType,@paramArr);
	$outputString = "$outputString$formattedString\n";
 }
 return $outputString;
 }

##
# Given a user defined function parse values
sub bondFuncParser
{
	my($bondFunc) = @_;
	my $fType;my @paramArr;my $directive;
	my $funcName = ""; my $params = "";
 ($bondFunc =~ m/(.*)\((.*)\)/);
	$funcName = $1;
	$params = $2;
	($fType,$directive) = returnFunction($funcName); ## Obtain Gromacs function type
	if($directive ne "bonds"){smog_quit ("$funcName is not a valid bonds function");}
 @paramArr = split(",",$params); ## Parse all parameters
 foreach $params(@paramArr){$params =~ s/^\s+|\s+$//g;}
	return ($fType,@paramArr);
}

######################
## CALCULATE ANGLES ##
######################

##
# Combined bond calculation,sorting, and printing
sub printOrderedAngles
{
	my($connAngleFunctionals,$connPDL) = @_;
	my @angleCache; ## CACHE BONDS TO ORDER


	## Cache Bonds ##
	connCalculateAngles($connAngleFunctionals,$connPDL,\@angleCache);

	## Sort angles by i,j then k ## 
	@angleCache = sort {($a->{"i"} <=> $b->{"i"}) || ($a->{"j"} <=> $b->{"j"}) || ($a->{"k"} <=> $b->{"k"})} @angleCache;

	## Print our sorted bonds ##
  	foreach my $p(@angleCache)
  	{
  		addToTop("angles",$p->{"v"});
	}
}

##
# calculate 3 angle value of a specific residue PDL
sub calculateAnglesHelper
{
 my($angleArr,$inputPDL) = @_;
 
 foreach my $angles(@{$angleArr})
 {
	my ($atom1,$atom2,$atom3) = split("-",$angles);
 my $left = norm(slice($inputPDL,"0:2,$atom1,:")-slice($inputPDL,"0:2,$atom2,:"));
	my $right = norm(slice($inputPDL,"0:2,$atom3,:")-slice($inputPDL,"0:2,$atom2,:"));
	my $acos = inner($left,$right);
 }
}

##
# Setup the calculation of 3 angle value of all the residues,
# then call calculateAnglesHelper() with a specific residue
sub calculateAngles
{
 my($angleFunctHandle,$whichPDL) = @_;
 foreach my $res(keys %{$angleFunctHandle})
 {
	calculateAnglesHelper($angleFunctHandle->{$res}->{"angles"},$whichPDL->{$res});
 }
}

##
# Setup the calculate of bond angles of all combined residues,
# then call connCalculateAnglesHelper() with a specific residue
sub connCalculateAngles
{
 my($angleFunctHandle,$whichPDL,$angleCache) = @_;
 
 foreach my $res(keys %{$angleFunctHandle})
 {
	connCalculateAnglesHelper($angleFunctHandle->{$res},$whichPDL->{$res},$angleCache);
 }
}

##
# calculate bond angle of a specific combined residue PDL
sub connCalculateAnglesHelper
{
 my($angleArr,$inputPDL,$angleCache) = @_;
 my $size = $angleArr->dim(1);
 
 for(my $i=0;$i<$size;$i++)
 {
	my ($atom1,$atom2,$atom3,$func) = $angleArr->slice(":,$i:$i")->list;
  	my $left = norm(slice($inputPDL,"0:2,$atom1,:")-slice($inputPDL,"0:2,$atom2,:"));
	my $right = norm(slice($inputPDL,"0:2,$atom3,:")-slice($inputPDL,"0:2,$atom2,:"));
	my $acos = mathFunctions::rad_to_deg(mathFunctions::acos(sclr(inner($left,$right))));
	
	my $atomi1 = sclr(slice($inputPDL,"3:3,$atom1,:"));
	my $atomi2 = sclr(slice($inputPDL,"3:3,$atom2,:"));
	my $atomi3 = sclr(slice($inputPDL,"3:3,$atom3,:"));
	if($atomi1 > $atomi3) { my $temp = $atomi1; $atomi1 = $atomi3; $atomi3 = $temp; }
  	my $val=angleOutput(intToFunc("angles",$func,""),$atomi1,$atomi2,$atomi3,$acos);
	if(!$val) {next;}
  	push @{$angleCache}, {'i' => $atomi1,'j' => $atomi2,'k' =>$atomi3, 'v' => 	angleOutput(intToFunc("angles",$func,""),$atomi1,$atomi2,$atomi3,$acos)};
 }
}

## 
# Convert internal angle function format to gromacs function format
sub angleOutput
{
 my($inputFunc,$i,$j,$k,$values) = @_;
	if(!$inputFunc){smog_quit ("ANGLEOUTPUT::NO FUNCTION DEFINED");}
 ## Remove white spaces from string ##
 $inputFunc =~ s/^\s+|\s+$//g;
 ## If $input contains a + ##
	my @funcs = split(/\+/,$inputFunc);
	my $outputString="";
	my $value="";my $kd="";
	my $fType="";my @paramArr;
	my $formattedString="";
	foreach my $fun(@funcs)
	{
	my $paramFormat="";
	($fType,@paramArr) = angleFuncParser($fun);
	if($fType != 0){
		if($paramArr[0] =~ /\?/){$paramArr[0]=$values;} ## non-native option used
	
		## Check angles threshold ##
	 	if($paramArr[0] < $interactionThreshold->{"angles"}->{"smallAngles"})
	 	 { 
	          my $THETA=int($paramArr[0]*100)/100.0;
	          print("\n\nWARNING: ANGLE between atoms $i $j $k smaller than smallAngles (see .sif): theta=$THETA degrees\n\n");}
	 	if($paramArr[0] > $interactionThreshold->{"angles"}->{"largeAngles"})
	 	 {
	          my $THETA=int($paramArr[0]*100)/100.0;
	          print("\n\nWARNING: ANGLE between atoms $i $j $k greater than largeAngles (see .sif): theta=$THETA degrees\n\n");}
	
 		## Format output <i j k function p1 p2 ... pn>
 		foreach(@paramArr){$paramFormat="$paramFormat %12.9e";}
			$formattedString = sprintf("%9d%9d%9d%6d$paramFormat",$i,$j,$k,$fType,@paramArr);
			$outputString = "$outputString$formattedString\n";
		}
	}
	if($fType != 0){
		return $outputString; 
	}
}

##
# Given a user defined angle function parse values
sub angleFuncParser
{
	my($angFunc) = @_;
	my $fType;my @paramArr;my $directive;
	my $funcName = ""; my $params = "";
 ($angFunc =~ m/(.*)\((.*)\)/);
	$funcName = $1;
	$params = $2;
	($fType,$directive) = returnFunction($funcName); ## Obtain Gromacs function type
	if($directive ne "angles"){smog_quit ("$funcName is not a valid angles function");}
 @paramArr = split(",",$params); ## Parse all parameters
 foreach $params(@paramArr){$params =~ s/^\s+|\s+$//g;}
	return ($fType,@paramArr);
}

#########################
## CALCULATE DIHEDRALS ##
#########################

##
# Combined dihedral calculation,sorting, and printing
sub printOrderedDihedrals
{
		my($connDiheFunctionals,$connPDL) = @_;
  my @diheCache; ## CACHE BONDS TO ORDER

  ## Cache Bonds ##
  connCalculateDihedrals($connDiheFunctionals,$connPDL,\@diheCache);

  ## Sort dihedrals by i, then j then k then l ## 
  @diheCache = sort {($a->{"i"} <=> $b->{"i"}) || ($a->{"j"} <=> $b->{"j"}) || ($a->{"k"} <=> $b->{"k"}) || ($a->{"l"} <=> $b->{"l"}) } @diheCache;
  
  ## Print our sorted bonds ##
  foreach my $p(@diheCache)
  {
  	addToTop("dihedrals",$p->{"v"});
  }
  addToTop("dihedrals","\n");
}

##
# Setup the calculate of bond angles of all combined residues,
# then call connCalculateBondsHelper() with a specific residue
sub connCalculateDihedrals
{
 my($diheFunctHandle,$whichPDL,$diheCache) = @_;
 foreach my $res(keys %{$diheFunctHandle})
 {
		connCalculateDihedralsHelper($diheFunctHandle->{$res},$whichPDL->{$res},$diheCache);
 }
}

sub connCalculateDihedralsHelper
{
	 my($diheArr,$inputPDL,$diheCache) = @_;
	 my $size = $diheArr->dim(1);
	 for(my $i=0;$i<$size;$i++)
	 {
			my @TMP=$diheArr->slice(":,$i:$i")->list;
			if(@TMP < 7){next;}
			my ($atom1,$atom2,$atom3,$atom4,$func,$cD,$eG) = $diheArr->slice(":,$i:$i")->list;
		
		   
	        	my $b1 = slice($inputPDL,"0:2,$atom2,:")-slice($inputPDL,"0:2,$atom1,:");
			my $b2 = slice($inputPDL,"0:2,$atom3,:")-slice($inputPDL,"0:2,$atom2,:");
			my $b3 = slice($inputPDL,"0:2,$atom4,:")-slice($inputPDL,"0:2,$atom3,:");
		
			my $n1 = norm(crossp($b1,$b2));
			my $n2 = norm(crossp($b2,$b3));
			my $m1 = crossp($n1,norm($b2));
		
			my $cos = atan2(inner($m1,$n2),inner($n1,$n2));
			my $negcos = $cos;#$cos->where($cos < 0);
	
			$negcos*=-1;$negcos+=mathFunctions::pi();
			my $acos = sclr(mathFunctions::rad_to_deg($cos));
		
			my $atomi1 = sclr(slice($inputPDL,"3:3,$atom1,:"));
			my $atomi2 = sclr(slice($inputPDL,"3:3,$atom2,:"));
			my $atomi3 = sclr(slice($inputPDL,"3:3,$atom3,:"));
			my $atomi4 = sclr(slice($inputPDL,"3:3,$atom4,:"));
			if($atomi1 > $atomi4) { #then reverse order
				my $temp = $atomi1; $atomi1 = $atomi4; $atomi4 = $temp;
				$temp = $atomi2; $atomi2 = $atomi3; $atomi3 = $temp;
			}
			## $eG >=0 dihedral is proper dihedral of any functional form
	        if($eG >= 0)
			{
				my $val = dihedralOutput(intToFunc("dihedrals",$func,$eG),$atomi1,$atomi2,$atomi3,$atomi4,$acos,$cD,$eG);
				if(!$val) {next;}
				push @{$diheCache}, {'i' => $atomi1,'j' => $atomi2,'k' =>$atomi3, 'l' => $atomi4, 'v' => dihedralOutput(intToFunc("dihedrals",$func,$eG),$atomi1,$atomi2,$atomi3,$atomi4,$acos,$cD,$eG)};
			}
			## Improper dihedral
			else
			{
				#print $OUTPUT dihedralOutput(intToFunc("impropers",$func,$eG),$atomi1,$atomi2,$atomi3,$atomi4,$acos,$cD);
				push @{$diheCache}, {'i' => $atomi1,'j' => $atomi2,'k' =>$atomi3, 'l' => $atomi4, 'v' => dihedralOutput(intToFunc("impropers",$func,$eG),$atomi1,$atomi2,$atomi3,$atomi4,$acos,$cD,-1)};
	 	   }
	 }
}

## Convert .b dihedral function format to gromacs function format
sub dihedralOutput
{
 my($inputFunc,$ai,$aj,$ak,$al,$values,$ratio,$eG) = @_;
 ## Remove white spaces from string ##
 $inputFunc =~ s/^\s+|\s+$//g;
 ## If $input contains a + ##
 	my @funcs = split(/\+/,$inputFunc);
	my $outputString="";
	my $fType="";my $exportRatio;       
 	my $formattedString="";
	my $valueSend;my @paramArr;
	my $funci=0; my @fTypei;
	foreach my $fun(@funcs)
	{
	my $paramFormat="";
	($fType,@paramArr) = diheFuncParser($fun);

 	if($fType !=0){
		# If there is a ?, then substitute the angle value and apply the multiplicity.  If there is no wild card, then simply use the angle provided
		if($paramArr[0] =~ /\?/){
	         # replace ? with native angles
	   	 $paramArr[0] =~ s/\?/$values/g;
		 # evaluate
		 $paramArr[0] = eval($paramArr[0]);
		 }
		 if( $fType == 1){
	            # Angle will be scaled by multiplicity factor n, if they are cosine functions
	            $paramArr[0] *= $paramArr[2];
		 }
	
	
	        if($paramArr[1] =~ /[*?^&!@#%()]/){smog_quit ("Dihedral weight can only contain numbers, but $paramArr[1] found.")};
	#	my $h=$energyGroups->{$eGTable{$eG}}->{"normalize"};
	#	print "$eG $fType $h\n";
	
		if($fType == 0 and $energyGroups->{$eGTable{$eG}}->{"normalize"} != 0){
			smog_quit("Function type dihedral_free is being used for an energy group with normalize != 0.  This can lead to unpredictable results.");
		}
	
		if($funci == 0){
		  $fTypei[0]= $fType;
	
		  if($fType==1 and $paramArr[1] != 1 and $energyGroups->{$eGTable{$eG}}->{"normalize"} != 0){
		   smog_quit ("Since normalization is turned on, the first cosine dihedral in a sum should have weight of 1.\n In order to adjust overall weight of dihedral, while also imposing normalization, use intraRelativeStrength in .sif file");
		  }
		}elsif($funci != 0 and $fTypei[0] != $fType){
	          smog_quit ("Sums of dihedrals of different types is not supported.");
		}
	
		$funci++;
		## If dihedral kd is normalized or has scaling&normalize ##
	 	$paramArr[1]*=$ratio;
	
		### MINOR KLUDGE TO FIX RIGID/IMPROPER DIHEDRALS BEING OFF BY +-180 ###
		if($fType == 2)
		{
			if($paramArr[0]>180){$paramArr[0]-=180;}else{$paramArr[0]+=180;}
		}
	 
		## Format output <i j k function p1 p2 ... pn>
	 	foreach(@paramArr){$paramFormat="$paramFormat %12.9e";}
	
	 ## MINOR KLUDGE TO FIX MULTIPLICITY FORMATTING FOR TYPE 1 ##
	 ## BLAME PAUL##
	 if($fType eq 1) {$paramFormat=" %12.9e	%12.9e %u";}
	
		$formattedString = sprintf("%9d%9d%9d%9d%3d$paramFormat",$ai,$aj,$ak,$al,$fType,@paramArr);
		$outputString = "$outputString$formattedString\n";
	}
	}
		return $outputString;
 }
 
##
# Given a user defined dihedral function parse values
sub diheFuncParser
{
	my($diheFunc) = @_;
 	my $fType;my @paramArr; my $directive;
	my $funcName = "";my $params = "";
	($diheFunc =~ m/(.*)\((.*)\)/);
	$funcName = $1; $params = $2;

	($fType,$directive) = returnFunction($funcName); ## Obtain Gromacs function type
	if($directive ne "dihedrals"){smog_quit ("$funcName is not a valid dihedrals function");}
	@paramArr = split(",",$params); ## Parse all parameters;
	foreach $params(@paramArr){$params =~ s/^\s+|\s+$//g;}
	return ($fType,@paramArr);
}


########################
## CALCULATE CONTACTS ##
########################

sub calculateContacts
{
	my($contactPDL,$inputPDL,$atomTypes,$numCon,$numAtom) = @_;
	my $atoma; my $atomb;my $fType; my $dist;
	my $nbtypea; my $nbtypeb;
	my $resTypea; my $resTypeb;
	my $contactInterScale;
 	my $dihedralInterScale;
	my $multFactor = 1;
	my $c0; my $c1; 
	my $epsilon;my $cG;my $funct;
 	my $totalStrength; my $outputString;
	my $contactIntraScale;
	my $contactIntraTotal;	
	my $count;

	## REMOVE ##
	my $totalEpsilon=0;

	## Sum all initial contact strengths ##	
	for(my $i=0;$i<$numCon;$i++)
	{
			my $normalize;
			$atoma = sclr(slice($contactPDL,"1:1,$i:$i"));
	  		$atomb = sclr(slice($contactPDL,"2:2,$i:$i"));
			$nbtypea = $atomTypes->{$atoma}->[0];
			$nbtypeb = $atomTypes->{$atomb}->[0];
			$resTypea = $atomTypes->{$atoma}->[1];
			$resTypeb = $atomTypes->{$atomb}->[1];
			($funct,$cG) = getContactFunctionals($nbtypea,$nbtypeb);

			if(!$funct || !$cG)
			{smog_quit("No contact Function defined for nbType contacts $nbtypea-$nbtypeb");}
			$normalize = $termRatios->{"contactGroup"}->{$cG}->{"normalize"};
			if(!$normalize){next;}		
			$contactIntraTotal = $termRatios->{"cintraRelativeTotal"};
			$contactIntraScale = $termRatios->{"contactGroup"}->{$cG}->{"intraRelativeStrength"};
			$count+=($contactIntraScale/$contactIntraTotal);
	}

	## Adjust ratio ##
	for(my $i=0;$i<$numCon;$i++)
	{
			my $contactLeftOver;my $diheTotal; my $normalize;
			my $deltaMin=-1;my $scale=-1;my $deltaMax=-1;
			my $resIdxA=0;my $resIdxB=0;
			my $atomA="";my $atomB="";
			my $outputString;
			my $directive;my $addExclusions;
	  		$atoma = sclr(slice($contactPDL,"1:1,$i:$i"));
	  		$atomb = sclr(slice($contactPDL,"2:2,$i:$i"));
			$nbtypea = $atomTypes->{$atoma}->[0];
			$nbtypeb = $atomTypes->{$atomb}->[0];
			$resTypea = $atomTypes->{$atoma}->[1];
			$resTypeb = $atomTypes->{$atomb}->[1];
			($funct,$cG) = getContactFunctionals($nbtypea,$nbtypeb);
			if(!$funct || !$cG)
			{smog_quit("No contact Function defined for nbType contacts $nbtypea-$nbtypeb");} 
			
			$normalize = $termRatios->{"contactGroup"}->{$cG}->{"normalize"};

            ## Stacking scaling ##
            $epsilon = 1;
            if(exists $contactSettings->{"contactScaling"}->{$resTypea}
            && exists $contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb})
            {
              $deltaMin=$contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"deltaMin"};
              $deltaMax=$contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"deltaMax"};

              $scale = $contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"scale"};
              $scale = eval($scale);
              $resIdxA = $allAtoms{$atoma}->[2];
              $resIdxB = $allAtoms{$atomb}->[2];
              
              $atomA = $allAtoms{$atoma}->[3];
              $atomB = $allAtoms{$atomb}->[3];
              ##Atom to boolean##
              $atomA = exists($contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"atomList"}->{$atomA});
              $atomB = exists($contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"atomList"}->{$atomB});

              
              if(abs($resIdxB-$resIdxA)>=$deltaMin 
              && abs($resIdxB-$resIdxA)<=$deltaMax
              && $atomA && $atomB)
              {
               $epsilon*=$scale;
              }
              else{$epsilon=1;}
            
            }

			## Non-Native option for contacts ##
			if(!$normalize) {
			$dist = sclr(slice($contactPDL,"3:3,$i:$i"));
			$c0=$dist;
			($directive,$addExclusions,$outputString) = contactOutput($funct,$atoma,$atomb,$c0,$epsilon);
			addToTop($directive,$outputString."\n");
			if($addExclusions) { addToTop("exclusions",$atoma."	".$atomb."\n"); }
			}	
			
			else {	
			## DIHE TO CONTACT SCALING ##
			## DIHEDRAL TO CONTACT RATIO IS GLOBAL IRREGARDLESS OF RESIDE TYPE ##
			$totalStrength = $termRatios->{"interRelativeTotal"};
			$diheTotal = $termRatios->{"energyRelative"};
			$contactLeftOver = $numAtom - $numAtom*($diheTotal/$totalStrength);
			$contactLeftOver = $contactLeftOver/$count;
   			$multFactor = $contactLeftOver;

			## CONTACT TO CONTACT SCALING ##			
			$contactIntraTotal = $termRatios->{"cintraRelativeTotal"};
			$contactIntraScale = $termRatios->{"contactGroup"}->{$cG}->{"intraRelativeStrength"};
			$multFactor = $multFactor*($contactIntraScale/$contactIntraTotal);

			$epsilon = $epsilon*$multFactor;
	  		$dist = sclr(slice($contactPDL,"3:3,$i:$i"));
	  		$c0=$dist;
	  		$totalEpsilon+=$epsilon;
			($directive,$addExclusions,$outputString) = contactOutput($funct,$atoma,$atomb,$c0,$epsilon);
			addToTop($directive,$outputString."\n");
			#print $directive," ",$addExclusions," ",$outputString,"\n";
			if($addExclusions) { addToTop("exclusions",$atoma."	".$atomb."\n"); }
			}
	}
}

##
# Convert internal contact function format to gromacs function format,
# internal format is f()+g()
sub contactOutput
{
 my($inputFunc,$i,$j,$c0,$epsilon) = @_;
 if(!$inputFunc){smog_quit ("CONTACTOUTPUT::NO FUNCTION DEFINED");}
 ## Remove white spaces from string ##
 $inputFunc =~ s/^\s+|\s+$//g;
 ## If $input contains a + ##
 my @funcs = split(/\+/,$inputFunc); ## split combination of functions
 my $outputString="";
 my @paramArr;
 my $fname;
 my $directive;
 my $addExclusions;
 my $fType=""; my $formattedString;
 ## Parse each part of the function ##
 foreach my $fun(@funcs)
 {
	my $paramFormat="";
	($fType,$fname,$directive,$addExclusions,@paramArr) = contactFuncParser($fun);
	## LJ CONTACTS N-M polynomial, sigma and epsilon usage ##	
    if($fname eq "contact_1"){
		contactParseNM1(\@paramArr,$c0,$epsilon);
		if($fType != 1){smog_quit ("Only fType=1 is supported with contacts contact_1")}
    }
	## LJ CONTACTS N-M polynomial, CN, CM usage ##	
    elsif($fname eq "contact_2"){
		contactParseNM2(\@paramArr,$c0,$epsilon);
		if($fType != 1){smog_quit ("Only fType=1 is supported with contacts contact_2")}
    }
        ## Gaussian ##
    elsif($fname eq "contact_gaussian"){
	contactParseGaussian(\@paramArr,$c0,$epsilon);
	if($fType != 6){smog_quit ("Only fType=6 is supported with contacts contact_gaussian")}

    }
	## harmonic bond type 6 ##
    elsif($fname eq "bond_type6"){
	contactParseBond6(\@paramArr,$c0,$epsilon);
	if($fType != 6){smog_quit ("Only fType=6 is supported with contacts of bond_type6")}

    }
    else{smog_quit("Contact function name $fname is not supported");}

 	## Format output <i j function p1 p2 ... pn>
 	foreach(@paramArr){$paramFormat="$paramFormat	%12.9e";}
	$formattedString = sprintf("%d %d %d$paramFormat",$i,$j,$fType,@paramArr);
	$outputString = "$outputString$formattedString";
 }
 return ($directive,$addExclusions,$outputString);
 
}

##
# Parse LJ NM sigma eps usage
sub contactParseNM1
{
  my($paramArr,$r0,$epsilon) = @_;
  ##pararArr holds N, M, and whether native distances and weights should be used.
  ##epsilon
  ##r0 is native distance##
  #
  my $cN;my $cM; 
  my $A; my $B;
  my $N; my $M;
  $M=$paramArr->[0];
  $N=$paramArr->[1];
  my $length=scalar @{$paramArr};
  if($length != 4){ smog_quit ("Incorrect number of parameters provided for contact_1. Expecting 4, found $length."); }
  if($N =~ /^\?$/ or $M =~ /^\?$/ or $N  !~ /^\d+$/ or $M  !~ /^\d+$/){smog_quit ("Must provide integers for exponents of function contact_1");}

  if($M>=$N){smog_quit ("When using contact_1, the first exponent provided should be smaller.")}

  $B=-1.0/($M/$N-1.0);
  $A=$M/$N*$B;
  # replace ? with native distance expression
  $paramArr->[2] =~ s/\?/$r0/g;
  #Eval expression
  $r0 = eval($paramArr->[2]);
     
  $A *= $epsilon*$r0**$N;
  $B *= $epsilon*$r0**$M;

  ## normalized option used
  if($paramArr->[3] =~ /^\?$/)
  {
    $paramArr->[3]=$A;
    $paramArr->[2]=$B;
  }
  ## additional rescaling used
  else{
   $A *= $paramArr->[3];
   $B *= $paramArr->[3];
   $paramArr->[3]=$A;
   $paramArr->[2]=$B;
  } 
  ## Shift first value off ##
  shift @{$paramArr};
  shift @{$paramArr};

}

# Parse LJ NM sigma eps usage
sub contactParseNM2
{
  my($paramArr,$r0,$epsilon) = @_;
  ##pararArr holds f(r), g(r), and whether native distances and weights should be used.
  ##epsilon
  ##r0 is native distance##
  #
  my $A; my $B;
  my $F; my $G;
  $F=$paramArr->[1];
  $G=$paramArr->[0];
  my $length=scalar @{$paramArr};
  if($length != 4){ smog_quit ("Incorrect number of parameters provided for contact_2. Expecting 4, found $length."); }

  # replace ? with native distance expression
  $paramArr->[2] =~ s/\?/$r0/g;

  $paramArr->[2] = eval($paramArr->[2]);

  # substitute value of r into f(r) and g(r)
  $F =~ s/\?/$paramArr->[2]/g;
  $G =~ s/\?/$paramArr->[2]/g;

  #Eval expression
  $A = eval($F);
  $B = eval($G);
  $A *= $epsilon; 
  $B *= $epsilon; 


  ## standard normalization used
  if($paramArr->[3] =~ /^\?$/)
  {
    $paramArr->[3]=$A;
    $paramArr->[2]=$B;
  }
  ## additional rescaling used
  else{
   $A *= $paramArr->[3];
   $B *= $paramArr->[3];
   $paramArr->[3]=$A;
   $paramArr->[2]=$B;
  } 
  ## Shift first value off ##
  shift @{$paramArr};
  shift @{$paramArr};

}


##
# Parse Gaussian Params
sub contactParseGaussian
{

 my($paramArr,$r0,$epsilon) = @_;
 my $A=0;my $sigma_G=0;my $a=0;
  ##i=0 is epsilon_c##
  ##i=1 is epsilon_nc#
  ##i=2 is sigma_gaussian##
  ##i=3 is r ##


  if($paramArr->[1] =~ /\?/ && !($paramArr->[2] =~ /^\?$/))
  {smog_quit("CONTACT FUNCTION PARSING:: CONFLICTING INPUTS");}

  ## Epsilon_c ##
  if($paramArr->[0] =~ /^\?$/){$paramArr->[0]=$epsilon;}
  else{$paramArr->[0]=$epsilon*($paramArr->[0]);}
  ## Epsilon_nc ##
  if($paramArr->[1] =~ /\?/){smog_quit("CONTACT FUNCTION PARSING:: CONFLICTING INPUTS");}

  ## Check if sigma_G has r0 dependency ##
  if($paramArr->[2] =~ /\?/)
  {
     #Replace ? with $r0 
     $paramArr->[2] =~ s/\?/$r0/g;
     #Eval expression
     $paramArr->[2] = eval($paramArr->[2]);
  }
  if($paramArr->[3] =~ /^?$/){$paramArr->[3]=$r0;}
  
  ($A,$r0,$sigma_G,$a) = ($paramArr->[0],$paramArr->[3],$paramArr->[2],$paramArr->[1]);
  @{$paramArr}=($A,$r0,$sigma_G,$a);

}
##
# Parse Bond type 6
sub contactParseBond6
{
 my($paramArr,$r0,$epsilon) = @_;
 my $k;
  ##i=0 is r##
  ##i=1 is k#

  ## k ##
  if($paramArr->[1] =~ /\?/)
  {smog_quit("CONTACT FUNCTION PARSING:: contact bond_type6 can't have ? in the stiffness.");}
  $paramArr->[1] = eval($paramArr->[1]);
  
  ## r ##
  if($paramArr->[0] =~ /\?/)
  {
     #Replace ? with $r0 
     $paramArr->[0] =~ s/\?/$r0/g;
  }
  #Eval expression
  $paramArr->[0] = eval($paramArr->[0]);
  
  ($r0,$k) = ($paramArr->[0],$paramArr->[1]);
  @{$paramArr}=($r0,$k);

}

##
# Given a user defined contact function parse values
sub contactFuncParser
{
	my($contactFunc) = @_;
	my $fType;my @paramArr;my $directive;my $addExclusions;
	my $funcName = ""; my $params = "";
 	#($contactFunc =~ m/(.*)\((.*)\)/);
 	($contactFunc =~ /^([^(]+)\((.*)\)$/);
 	$funcName = $1;
	$params = $2;
	($fType,$directive,$addExclusions) = returnFunction($funcName); ## Obtain Gromacs function type
	if($directive ne "pairs" && $directive ne "bonds"){smog_quit ("$funcName is a contact type function and should only go into pairs or bonds directives");}
 	@paramArr = split(",",$params); ## Parse all parameters
 	foreach $params(@paramArr){$params =~ s/^\s+|\s+$//g;}
	#if($funcName eq "bond_type6") { print @paramArr;}
	return ($fType,$funcName,$directive,$addExclusions,@paramArr);
}



##########################
## CALCULATE EXCLUSIONS ##
##########################


#deprecated!
sub calculateExclusions
{
	my($contactPDL,$numCon) = @_;
	my $atoma; my $atomb;


	#print an exclusion for every contact
	for(my $i=0;$i<$numCon;$i++)
	{
		$atoma = sclr(slice($contactPDL,"1:1,$i:$i"));
		$atomb = sclr(slice($contactPDL,"2:2,$i:$i"));
		addToTop("exclusions",$atoma."	".$atomb."\n");
	}
}

sub calculateAtomTypes
{
	my($uniqeHandle) = @_;
	my $formattedString = "";	
	
	## OBTAIN UNIQUE ATOM TYPES ##
	my %obtained;my $nbtype ="";
	my $c12;my $c6;my $ptype;my $charge;my $mass;
	
	foreach my $atoms(keys %{$uniqeHandle})
	{
		$nbtype = $uniqeHandle->{$atoms}->[0];
  		if(!$uniqeHandle->{$atoms}->[0])
        {
          smog_quit("Atom $atoms has no nbType");
        }
		my $tmptype=$nbtype;
		foreach my $name(keys %{$interactions->{"nonbonds"}}){
                        if($nbtype =~ /\Q$name\E/) {$tmptype=$name; last; }# exact match found
                        if($name =~ /\Q*\E/) { $tmptype=$name; }# not exact match.  maybe use it, but keep looking
		}
		if(exists $obtained{$nbtype}){next;}
		$c6 = $interactions->{"nonbonds"}->{$tmptype}->{"c6"};
		$c12 = $interactions->{"nonbonds"}->{$tmptype}->{"c12"};
		$ptype = $interactions->{"nonbonds"}->{$tmptype}->{"ptype"};
		$mass = $interactions->{"nonbonds"}->{$tmptype}->{"mass"};
		$charge = $interactions->{"nonbonds"}->{$tmptype}->{"charge"};

		if(!$c6 || !$c12 || !$ptype || !$mass || !$charge)
		{smog_quit("Nonbond Params at atom types not set for nbType $tmptype");}
		
		$formattedString = sprintf("  %-4s %-6.3f %-5.3f  %1s     %-13.5e %-13.5e",$nbtype,$mass,$charge,$ptype,$c6,$c12);
		addToTop("atomtypes",$formattedString."\n");
		$obtained{$nbtype}=1;
	}
}

sub readAtoms
{
	my($inputPDB) = @_;
	open(PDB,$inputPDB);
	my $line = "";
	my $atomName;my $atomNum; my $resName; my $resNum;
	my $charge = 0; my $mass = 1; my $atomType="none";
	my $counter=0; my $resCounter=1;my $resNumCurr="null";
	while($line = <PDB>)
	{
		if($line =~ m/END/) {last;}
		if($line =~ m/ATOM/ || $line =~ m/HETATM/)
		{
			$atomName = substr($line, 12, 4);
			$atomName =~ s/^\s+|\s+$//g;
			#$atomNum = substr($line,6,5);
			
			$resName = substr($line,17,4);
			$resName =~ s/^\s+|\s+$//g;
			$resNum = substr($line,22,4);
			$resNum =~ s/^\s+|\s+$//g;
			if($resNumCurr eq "null"){
				$resNumCurr=$resNum;
			}
   			if($resNum ne $resNumCurr)
			{
				$resNumCurr=$resNum;
				$resCounter++;
			}
			if(!$residues{$resName}->{"atoms"}->{$atomName}){next;}
			$counter++;$atomNum=$counter;
			$atomType = $residues{$resName}->{"atoms"}->{$atomName}->{"nbType"};
			#printf $OUTPUT "%6d %10s %6d %6s %6s %6d\n", $atomNum, $atomType, $resCounter, $resName, $atomName, $atomNum;
			addToTop("atoms",sprintf("%6d %10s %6d %6s %6s %6d\n", $atomNum, $atomType, $resCounter, $resName, $atomName, $atomNum));

		}
	}


}

##
# Convert PDB to GRO
# Store chain info to ndx file
sub convertPDBToGroNdx
{
	my ($inputPDB,$outputGRO,$outputNDX) = @_;
	my $counter = 0 ;	
	my $line = "";
	my $resName="";
	my $resNum="";
	my $atomName="";
	my $atomNum="";
 	my $x="";my $y="";my $z="";
 	my $output = "";
 	my $chain = "";
 	my $chainCounter = 1;
 	my %chainHash;
	my $resNumCurr=1;my $resCounter=1;
	my $boundflag=0;
	my ($xmin, $xmax, $ymin,$ymax,$zmin,$zmax);
 	open(PDB,$inputPDB); ## INPUT PDB
	if(-e "meta.Gro"){
		print "meta.Gro is a reserved file name.  It appears to already exist.  Please move and try again\n";
		die;
	}
	open(GRO,">meta.Gro");
	while($line=<PDB>)
	{
		
	 if($line =~ m/END/) {last;}
  	 if($line =~ m/TER/) {$chainCounter++;next;}
         if($line =~ m/ATOM|HETATM/)
         {
		$atomName = substr($line, 12, 4);
		$atomName =~ s/^\s+|\s+$//g;
		$resName = substr($line,17,4);
		$resName =~ s/^\s+|\s+$//g;
        if(!exists $residues{$resName}->{"atoms"}->{$atomName})
		{next;}
		
		$x = substr($line, 30, 8);$x*=0.10;
		$y = substr($line, 38, 8);$y*=0.10;
		$z = substr($line, 46, 8);$z*=0.10;
		
		if($boundflag == 0){
			$xmin=$x;
			$xmax=$x;
			$ymin=$y;
			$ymax=$y;
			$zmin=$z;
			$zmax=$z;
			$boundflag=1;
		}else{
			if($x > $xmax){$xmax=$x;}
			if($x < $xmin){$xmin=$x;}
			if($y > $ymax){$ymax=$y;}
			if($y < $ymin){$ymin=$y;}
			if($z > $zmax){$zmax=$z;}
			if($z < $zmin){$zmin=$z;}
		}
	
  		$chain = $chainCounter;
		$counter++;$atomNum=$counter;
		$resNum = substr($line,22,4);
		$resNum =~ s/^\s+|\s+$//g;
		if($atomNum == 1){$resNumCurr=$resNum;}
		if($resNum ne $resNumCurr)
			{
				$resNumCurr=$resNum;
				$resCounter++;
			}

  		## Save atom index to chain ##
  		push(@{$chainHash{$chain}},$atomNum);
		if($atomNum >= 100000){$atomNum = $atomNum%100000;}
	    if($resCounter >= 100000){$resCounter = $resCounter%100000;}
		$output = sprintf("%5d%-5s%5s%5d%8.3f%8.3f%8.3f\n",$resCounter,$resName,$atomName,$atomNum,$x,$y,$z);
		print GRO $output;
		
	 }
	}

## default box size if 1nm larger than system size in each direction
	my $xrange=($xmax-$xmin)+2.0;
	my $yrange=($ymax-$ymin)+2.0;
	my $zrange=($zmax-$zmin)+2.0;

 ## ADJUST GRO FILE ##
	close(PDB);
	close(GRO);open(GROIN,"meta.Gro");
	open(GRO,">$outputGRO");
	print GRO "Gro file for a structure based model, generated with SMOG Version $VERSION\n";
	print GRO $counter,"\n";
	while(<GROIN>) { print GRO $_;}
	print GRO "$xrange $yrange $zrange\n";
	close(GRO); close(GROIN);
	unlink("meta.Gro");
	
 ## CREATE NDX FILE ##
 open(NDX,">$outputNDX");
 my $c;my $v;
 while(($c,$v) =  each %chainHash)
 {
			print NDX "[ $c ]\n";
   print NDX join("\n",@{$v});
   print NDX "\n";
 }
 close(NDX);
 
}

sub validateTemplate
{
 my ($file,$type) = @_;
 my $validator = XML::Validator::Schema->new(file => "$ENV{SMOG_PATH}/schemas/$type.xsd");
 my $parser = XML::SAX::ParserFactory->parser(Handler => $validator);
 eval { $parser->parse_uri($file) };
 die "\nFailed at validating $file: $@" if $@;

}

sub parseInputFolder
{
 my ($folderName) = @_;
 $folderName = $1 if($folderName=~/(.*)\/$/);
 opendir(my $folder,$folderName);
 my $bif;my $sif;my $b;my $nb;
 my $bifexists=0;
 my $sifexists=0;
 my $nbexists=0;
 my $bexists=0;
 while(my $file = readdir($folder))
 {
   if($file =~ m/\.bif$/)
   {
    $bifexists++;
    $bif = $file;$bif = "$folderName/$bif";
    print "\nFound .bif file $bif";
    validateTemplate($bif,"bif");next;}
   if($file =~ m/\.sif$/)
   {
    $sifexists++;
    $sif = $file;$sif = "$folderName/$sif";
    print "\nFound .sif file $sif";
    validateTemplate($sif,"sif");next;}
   if($file =~ m/\.b$/)
   {
    $bexists++;
    $b = $file;$b = "$folderName/$b";
    print "\nFound .b file $b";
    validateTemplate($b,"b");next;}
   if($file =~ m/\.nb$/)
   {
    $nbexists++;
    $nb = $file;$nb = "$folderName/$nb";
    print "\nFound .nb file $nb";
    validateTemplate($nb,"nb");next;}
  }
  $bifForSCM = $bif;

  if($bifexists >1){
   smog_quit ("Found multiple .bif files in directory $folderName");
  }elsif($bifexists ==0){
   smog_quit (" .bif file not found in directory $folderName");
  }
  if($sifexists >1){
   smog_quit ("Found multiple .sif files in directory $folderName");
  }elsif($sifexists ==0){
   smog_quit (" .sif file not found in directory $folderName");
  }
  if($bexists >1){
   smog_quit ("Found multiple .b files in directory $folderName");
  }elsif($bexists ==0){
   smog_quit (" .b file not found in directory $folderName");
  }
  if($nbexists >1){
   smog_quit ("Found multiple .nb files in directory $folderName");
  }elsif($nbexists ==0){
   smog_quit (" .nb file not found in directory $folderName");
  }

 setInputFileName($bif,$sif,$b,$nb);

}

sub header
{
my $header="******* ******* ******* ******* ******* SMOG v$VERSION ******* ******* ******* ******* *******";
my $headw=length($header);
  print "\n";
for(my $I=0;$I<$headw;$I++){
  print "*";
}
  print "\n";
  print "$header";

print <<EOT;

              Thank you for using the Structure-based Model (SMOG) software

    This package is the product of contributions from a number of people, including:
                      Jeffrey Noel, Mariana Levi, Mohit Raghunathan,
                         Ryan Hayes, Jose Onuchic & Paul Whitford

                     Copyright (c) 2015, The SMOG development team at
                        Rice University and Northeastern University

              SMOG v$VERSION & Shadow are available at http://smog-server.org

                        Direct questions to: info\@smog-server.org

EOT

 for(my $I=0;$I<$headw;$I++){
   print "*";
 }
 print "\n";

}

sub usage
{
  header();
  print <<EOT;

usage: smogv2  [-i PDB file name] [-o smog.top] [-g smog.gro] [--help|-?]

   Required Input
	-i [filename.pdb]: Input PDB to generate Hamiltonian
   Optional Input/Output parameters
	-AA: Use default All-atom model
	-CA: Use default Calpha protein model
	-t [templateFolder]: Folder containing templates of molecular and interaction definitions. Required when defaults are not used.
	-tCG [templateFolder]: Folder containing templates Coarse Graining. Indicates that the program should coarse grain.
	-g [smog.gro]: Output .gro file name
	-o [smog.top]: Output .top file name
	-s [smog.contacts]: Output .contacts file name
	-n [smog.ndx]: Output .ndx file name
	-c [contacts.txt]: Input contact map file
	-dname [smog]: Default name to use for all output files
	-backup [yes]: Back up any pre-existing output files
	-warnonly: Convert fatal errors to warnings (Caution: Consult manual before using this option)
	-limitbondlength: If a bond length is outside of the allowable range, set it to limiting value
	-limitcontactlength: If a contact length is too short, set it to the minimal value
	-ignH: Ignore any atoms with name starting with 'H' in the internal contact algorithm
EOT
  if ( @_ ){
   smog_quit("Command-line argument \"@_\" not recognized.");
  }else{
   exit;
  }
}

sub setContactParams
{
	my $method = $contactSettings->{"method"};
	my $params = "";
	if($method =~ m/shadow/)
	{
		my $radius = $contactSettings->{"shadowRadius"};
		my $radiusBonded = $contactSettings->{"shadowRadiusBonded"};
		my $dist = $contactSettings->{"contactDistance"};
		$params="-m shadow -c $dist -s $radius -br $radiusBonded -bif $bifForSCM --smog2output --showProgress";
	}
	elsif($method =~ m/cutoff/) 
	{
		my $dist = $contactSettings->{"contactDistance"};
		my $radius = 0.0;
		my $radiusBonded = 0.0;
		$params="-m shadow -c $dist -s $radius -br $radiusBonded -bif $bifForSCM --smog2output --showProgress";
	}
	else {smog_quit ("Contact map method $method is not supported.");}
	if($ignoreHydrogen == 1) { $params = $params." --ignoreH "; }
	return $params;
}


sub printCitation
{
    my $citationFile = "";
    ## CHECK FOR .citation meta file ##
    if($coarseFolder && -e "$coarseFolder/.citation")
    {
      open(CITE,"$coarseFolder/.citation");
      $citationFile = join("",<CITE>);
      close(CITE);
    }
    elsif(-e "$inputFolder/.citation")
    {
      open(CITE,"$inputFolder/.citation");
      $citationFile = join("",<CITE>);
      close(CITE);
    }
    else{$citationFile = "";}
       

print <<EOT;

########################################################################################

              We kindly ask that you cite the appropriate primary references
             when using SMOG models. See http://www.smog-server.org/refs.html

--Software-- 
Noel JK, Levi M, Rangunathan M, Lammert H, Hayes R, Onuchic JN, and Whitford PC.
SMOG V2, A Versatile Software Package for Generating Structure-Based Models 
2015, In preparation. 

$citationFile
########################################################################################

EOT

}

##
## MEMORY MANAGEMENT ROUTINES
##

sub freeMemoryForShadow
{
undef %resPDL;undef %connPDL;
undef %connAngleFunctionals;undef %connDiheFunctionals;
undef %connBondFunctionals;undef $contactPDL;
}


sub parseTemplates
{
	my ($inputFolder,$inputPDB,$allowCG) = @_;
    
    ## TEST IF SMOG PATH EXISTS ##
    if(!$ENV{"SMOG_PATH"}){smog_quit("SMOG_PATH environment variable not set");}
	$| = 1;
	## OPEN .top handle ## don't do this here since we buffered the output now
	#open($OUTPUT, ">$topFile"); 
	parseInputFolder($inputFolder); ## PARSE FOLDER --> FILE

	#####################
    ## PARSE TEMPLATES ##
    #####################
	initializeDirectives($inputFolder,$inputPDB);
	## parse .bif File ##
	parseBif();
	## parse .sif File ##
	parseSif();
	## parse Bonds/Nonbonds File
	parseBonds();parseNonBonds();
    	print "\nDone parsing templates.\n";
	## Find Bonds ##
	createBondFunctionals();
	## Find Angles ##
	createDihedralAngleFunctionals();
	###############
    ## PARSE PDB ##
    ###############
	print "Parsing .pdb...\n";
	parsePDBATOMS($inputPDB,$allowCG);
	catPDL();
}

sub printBondedTopOutput {
	my ($inputPDB,$groFile,$ndxFile) = @_;
	print "Generating angles and dihedrals...";
	getSetDiheCounts(\%connDiheFunctionals,\%connPDL);
	## SET DIHEDRAL RATIOS ##
	print "..";
	setRatios(\%connDiheFunctionals,\%connPDL,$totalAtoms,\%allAtoms);
	print "..";
	calculateAtomTypes(\%allAtoms);
	print "..";
	readAtoms($inputPDB);
	## CALCULATE BONDS/CONNECTED BONDS ##
	print "..";
	printOrderedBonds(\%bondFunctionals,\%resPDL,\%connBondFunctionals,\%connPDL);
	## CALCULATE ANGLES ##
	print "\nSaving angles\n";
	printOrderedAngles(\%connAngleFunctionals,\%connPDL);
	## CALCULATE DIHEDRALS ##
	print "Saving dihedrals\n";
	printOrderedDihedrals(\%connDiheFunctionals,\%connPDL);
	## CREATE GRO FILE ##
	convertPDBToGroNdx($inputPDB,$groFile,$ndxFile);
	## print intermediate top for SCM.jar to read ##
}

sub generateContactMap {
	my ($groFile,$ndxFile,$shadowFile,$topFile) = @_;
	## CALL SHADOW/PARSE CONTACTS ##
	print "Starting contact calculations ...\n  ";
	my $SCMparams = setContactParams();
    my $memoryMax = "";
	my $absAtomCount = keys(%allAtoms);
    if($absAtomCount >= 1000000)
    {
     $memoryMax = 4000;
     print "JAVA HEAP SIZE INCREASED to $memoryMax Mb\n";
     $memoryMax = "-Xmx$memoryMax"."m";
    } 
	
	## Delete Preexisting contact file ##
	if(-e $shadowFile){unlink($shadowFile);}
	
	## Free Memory for Shadow ##
	freeMemoryForShadow();
	
	if((!exists $ENV{SMOG_PATH}) || 
		!(-e "$ENV{SMOG_PATH}/tools/SCM.jar")){smog_quit ("Can't find Shadow executable. Make sure SMOG_PATH is set correctly.")}
		print "Calling $ENV{SMOG_PATH}/tools/SCM.jar \n";
	    system("java $memoryMax -jar $ENV{SMOG_PATH}/tools/SCM.jar -g $groFile -t $topFile -o $shadowFile -ch $ndxFile $SCMparams ");
}

sub appendContactsAndFinish {
	my($fileName,$fileName2,$userProvidedMap) = @_;
	#Parse the contact map, either the generated one or the user provided one
	$numContacts = parseCONTACT($shadowFile,$ContactFile,$userProvidedMap,$CGenabled);
	if($numContacts == 0){smog_quit ("There are 0 contacts.  See earlier messages for possible errors");}
	my $absAtomCount = keys(%allAtoms);
	print "NOTE: Total number of atoms included in normalization is $totalAtoms, and $absAtomCount atoms are in the system.\n";
	print "Completing final details...";
	## CALCULATE PAIRS and EXCLUSIONS ##
 	calculateContacts($contactPDL,\%resPDL,\%allAtoms,$numContacts,$totalAtoms);
	#print defaults
	my $combrule = 1; my $genpairs = "no";
	if(exists $interactions->{"gmx-combination-rule"}) { 
		$combrule = $interactions->{"gmx-combination-rule"};
	}
	if(exists $interactions->{"gen-pairs"} && $interactions->{"gen-pairs"} == 1) { $genpairs = "yes"; }
	addToTop("defaults", "  1      $combrule         $genpairs\n");
	print "\nYour Structure-based Model is ready!\n\nFiles generated: \n\t$topFile\n\t$groFile\n\t$ndxFile\n";
	if(!$userProvidedMap) { print "\t$shadowFile\n"; }
	if($CGenabled && !$userProvidedMap) { print "\t$shadowFile.CG\n"; }
	printCitation();
}

##################
## PARSE INPUTS ##
##################

my $DNAME="smog";
my $warnonly=0;
my $backup="yes";

## parse command line options ##
# -o output top file name, default is smog.top
usage() if (@ARGV < 1 || !GetOptions('help|?' => \$help, 'o=s' => \$topFile, 't=s' => \$inputFolder, 'i=s' => \$inputPDB, 'g=s' => \$groFile,
	'c=s' => \$ContactFile, 's=s' => \$shadowFile, 'n=s' => \$ndxFile, 'ignH' => \$ignoreHydrogen,
	 'tCG=s' => \$coarseFolder, 'CA'=> \$CAdefault, 'AA' => \$AAdefault, 'dname=s' => \$DNAME, 'warnonly' => \$warnonly, 
         'backup=s' => \$backup, 'limitbondlength' => \$setBondtoLimit, 'limitcontactlength' => \$setContacttoLimit, '<>' => \&usage)
          or defined $help 
          or !defined $inputPDB 
          or (!defined $inputFolder  && !defined $coarseFolder));

header();
if($warnonly){
	$noexit=1;
	print "\n\n-warnonly selected.  Will not intentionally exit when an error is encountered.\nThis can lead to program instability, which may still result in a crash.\nBe cautious, ignoring errors can lead to unpredictable results. \n ONLY use this option if you are sure the error is harmless.\n\n";
}else{
	$noexit=0;
}

if($inputFolder eq "" && $CAdefault==0 && $AAdefault==0){
	smog_quit("No model specified. You must use either -t, -AA, or -CA. Try -help for usage information.");
}

if($coarseFolder ne "") { $CGenabled = 1; }

if($backup ne "yes" and $backup ne "no"){
	smog_quit("Can not understand -backup flag. Usage -bu [yes/no]");
}elsif($backup eq "no"){
	print "-backup no issued.  Will overwrite any existing output files.\n";
}

if($CAdefault == 1 and $AAdefault == 1){
	smog_quit('Can not use -CA and -AA options at the same time.');
}
if($CAdefault == 1 and $CGenabled == 1){
	smog_quit('Can not use -tCG and -AA options at the same time.');
}
if($CAdefault == 1 and $inputFolder ne ""){
	smog_quit('Can not use -CA and -t options at the same time.');
}
if($AAdefault == 1 and $inputFolder ne ""){
	smog_quit('Can not use -AA and -t options at the same time.');
}
if(($CAdefault == 1 || $AAdefault == 1) and $coarseFolder ne ""){
	smog_quit('Can not use -AA, or -CA with -tCG.');
}

if($CAdefault == 1){
	print "\n -CA given. Will use the default Calpha SMOG model provided with the distribution.\n";
	my $SMOGDIR=$ENV{'SMOG_PATH'};
	$inputFolder="$SMOGDIR/SBM_AA";
	$coarseFolder="$SMOGDIR/SBM_calpha";
	print "Will try to use templates found in \n$inputFolder\n and\n$coarseFolder\n\n";
	if(! -d $inputFolder){
		smog_quit("$inputFolder is not a valid template directory.");
	}
	if(! -d $coarseFolder){
		smog_quit("$coarseFolder is not a valid template directory.");
	}
	$CGenabled=1;
}
if($AAdefault == 1){
	print "\n-AA given. Will use the default All-Atom SMOG model provided with the distribution.\n";
	my $SMOGDIR=$ENV{'SMOG_PATH'};
	$inputFolder="$SMOGDIR/SBM_AA";
	print "Will try to use templates found in \n$inputFolder\n\n";
	if(! -d $inputFolder){
		smog_quit("$inputFolder is not a valid template directory.");
	}
}


# if a contact file is provided, then don't calculate contacts
if($ContactFile ne ""){
	$userProvidedMap=1;
}

## Ensure we only write out files with gromacs-compatible suffices
my $maxbu=10;
if($topFile eq ""){$topFile=$DNAME};
if($groFile eq ""){$groFile=$DNAME};
if($shadowFile eq ""){$shadowFile=$DNAME};
if($ndxFile eq ""){$ndxFile=$DNAME};
my ($ext)=$topFile =~ /(\.[^.]+)$/;
if($topFile !~ /(\.[^.]+)$/){
	$topFile = $topFile . ".top";
}elsif($ext ne ".top"){
	$topFile = $topFile . ".top";
}
($ext)=$groFile =~ /(\.[^.]+)$/;
if($groFile !~ /(\.[^.]+)$/){
	$groFile = $groFile . ".gro";
}elsif($ext ne ".gro"){
	$groFile = $groFile . ".gro";
}
($ext)=$shadowFile =~ /(\.[^.]+)$/;
if($shadowFile !~ /(\.[^.]+)$/){
	$shadowFile = $shadowFile . ".contacts";
}elsif($ext ne ".contacts"){
	$shadowFile = $shadowFile . ".contacts";
}
($ext)=$ndxFile =~ /(\.[^.]+)$/;
if($ndxFile !~ /(\.[^.]+)$/){
	$ndxFile = $ndxFile . ".ndx";
}elsif($ext ne ".ndx"){
	$ndxFile = $ndxFile . ".ndx";
}

## check if files exist
# things we don't want to overwrite
if($backup eq "yes"){
	foreach my $filen($topFile, $groFile, $shadowFile, $ndxFile){
		my ($ext) = $filen =~ /(\.[^.]+)$/;
		if($filen ne "" && -e $filen){
			for(my $bu=1;$bu<=$maxbu;$bu++){
				my $buname="$filen.bu$bu";
				if( ! -e $buname){	
				print "$filen already exists.  Backing up to $buname\n";
				system("mv $filen $buname");
				last;
				}
				if($bu == $maxbu){
			 	smog_quit ("Already backed up $maxbu copies of $filen."); 
				}
			}
		}
	}
}
# files we will read
foreach my $filen($inputPDB,$ContactFile){
	if($filen ne "" && ! -f $filen){
		smog_quit("Can't find file $filen !! ");
	}
}
# directories we will access
foreach my $filen($inputFolder,$coarseFolder){
	if($filen ne "" && ! -d $filen){
		smog_quit ("Can't find directory $filen !! ");
	}
}


####################
## PROGRAM DRIVER ##
####################

if($CGenabled == 0) {
	print "\n*****************************************************\n";
	print   "******* ALL-ATOM SMOG MODEL WILL BE GENERATED *******";
	print "\n*****************************************************\n";
} else {
	print "\n*****************************************************\n";
	print   "**** COARSE-GRAINED SMOG MODEL WILL BE GENERATED ****";
	print "\n*****************************************************\n";
}
my $allowCG = 0;
print "Parsing templates corresponding to input PDB... ";
parseTemplates($inputFolder,$inputPDB,$allowCG);
if($CGenabled == 0) {
	printBondedTopOutput($inputPDB,$groFile,$ndxFile);
} elsif ($CGenabled == 1 && $userProvidedMap == 0) { #CG but we still need full .top to make a map
	print "Creating topology for contact calculation.....\n";
	printBondedTopOutput($inputPDB,$groFile,$ndxFile);
}
if($userProvidedMap == 0) { #use SCM.jar if user doesn't provide a map
	printTop($topFile);
	generateContactMap($groFile,$ndxFile,$shadowFile,$topFile);
}
if($CGenabled == 1) { #Coarse graining, do everything over with new templates
    	clearBifMemory();clearPDBMemory();
	$allowCG = 1;
	print "\nParsing templates for coarse graining... ";
	parseTemplates($coarseFolder,$inputPDB,$allowCG);
	printBondedTopOutput($inputPDB,$groFile,$ndxFile);
}
appendContactsAndFinish($shadowFile,$ContactFile,$userProvidedMap);
printTop($topFile);
## END ##
