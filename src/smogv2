#########################################################################################
# smog2 contains the main routines
#
#                          Structure-based Model (SMOG) software
#    This package is the product of contributions from a number of people, including:
#            Jeffrey Noel, Mariana Levi, Antonio Oliveira, VinÃ­cius Contessoto,
#             Esteban Dodero-Rojas, Mohit Raghunathan, Joyce Yang, Prasad Bandarkar,  
#                       Udayan Mohanty, Ailun Wang, Heiko Lammert, Ryan Hayes, 
#                               Jose Onuchic & Paul Whitford
#
#         Copyright (c) 2015,2016,2018,2021,2022,2024 The SMOG development team at
#                    The Center for Theoretical Biological Physics
#                     Rice University and Northeastern University
#
#          SMOG 2, Shadow and OpenSMOG are available at http://smog-server.org
#
#          You can direct questions to info@smog-server.org, or the smog-users forum, 
#          which you can find at https://mailman.rice.edu/mailman/listinfo/smog-users
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#########################################################################################

use strict;
use warnings FATAL => 'all';
&checkForModules;
use XML::Simple;
use templateParser;
use PDB_Bonded;
use PDL;
use mathFunctions;
use setRatios;
use Getopt::Long;
Getopt::Long::Configure("pass_through");
use XML::SAX::ParserFactory;
use XML::Validator::Schema; 
use Scalar::Util qw(looks_like_number);
use smog_common;
use OpenSMOG;
use SMOGglobals;
######################
## GLOBAL VARIABLES ##
######################
our $VERSION;
my $angToNano = 0.1;
my $OUTPUT;
my $help;
our $gen_map;
my $inputPDB="molecule.pdb"; 
my $inputFolder=""; 
my $bifForSCM;
my $userProvidedMap=0;
my $topFile = "";
my $groFile = "";
my $g96File = "";
my $groFile4SCM = "";
my $topFile4SCM = "";
my $ContactFile;
my $shadowFile = "";
my $ndxFile = "";
my $numContacts = 0;
my $coarseFolder = ""; ## Coarse Grain Folder ##
my $AAdefault = 0; 
my $CAdefault = 0;
my $AAGdefault = 0; 
my $centersystem; 
my $boxbuffer=1; 
our $OpenSMOG; 
my $OpenSMOGxml="";
my $CAGdefault = 0;
my $saveSCMorig=0;
my $printversion;
my $ignoreHydrogen=0; #variable that is set when you don't want contact map generation to consider hydrogens
my $DNAME="smog";
my $backup="yes";
my $freecoor;
my $CGstage = 0;
my $nocheck = "no";
my $keep4SCM;
my $extrasfile="";
my $iondeffile="";
my $anyfree;
our %freeangles;
our $CGenabled=0; ## enable coarse-graining
our $setBondtoLimit=0;
our $setContacttoLimit;
our $DeleteShortContact;
our %funtypechecked;
our %presentatomtypes;
our %foundBtype;
our %foundAtype;
our %foundDtype;
our @topFileBuffer;
our @linesInDirectives;
our @linesInDirectivesWithContent;
our $inputArguments=join(' ',@ARGV);
our %Btypespresent;
our %NBtypespresent;
our %PAIRtypespresent;
our %pairtypesused;
our %fTypes;
our %fTypesdefault;
our %fTypesArgNum;
our %OpenSMOGpot;
our $OpenSMOGpothash;
our %directives;
our %directivesatomnumber;
our @directivesList;
our %extraatomtypes;
our %bondParseSeen;
our %angleParseSeen;
our %dihParseSeen;
our %contactParseSeen;
our $normalizevals;
our $SCMbuffer;
my @OSswitchlist;
my $OSref;
#######END GLOBAL DEFS#######
#######MAIN PROGRAM####### 

quit_init();
note_init();

setglobals();

header();

parse_args();

print "Parsing templates files...\n";
# CGstage =0 means that we will not CG at this step
# CGenabled indicates whether CGing will be done, later
# If CGenabled=1 and CGstage=0, then we save any BOND lines for later.
# if both are = 1, then we use the saved BOND lines
parseTemplatesAndPDB($inputFolder,$inputPDB,$CGenabled,$CGstage);
if($CGenabled == 0 || ($CGenabled == 1 && $userProvidedMap == 0)) {
	# either no CG, or CG and need to generate a map
	printBondedTopOutput($inputPDB);
} 

appendDefaults();

# generate contact map
if($userProvidedMap == 0) {
	#use SCM.jar if user doesn't provide a map
	# the 0 indicates this is a top file for use with SCM, only
	my $comments=printTop($topFile4SCM,0);
	generateContactMap($groFile4SCM,$ndxFile,$shadowFile,$topFile4SCM);
}

if(! defined $keep4SCM){
	# this is only used for smog-check
	if(-e $groFile4SCM){ 
		`rm $groFile4SCM`;
	}
	if(-e $topFile4SCM){ 
		`rm $topFile4SCM`;
	}
}

# do CGing, if needed
if($CGenabled == 1) { #Coarse graining, do everything over with new templates
    	clearBifMemory();
	clearPDBMemory();
	# clear OS stuff for the initial AA input
	undef %{$OSref};
	my %OS;
	$OSref   = \%OS;

	undef %presentatomtypes;
	$CGstage = 1;
	print "\nParsing templates for coarse graining...\n";
	$inputFolder = $coarseFolder;
	parseTemplatesAndPDB($coarseFolder,$inputPDB,$CGenabled,$CGstage);
	printBondedTopOutput($inputPDB);
	appendDefaults();

	if(! defined $keep4SCM){
		# this is only used for smog-check
		if(-e $groFile4SCM){ 
			`rm $groFile4SCM`;
		}
		if(-e $topFile4SCM){ 
			`rm $topFile4SCM`;
		}
	}
}

appendContacts($shadowFile,$ContactFile,$userProvidedMap,$saveSCMorig);

my $comments=printTop($topFile);

my $OpenSMOGwritten="";
if (defined $OpenSMOG){
	$OpenSMOGwritten=OpenSMOGwriteXML($OSref,$OpenSMOGxml,$comments);
}

my $cfile;
if($groFile ne ""){
	$cfile=$groFile;
}elsif($g96File ne ""){
	$cfile=$g96File;
}else{
	print "Internal error: Unable to write an output coordinate file.";
	exit;
}

print "\nYour Structure-based Model is ready!\n\nFiles generated: \n\t$topFile\n$OpenSMOGwritten\t$cfile\n\t$ndxFile\n";
	if(!$userProvidedMap) { print "\t$shadowFile\n"; }
	if($CGenabled && !$userProvidedMap) { print "\t$shadowFile.CG\n"; }
	printNotes();
	printCitation();

warnsummary();

###### END OF MAIN PROGRAM ######

######SUBROUTINES######
sub setglobals {
	## this is the array that defines how function names are converted to gromacs function types
	# special cases: 
		# -2 means this is an OpenSMOG-specific function (defined in templates)
		# -1 means used byType routined (e.g. nonbond_params in gromacs)
		# 0 means don't assign an interaction (i.e. "free" terms)
		
	%fTypes = ('bond_harmonic' => '1',
		'bond_bytype' => '-1',
		'bond_type6' => '6',
		'angle_harmonic' => '1',
		'angle_bytype' => '-1',
		'angle_free' => '0',
		'dihedral_cosine'=>'1',
		'dihedral_cosine4'=>'4',
		'dihedral_ncos'=>'1',
		'dihedral_ncos4'=>'4',
		'dihedral_pcos'=>'1',
		'dihedral_pcos4'=>'4',
		'dihedral_harmonic' => '2',
		'dihedral_bytype' => '-1',
		'dihedral_free' => '0',
		'contact_free'=>'0',
		'contact_1'=>'1',
		'contact_2'=>'1',
		'contact_gaussian'=>'6'
		);
	# note, only bonds are properly set in fTypesArgNum.  The rest will be updated later.
	# note: dihedral_cosine and dihedral_ncos are identical.  By default, SMOG uses negative cosine functions.  For back compatibility, we have have left in the old dihedral_cosine, even though there is now dihedral_pcos (positive cosine) and dihedral_ncos (negative cosine)
	%fTypesArgNum = ('bond_harmonic' => '2',
		'bond_bytype' => '0',
		'bond_type6' => '2',
		'angle_harmonic' => '2',
		'angle_bytype' => '0',
		'angle_free' => '0',
		'dihedral_cosine'=>'3',
		'dihedral_cosine4'=>'3',
		'dihedral_ncos'=>'3',
		'dihedral_ncos4'=>'3',
		'dihedral_pcos'=>'3',
		'dihedral_pcos4'=>'3',
		'dihedral_harmonic' => '2',
		'dihedral_bytype' => '0',
		'dihedral_free' => '0',
		'contact_free'=>'0',
		'contact_1'=>'4',
		'contact_2'=>'4',
		'contact_gaussian'=>'4'
		);

        initOSrestrict();
	$OpenSMOGpothash=\%OpenSMOGpot;
	# predefine the mapping of openMM functions for default SMOG 2 potentials
	$OpenSMOGpothash->{contact_1}->{expression}="A/r^N-B/r^M";
	push(@{$OpenSMOGpothash->{contact_1}->{parameters}},"A");
	push(@{$OpenSMOGpothash->{contact_1}->{parameters}},"B");

	$OpenSMOGpothash->{bond_type6}->{expression}="eps*0.5*(r-r0)^2";
	push(@{$OpenSMOGpothash->{bond_type6}->{parameters}},"eps");
	push(@{$OpenSMOGpothash->{bond_type6}->{parameters}},"r0");

	$OpenSMOGpothash->{contact_gaussian}->{expression}="A*((1+a/(A*r^12))*(1-exp(-(r-r0)^2/(2*sigmaG^2)))-1)";
	push(@{$OpenSMOGpothash->{contact_gaussian}->{parameters}},"A");
	push(@{$OpenSMOGpothash->{contact_gaussian}->{parameters}},"r0");
	push(@{$OpenSMOGpothash->{contact_gaussian}->{parameters}},"sigmaG");
	push(@{$OpenSMOGpothash->{contact_gaussian}->{parameters}},"a");

	$OpenSMOGpothash->{contact_free}->{expression}="";


	# dihedrals OpenSMOG potentials
	$OpenSMOGpothash->{dihedral_cosine}->{expression}="weight*(1-cos(multiplicity*(theta-theta0)))";
	push(@{$OpenSMOGpothash->{dihedral_cosine}->{parameters}},"theta0");
	push(@{$OpenSMOGpothash->{dihedral_cosine}->{parameters}},"weight");
	push(@{$OpenSMOGpothash->{dihedral_cosine}->{parameters}},"multiplicity");
	$OpenSMOGpothash->{dihedral_cosine}->{theta0}=0;
	$OpenSMOGpothash->{dihedral_cosine}->{weight}=1;
	push(@OSswitchlist,"dihedral_cosine");

	$OpenSMOGpothash->{dihedral_ncos}->{expression}="weight*(1-cos(multiplicity*theta-theta0))";
	push(@{$OpenSMOGpothash->{dihedral_ncos}->{parameters}},"theta0");
	push(@{$OpenSMOGpothash->{dihedral_ncos}->{parameters}},"weight");
	push(@{$OpenSMOGpothash->{dihedral_ncos}->{parameters}},"multiplicity");
	$OpenSMOGpothash->{dihedral_ncos}->{theta0}=0;
	$OpenSMOGpothash->{dihedral_ncos}->{weight}=1;
	push(@OSswitchlist,"dihedral_ncos");

	$OpenSMOGpothash->{dihedral_pcos}->{expression}="weight*(1+cos(multiplicity*theta-theta0))";
	push(@{$OpenSMOGpothash->{dihedral_pcos}->{parameters}},"theta0");
	push(@{$OpenSMOGpothash->{dihedral_pcos}->{parameters}},"weight");
	push(@{$OpenSMOGpothash->{dihedral_pcos}->{parameters}},"multiplicity");
	$OpenSMOGpothash->{dihedral_pcos}->{theta0}=0;
	$OpenSMOGpothash->{dihedral_pcos}->{weight}=1;
	push(@OSswitchlist,"dihedral_pcos");

	$OpenSMOGpothash->{dihedral_cosine4}->{expression}="weight*(1-cos(multiplicity*(theta-theta0)))";
	push(@{$OpenSMOGpothash->{dihedral_cosine4}->{parameters}},"theta0");
	push(@{$OpenSMOGpothash->{dihedral_cosine4}->{parameters}},"weight");
	push(@{$OpenSMOGpothash->{dihedral_cosine4}->{parameters}},"multiplicity");
	$OpenSMOGpothash->{dihedral_cosine4}->{theta0}=0;
	$OpenSMOGpothash->{dihedral_cosine4}->{weight}=1;
	push(@OSswitchlist,"dihedral_cosine4");

	$OpenSMOGpothash->{dihedral_ncos4}->{expression}="weight*(1-cos(multiplicity*theta-theta0))";
	push(@{$OpenSMOGpothash->{dihedral_ncos4}->{parameters}},"theta0");
	push(@{$OpenSMOGpothash->{dihedral_ncos4}->{parameters}},"weight");
	push(@{$OpenSMOGpothash->{dihedral_ncos4}->{parameters}},"multiplicity");
	$OpenSMOGpothash->{dihedral_ncos4}->{theta0}=0;
	$OpenSMOGpothash->{dihedral_ncos4}->{weight}=1;
	push(@OSswitchlist,"dihedral_ncos4");

	$OpenSMOGpothash->{dihedral_pcos4}->{expression}="weight*(1+cos(multiplicity*theta-theta0))";
	push(@{$OpenSMOGpothash->{dihedral_pcos4}->{parameters}},"theta0");
	push(@{$OpenSMOGpothash->{dihedral_pcos4}->{parameters}},"weight");
	push(@{$OpenSMOGpothash->{dihedral_pcos4}->{parameters}},"multiplicity");
	$OpenSMOGpothash->{dihedral_pcos4}->{theta0}=0;
	$OpenSMOGpothash->{dihedral_pcos4}->{weight}=1;
	push(@OSswitchlist,"dihedral_pcos4");

	$OpenSMOGpothash->{dihedral_harmonic}->{expression}="weight*(0.5*min(dtheta, 2*pi-dtheta)^2); dtheta = abs(theta-theta0); pi = 3.1415926535";
	push(@{$OpenSMOGpothash->{dihedral_harmonic}->{parameters}},"theta0");
	push(@{$OpenSMOGpothash->{dihedral_harmonic}->{parameters}},"weight");
	$OpenSMOGpothash->{dihedral_harmonic}->{theta0}=0;
	$OpenSMOGpothash->{dihedral_harmonic}->{weight}=1;
	push(@OSswitchlist,"dihedral_harmonic");

	## this is the topfile buffer stuff
	%directives = ("comments",1,"defaults",2,"atomtypes",3,"bondtypes",4,"angletypes",5,"dihedraltypes",6,"nonbond_params",7,"moleculetype",8,"atoms",9,"bonds",10,"angles",11,"dihedrals",12,"pairs",13,"exclusions",14,"position_restraints",15,"system",16,"molecules",17);
	# %directivesatomnumber indicates the number of atoms associated with each directive. This is used to make sure that there are no duplicate declarations in the types sections
	%directivesatomnumber = ("atomtypes",1,"bondtypes",2,"angletypes",3,"dihedraltypes",4,"nonbond_params",2);
	@directivesList=("comments","defaults","atomtypes","bondtypes","angletypes","dihedraltypes","nonbond_params","moleculetype","atoms","bonds","angles","dihedrals","pairs","exclusions","position_restraints","system","molecules");
}

sub formatvalues {
	my ($len)=@_;
	my $string="";
	for (my $I=0;$I<$len+1;$I++){
		$string .= " %12.9e";
	}
	$string .= "\n";
	return($string); 
}

sub parse_args {
	## parse command line options ##
	# -o output top file name, default is smog.top
	my $tempcheckoff;
	my $g96on;
	usage() if (@ARGV < 1 || !GetOptions('help|?' => \$help, 
		'o=s' => \$topFile, 
		't=s' => \$inputFolder, 
		'i=s' => \$inputPDB, 
		'g=s' => \$groFile,
		'c=s' => \$ContactFile, 
		'SCMorig' => \$saveSCMorig, 
		's=s' => \$shadowFile, 
		'n=s' => \$ndxFile, 
		'ignH' => \$ignoreHydrogen,  
		'gen_map=s' => \$gen_map,
		'tCG=s' => \$coarseFolder, 
		'CA'=> \$CAdefault, 
		'AA' => \$AAdefault, 
		'CAgaussian'=> \$CAGdefault, 
		'AAgaussian' => \$AAGdefault, 
		'OpenSMOG' => \$OpenSMOG, 
		'OpenSMOGxml=s' => \$OpenSMOGxml, 
		'dname=s' => \$DNAME, 
		'warn=i' => \$maxwarn, 
		'backup=s' => \$backup, 
		'freecoor' => \$freecoor, 
		'center' => \$centersystem, 
		'boxbuffer=f' => \$boxbuffer, 
		'limitbondlength' => \$setBondtoLimit, 
		'limitcontactlength' => \$setContacttoLimit, 
		'deleteshortcontacts' => \$DeleteShortContact, 
		'nocheck'=> \$tempcheckoff,
		'keep4SCM'=> \$keep4SCM,
		'<>' => \&usage, 
		'v' => \$printversion)
	          or defined $help 
	          or !defined $inputPDB 
	          or (!defined $inputFolder  && !defined $coarseFolder));
	
	if($printversion){
		print "Version $VERSION\n";
		exit;
	}
	
	warninfo();
	if(defined $tempcheckoff){
		smog_note("-nocheck was issued. Will not cross-check the templates for consistency in energetics declarations. Use this option at your own risk...");
		$nocheck="yes";
	}

	if(defined $setContacttoLimit && defined $DeleteShortContact){
		smog_quit("Can not use -limitcontactlength and -deleteshortcontacts at the same time.");
	}

	if(defined $OpenSMOG){
		# create the hash ref that we will put data, so that we can dump it into an xml file later
		my %OS;
		$OSref   = \%OS;
	}	

	if(!defined $setContacttoLimit){
		$setContacttoLimit=0;
	}
	if(!defined $DeleteShortContact){
		$DeleteShortContact=0;
	}
	
	if($coarseFolder ne "" and $inputFolder eq ""){
		smog_quit("When using a CG model with -tCG, you must also specify the model to be used when calculating the contact map by invoking the option -t. Check -help for usage information. ");
	}
	
	my $numdefaults=$CAdefault+$AAdefault+$AAGdefault+$CAGdefault;
	if($inputFolder eq "" && $numdefaults==0){
		smog_quit("No model specified. You must use either -t, -AA, or -CA. Try -help for usage information.");
	}
	
	if($coarseFolder ne "") { $CGenabled = 1; }
	
	if($backup ne "yes" and $backup ne "no"){
		smog_quit("Can not understand -backup flag. Usage -backup [yes/no]");
	}elsif($backup eq "no"){
		print "-backup no issued.  Will overwrite any existing output files.\n";
	}
	
	if($numdefaults > 1){
		smog_quit('Can not select more than one default model at a time.');
	}
	if($CAdefault == 1 and defined $ContactFile){
		smog_quit('Can not use -c and -CA options at the same time.');
	}
	if(defined $ContactFile and $CGenabled == 1){
		smog_quit('Can not use -tCG and -c options at the same time.');
	}
	if($CAdefault == 1 and $CGenabled == 1){
		smog_quit('Can not use -tCG and -CA options at the same time.');
	}
	if($CAGdefault == 1 and $CGenabled == 1){
		smog_quit('Can not use -tCG and -CAgaussian options at the same time.');
	}
	if($CAdefault == 1 and $inputFolder ne ""){
		smog_quit('Can not use -CA and -t options at the same time.');
	}
	if($CAGdefault == 1 and $inputFolder ne ""){
		smog_quit('Can not use -CAgaussian and -t options at the same time.');
	}
	
	if($AAdefault == 1 and $inputFolder ne ""){
		smog_quit('Can not use -AA and -t options at the same time.');
	}
	if($AAGdefault == 1 and $inputFolder ne ""){
		smog_quit('Can not use -AAgaussian and -t options at the same time.');
	}
	if($numdefaults and $coarseFolder ne ""){
		smog_quit('Can not use a default model with -tCG.');
	}
	
	if($CAdefault == 1){
		print "\n -CA given. Will use the default Calpha SMOG model provided with the distribution.\n";
		my $SMOGDIR=$ENV{'SMOG_PATH'};
		$inputFolder="$SMOGDIR/SBM_AA";
		$coarseFolder="$SMOGDIR/SBM_calpha";
		print "Will try to use templates found in \n$inputFolder\n and\n$coarseFolder\n\n";
		if(! -d $inputFolder){
			smog_quit("$inputFolder is not a valid template directory.");
		}
		if(! -d $coarseFolder){
			smog_quit("$coarseFolder is not a valid template directory.");
		}
		$CGenabled=1;
	}
	if($AAdefault == 1){
		print "\n-AA given. Will use the default All-Atom SMOG model provided with the distribution.\n";
		my $SMOGDIR=$ENV{'SMOG_PATH'};
		$inputFolder="$SMOGDIR/SBM_AA";
		print "Will try to use templates found in \n$inputFolder\n\n";
		if(! -d $inputFolder){
			smog_quit("$inputFolder is not a valid template directory.");
		}
	}
	
	if($CAGdefault == 1){
		print "\n -CAgaussian given. Will use the default Calpha SMOG model with gaussian contacts, as provided with the distribution.\n";
		my $SMOGDIR=$ENV{'SMOG_PATH'};
		$inputFolder="$SMOGDIR/SBM_AA";
		$coarseFolder="$SMOGDIR/SBM_calpha+gaussian";
		print "Will try to use templates found in \n$inputFolder\n and\n$coarseFolder\n\n";
		if(! -d $inputFolder){
			smog_quit("$inputFolder is not a valid template directory.");
		}
		if(! -d $coarseFolder){
			smog_quit("$coarseFolder is not a valid template directory.");
		}
		$CGenabled=1;
	}
	if($AAGdefault == 1){
		print "\n-AAgaussian given. Will use the default All-Atom SMOG model with gaussian contacts, as provided with the distribution.\n";
		my $SMOGDIR=$ENV{'SMOG_PATH'};
		$inputFolder="$SMOGDIR/SBM_AA+gaussian";
		print "Will try to use templates found in \n$inputFolder\n\n";
		if(! -d $inputFolder){
			smog_quit("$inputFolder is not a valid template directory.");
		}
	}
	
	if(defined $gen_map) {
		smog_quit("Option -gen_map moved to smog_adjustPDB");
	}
	
	# if a contact file is provided, then don't calculate contacts
	if(defined $ContactFile){
		$userProvidedMap=1;
	}
	
	## Ensure we only write out files with gromacs-compatible suffices
	if($topFile eq ""){$topFile=$DNAME};
	if($groFile eq ""){
		$groFile=$DNAME
	}
	$groFile4SCM=$groFile . "4SCM.gro";
	if(defined $g96on){
		$groFile =~ s/\.gro$/\.g96/g;
		$g96File = $groFile;
		$groFile="";
	}


	if($OpenSMOGxml eq ""){$OpenSMOGxml=$DNAME};
	$topFile4SCM=$topFile . "4SCM.top";
	if($shadowFile eq ""){$shadowFile=$DNAME};
	if($ndxFile eq ""){$ndxFile=$DNAME};
	
	$topFile=checksuffix($topFile,".top");

	if($groFile ne ""){
		$groFile=checksuffix($groFile,".gro");
	}elsif($g96File ne ""){
		$g96File=checksuffix($g96File,".g96");
	}else{
		print "Internal error handing gro name\n";
		exit;
	}

	$shadowFile=checksuffix($shadowFile,".contacts");
	$ndxFile=checksuffix($ndxFile,".ndx");
	$OpenSMOGxml=checksuffix($OpenSMOGxml,".xml");
	
	
	## check if files exist
	# things we don't want to overwrite
	if($backup eq "yes"){
		foreach my $filen($topFile, $g96File, $groFile, $groFile4SCM, $shadowFile, $ndxFile,$OpenSMOGxml){
			checkalreadyexists($filen);
		}
	}
	 
	# files we will read
	foreach my $filen($inputPDB,$ContactFile){
		if(defined $filen  && ! -f $filen){
			smog_quit("Can't find file $filen !! ");
		}
	}
	
	# directories we will access
	foreach my $filen($inputFolder,$coarseFolder){
		if($filen ne "" && ! -d $filen){
			smog_quit ("Can't find directory $filen !! ");
		}
	}

	if($CGenabled == 0) {
		print "\n*****************************************************\n";
		print   "******* ALL-ATOM SMOG MODEL WILL BE GENERATED *******";
		print "\n*****************************************************\n";
	} else {
		print "\n*****************************************************\n";
		print   "**** COARSE-GRAINED SMOG MODEL WILL BE GENERATED ****";
		print "\n*****************************************************\n";
	        print <<EOT;

When SMOG 2 performs coarse graining, the system is 
first processed at the all-atom level. This is necessary 
to determine which residue pairs should have native
contacts included in the coarse-grained model. 
Accordingly, you will see a sequence of messages that
describe:
- Processing of the all-atom model: This will include 
    information about the all-atom SMOG template files
    and possible warnings about the atomic structure.
- Generation of the contact map
- Generation of the coarse-grained model: This stage
    will report information about the coarse-grained
    template files and possible warnings/errors about
    the structure, in terms of the coarse-grained
    model parameters. 

EOT
	}
}

sub printTop {
	my ($topFile,$gen4SCM) = @_;
	open($OUTPUT, ">$topFile");
	my $i;
	my $directive;
	my $comments="";
	foreach $directive (@directivesList) { #order of list defines order in top
		if($directive eq "comments") { 
			foreach $i (1 .. scalar @{$topFileBuffer[$directives{$directive}]}-1) {
				my $nextcomment = $topFileBuffer[$directives{$directive}][$i][0];
				$nextcomment =~ s/^\s*;\s*//; #remove all semicolons at the beginning
				$nextcomment =~ s/\\n;*/\n; /; #add requested newlines 
				print $OUTPUT "; ".$nextcomment; #append semicolon and space before each comment
				$comments .= "; ".$nextcomment; #append semicolon and space before each comment
			}
		}elsif(defined $gen4SCM and exists $SCMbuffer->{$directive}){
			# we are generating a map for SCM, which sometimes needs
			# information that we have stored in the OpenSMOG XML file
			# In those cases, we need to write out a complete list of information into the temporary top used for SCM.
			foreach $i (0 .. scalar @{$SCMbuffer->{$directive}}-1) { 
				print $OUTPUT ${$SCMbuffer->{$directive}}[$i];
			}
	
		}elsif($linesInDirectivesWithContent[$directives{$directive}] > 1) { # print if the section has more than a header and comments
			foreach $i (0 .. scalar @{$topFileBuffer[$directives{$directive}]}-1) { 
				print $OUTPUT $topFileBuffer[$directives{$directive}][$i][0];
			}
		}
	}
	close($OUTPUT);
    	return($comments);

}

# utility method to set all the initial directive comments
sub initializeDirectives {
	for (keys %directives) { 
		$linesInDirectives[$directives{$_}]=0; 
		$linesInDirectivesWithContent[$directives{$_}]=0; 
		#need this because we are going to output a top without pairs but want it to not die when it is not initialized
		push @{$topFileBuffer[$directives{$_}][$linesInDirectives[$directives{$_}]++]}, ""; 
	}
	my $hostdate=printhostdate();
	my $software;
	if(defined $OpenSMOG){
		# this is for openMM, only
		$software="OpenMM";
	}else{
		$software="GROMACS, NAMD, or OpenMM";
	}
	addToTop("comments", "Structure-based \"SMOG\" model for use with $software\n");
	addToTop("comments", "Generated by the SMOG tool version $VERSION\n");
	addToTop("comments", "$hostdate");
	addToTop("comments", "SMOG2 called with the following flags: $inputArguments\n");	
        my $gitver=getgitver;
        if($gitver ne ""){
                addToTop("comments","THIS VERSION OF SMOG IS FROM A GIT REPO. COMMIT NUMBER\n");
		addToTop("comments","$gitver\n");
        }
	addToTop("defaults", "\n[ defaults ]\n");
	addToTop("bonds","\n[ bonds ]\n");
	addToTop("bonds",";ai\taj\tfunc\t r0(nm)\t         Kb\n");
	addToTop("angles","\n[ angles ]\n");
	addToTop("angles",";ai\taj\tak\tfunc\t th0(deg)        Ka\n");
  	addToTop("dihedrals","\n[ dihedrals ]\n");
	addToSCMbuffer("dihedrals","\n[ dihedrals ]\n");
  	addToTop("dihedrals",";ai\taj\tak\tal\tfunc\t phi0(deg)       Kd              mult\n");
	addToTop("pairs","\n[ pairs ]\n");
	addToTop("exclusions","\n[ exclusions ]\n");
	addToTop("exclusions",";ai	aj\n");
	addToTop("atomtypes","\n[ atomtypes ] \n");
	addToTop("bondtypes","\n[ bondtypes ] \n");
	addToTop("angletypes","\n[ angletypes ] \n");
	addToTop("dihedraltypes","\n[ dihedraltypes ] \n");
	addToTop("nonbond_params","\n[ nonbond_params ]\n");
	if($interactions->{"gmx-combination-rule"}==1){
		addToTop("nonbond_params",";ai     aj    func    c6       c12\n");
		addToTop("atomtypes","; name  mass     charge    ptype c6            c12\n");
		addToTop("pairs",";ai\taj\ttype\t A               B\n");
	}elsif($interactions->{"gmx-combination-rule"}==2){
		addToTop("nonbond_params",";ai     aj    func    sigma       epsilon\n");
		addToTop("atomtypes","; name  mass     charge    ptype  sigma   epsilon\n");
		addToTop("pairs",";ai\taj\ttype\tsigma\t\tepsilon\n");
	}
	addToTop("position_restraints","\n[ position_restraints ]\n");
	addToTop("position_restraints",";ai    func    kx    ky   kz\n");
	addToTop("atoms","\n[ atoms ]\n");
	addToTop("atoms",";  nr        type   resnr residue atom   cgnr   charge\n");
	addToTop("moleculetype","\n[ moleculetype ]\n");
	my $molname=$interactions->{"molname"};
	my $nrexcl=$interactions->{"nrexcl"};
	addToTop("moleculetype","; name       nrexcl\n");
	addToTop("moleculetype"," $molname    $nrexcl\n");
	addToTop("system","\n[ system ]\n");
	addToTop("system","; name\n");
	addToTop("system","  $molname\n");
	addToTop("molecules","\n[ molecules ]\n");
	addToTop("molecules","; name            #molec\n");
	addToTop("molecules","  $molname   1\n");
}

#adds something to the topfile at the bottom of a directive
sub addToTop {
	my($directive,$stuff,$OSdir) = @_;
		
	if($directive =~ m/^OpenSMOG$/){
		# if $directive is OpenSMOG, then $stuff is the address of the array that contains the following information: i, j, [k, j,] interaction type, function name, @parameters (in the order found in $OSref->{$type}->[0]->{$name}->[0]->{parameters} array)
		if(! defined $OSdir){
			smog_quit("internal error: OS 1");
		}elsif( $OSdir eq "contact" or $OSdir eq "dihedral"){
			AddInteractionOShash($OSdir,$OSref,$stuff);
		}else{
			smog_quit("internal error: OS 2");
		}

        }else{
		my $dir=$directives{$directive};
		$linesInDirectivesWithContent[$dir]+= hascontent($stuff);
		push  @{$topFileBuffer[$dir][$linesInDirectives[$dir]++]}, $stuff;
	}
}

#adds something to the topfile at the bottom of a directive
sub addToSCMbuffer{
	my($directive,$stuff) = @_;
	
	if(hascontent($stuff) == 1){
		push  @{$SCMbuffer->{$directive}}, $stuff;
	}
}

sub addToSCMbufferArr{
	# same as addToSCMbuffer, except the input is an array
	my($directive,$stuff) = @_;
	my $line="";
	my @tmparr=@{$stuff};
	for(my $I=0;$I<4; $I++){
		my $n=$tmparr[$I];
		$line .= "$n ";
	}
	#dummy values for the type, angles, weight and multiplicity, since we are never going to use that info.
	$line .= "1 1 1 1\n";
	if(hascontent($line) == 1){
		push  @{$SCMbuffer->{$directive}}, $line;
	}
}

#read file "extras" in template directory
sub addExtras {
	my ($filename) = @_;
	my %foundNBe;
	my $customerror="If you are using custom templates, then this definition may be intentional. Otherwise, there may be a mistake in your extras file.";
	if( -e $filename){
		print "\nAdding extras information\n\n";
		open(EXTRA,"$filename");
		my $line = "";
		my $directive;my $stuff;my @tokens;
		while($line = <EXTRA>)
		{
			my ($A,$B)=checkcomment($line);
			if($A eq ""){next;}  # skip the line if it is only a comment
		    	@tokens = split('<',$line);
			$directive = trim($tokens[0]);
			$stuff = trim($tokens[1]);
			# check that nonbonded params are only added if the atom types are present
			my $writetoXML="no";

			if($directive eq "atomtypes"){
		    		my @ltokens = split('<',$A);
				if(@ltokens ==1){
					# if it is just a comment, save.
					addToTop($directive,$stuff."\n");
					next;	
				}
				my $lstuff= trim($ltokens[1]);
				my @entries = split(/\s+/,$lstuff);
				if(defined $presentatomtypes{$entries[0]} ){
					# this atomtype is found in the system. store the extra info
					$extraatomtypes{$entries[0]}=$lstuff;
				}
				next;
			}

			if($directive eq "nonbond_params"){
		    		my @ltokens = split('<',$A);
				if(@ltokens ==1){
					# if it is just a comment, save.
					addToTop($directive,$stuff."\n");
					next;	
				}
				my $lstuff= trim($ltokens[1]);
				my @tarray=split(/\s+/,$lstuff);
				if(exists $interactions->{"CustomNonBonded"}){
					# do checks for custom potentials
					if(exists $interactions->{"CustomNonBonded"}->{"parameters"}){
						if(@tarray -3 != @{$interactions->{"CustomNonBonded"}->{"parameters"}}){
							my $tarray=scalar(@tarray)-3;
							my $parray=scalar(@{$interactions->{"CustomNonBonded"}->{"parameters"}});
							smog_quit("A custom potential is being used, and $parray parameters are expected (as defined in the .nb file), but $tarray parameters found on a nonbond_params entry of the extras file. Problematic line:$line");
						}
					}else{
						smog_quit("A custom potential is being used for nonbonded terms, and your extras file defines nonbond_params. However, the parameter list for your custom potential is not given in the .nb file. Your extras file may be ok, but SMOG 2 can\'t determine if you have the correct number of parameters listed. It is strongly recommended that you give the parameter list, in order to avoid this warning.",0)	
					}
					if(defined $OpenSMOG){
						# Since we are using OpenSMOG with a Custom Potential, then we don't want 
						# to write the nonbond_params in the top file. Instead, we want to add it to 
						# the OpenSMOG hash, so that it will be written to the output XML
						$writetoXML="yes"; #ensures that we don't write to top
						
						if(!defined $presentatomtypes{$tarray[0]} || !defined $presentatomtypes{$tarray[1]}){
							next;
						}	
						# now, populate hash. remove type, since that is not used by OpenSMOG 
						splice(@tarray,2,1);
						AddNonbondOShash($OSref,\@tarray);
					}
				}else{
					# do standard gromacs format checks
					unless($tarray[2]  =~ /^[12]$/){
						smog_quit("In extras file, only nonbond_param types 1 and 2 are supported (default Gromacs options), unless a CustomNonBonded is defined in the .nb file. $customerror Offending line:$line");
					}
					
					if($tarray[2]==2){
						smog_note("Nonbond function type 2 is defined in extras file. This has not been tested by the SMOG team. It may work, but you should consider any such applications as experimental.");
					}
					if($tarray[2]==1 && @tarray!=5){
						smog_quit("In extras file, nonbond_param defined with nbtype 1. Must have 5 parameters. $customerror Offending line:$line",0);
					}
				}
				if(!defined $presentatomtypes{$tarray[0]} || !defined $presentatomtypes{$tarray[1]}){
					next;
				}	
				# since they are both defined, we will keep a record of them.
				my $f;
				if($tarray[0] lt $tarray[1]){
					$f = $tarray[0] . "-" . $tarray[1];
				}else{
					$f = $tarray[1] . "-" . $tarray[0];
				}
				$foundNBe{$f}=1;
			}
			if($directive eq "bondtypes"){
		    		my @ltokens = split('<',$A);
				if(@ltokens ==1){
					# if it is just a comment, save.
					addToTop($directive,$stuff."\n");
					next;	
				}
				my $lstuff= trim($ltokens[1]);
				my @tarray=split(/\s+/,$lstuff);
				if(@tarray < 5 ){
					smog_quit("bondtypes defined in extras file, but too few parameters are given. $customerror Offending line:$line",0);
				}
				unless($tarray[2]  =~ /^[1-9]$|^10$/){
					smog_quit("In extras file, only bondtypes types 1-10 are supported. $customerror Offending line:$line",0);
				}
				if($tarray[2]==1 && @tarray!=5){
					smog_quit("In extras file, bondtypes defined with nbtype 1. Must have 5 parameters. $customerror Offending line:$line",0);
				}
				unless(defined $presentatomtypes{$tarray[0]} &&  defined $presentatomtypes{$tarray[1]}){
					next;
				}	
				# since they are both defined, we will keep a record of them.
				# save the type hash
				my @taa=@tarray[2..4];
				$foundBtype{"$tarray[0]-$tarray[1]"}=\@taa;
				$foundBtype{"$tarray[1]-$tarray[0]"}=\@taa;
			}
			if($directive eq "angletypes"){
		    		my @ltokens = split('<',$A);
				if(@ltokens ==1){
					# if it is just a comment, save.
					addToTop($directive,$stuff."\n");
					next;	
				}
				my $lstuff= trim($ltokens[1]);
				my @tarray=split(/\s+/,$lstuff);
				if(@tarray < 6 ){
					smog_quit("angletypes defined in extras file, but too few parameters are given. $customerror Offending line:$line",0);
				}
				unless($tarray[3]  =~ /^[1-6]$|^8$|^10$/){
					smog_quit("In extras file, only angletypes types 1-6, 8 and 10 are supported. $customerror Offending line:$line",0);
				}
				if($tarray[3]==1 && @tarray!=6){
					smog_quit("In extras file, angletypes defined with nbtype 1. Must have 6 parameters. $customerror Offending line:$line",0);
				}
				unless(defined $presentatomtypes{$tarray[0]} && defined $presentatomtypes{$tarray[1]} && defined $presentatomtypes{$tarray[2]}){
					next;
				}	
				# since they are both defined, we will keep a record of them.

				my @taa=@tarray[3..5];
				$foundAtype{"$tarray[0]-$tarray[1]-$tarray[2]"}=\@taa;
				$foundAtype{"$tarray[2]-$tarray[1]-$tarray[0]"}=\@taa;
			}
			if($directive eq "dihedraltypes"){
		    		my @ltokens = split('<',$A);
				if(@ltokens ==1){
					# if it is just a comment, save.
					addToTop($directive,$stuff."\n");
					next;	
				}
				my $lstuff= trim($ltokens[1]);
				my @tarray=split(/\s+/,$lstuff);
				if(@tarray < 7 ){
					smog_quit("dihedraltypes defined in extras file, but too few parameters are given. $customerror Offending line:$line",0);
				}
				unless($tarray[4]  =~ /^[1-5]$|^[89]$|^1[01]$/){
					smog_quit("In extras file, only angletypes types 1-5, 8, 9, 10 and 11 are supported. $customerror Offending line:$line",0);
				}
				if((!defined $presentatomtypes{$tarray[0]} && $tarray[0] ne "X") || (!defined $presentatomtypes{$tarray[1]} && $tarray[1] ne "X") || (!defined $presentatomtypes{$tarray[2]} && $tarray[2] ne "X") || (!defined $presentatomtypes{$tarray[3]} && $tarray[3] ne "X") ){
					next;
				}	
				# since they are both defined, we will keep a record of them.
				$foundDtype{"$tarray[0]-$tarray[1]-$tarray[2]-$tarray[3]"}=1;
				$foundDtype{"$tarray[3]-$tarray[2]-$tarray[1]-$tarray[0]"}=1;
			}
			if($writetoXML eq "yes"){
				next;
			}elsif($writetoXML ne "no"){
				smog_quit("Internal error 1. Contact SMOG team.");
			}else{
				addToTop($directive,$stuff."\n");
			}
		}
	}
	if(exists $interactions->{"nbfunc"} && $interactions->{"nbfunc"} > 2){
	# types gt 2 are not defined for official versions of gromacs. We have added routines in a SMOG-supported version, that allow for more flexible definitions to be used. However, since they do not support combination rules, we restrict SMOG2, so that all possible nonbond_params are defined in the extras file. In the future, we may relax this condition.
		foreach my $t1(keys %presentatomtypes){	
			foreach my $t2(keys %presentatomtypes){	
				my $f;
				if($t1 lt $t2){
					$f = $t1 . "-" . $t2;
				}else{
					$f = $t2 . "-" . $t1;
				}
				if(!exists $foundNBe{$f}){
					smog_quit("nbtype $interactions->{\"nbfunc\"} is being used, yet not all possible nonbond_params are given in extras file. Did not find params for atomtype pair $f");
				}
			}
		}
	}
}

sub checkExtras {
	my ($filename) = @_;
	open(EXTRA,"$filename");
	my $line = "";
	my $directive;
	my $stuff;
	my @tokens;
	my %foundtypes;
	while($line = <EXTRA>)
	{
		my ($A,$B)=checkcomment($line);
		if($A eq ""){next;}  # skip the line if it is only a comment
		if($line !~ m/^(\s+)?\w+(\s+)?</){
			smog_quit("extras file: $filename contains a line that does not begin with a directive name followed by '<'. Offending line:\n $line");
		}
	    	@tokens = split('<',$line);
		if(scalar @tokens > 2) {
			smog_quit("extras file: $filename contains more than one instance of character '<'. Offending line:\n $line");
		}
		$directive = trim($tokens[0]);
		if(!exists $directives{$directive}) {
			smog_quit("extras file: $filename has a non-valid directive \"$directive\". Check for typos or add directive to directivesList in src/smogv2.");			
		}
		if (exists $directivesatomnumber{$directive}){
			my $natoms=$directivesatomnumber{$directive};
			# get atom names
			my $entry = trim($tokens[1]);
			my @list=split(/\s+/,$entry);
			my $forward="";
			my $backward="";
			for(my $I=0;$I<$natoms;$I++){
				$forward = "$forward " .  $list[$I];
				$backward = $list[$I] . " $backward";
			}
			if(exists ${$foundtypes{$directive}}->{$forward} && $directive ne "dihedraltypes"){
				smog_quit("Found duplicate $directive definition in the extras file.\n\tDuplicate set of atom types:$forward");
			}
			${$foundtypes{$directive}}->{$forward}=1;
			${$foundtypes{$directive}}->{$backward}=1;
			# check if hash element assigned
			# add to hash
		}
	}
}

# Combined bond calculation,sorting, and printing
sub printOrderedBonds
{

	my($bondFunctHandle1,$whichPDL1,$bondHandle2,$isBOND,$whichPDL2,$indexhandle,$allatoms,$bondvectors) = @_;
	my @bondCache; ## CACHE BONDS TO ORDER

	## Cache Bonds ##
	calculateBonds1($bondFunctHandle1,$whichPDL1,\@bondCache,$indexhandle,$allatoms,$bondvectors);
	calculateBonds2($bondHandle2,$isBOND,$whichPDL2,\@bondCache,$indexhandle,$allatoms,$bondvectors);
	## Sort bonds by i then j ## 
	@bondCache = sort {($a->{"i"} <=> $b->{"i"}) || ($a->{"j"} <=> $b->{"j"}) } @bondCache;

	## Print our sorted bonds ##
	my %bfound;
	my %blist;
	foreach my $p(@bondCache)
	{
		addToTop("bonds",$p->{"v"});
		my $i=$p->{"i"};
		my $j=$p->{"j"};
		$blist{"$i $j"}=0;	
		$blist{"$j $i"}=0;	
		if(exists $bfound{"$i-$j"}){
			my $def1=$p->{"v"};
			my $def2=$bfound{"$i $j"};
			smog_quit("Found duplicate bond definitions for atom pair $i-$j. Generally, this is due to a mistake, since there is no reason to define two bonds between the same atoms. Found the following parameters assigned for this bond in the top file:\n$def1\n$def2",1);	
		}
		$bfound{"$i $j"}=$p->{"v"};
	}
	if(defined $OpenSMOG && $interactions->{"nrexcl"} >=1){
		%excludebonded=%blist;
	}
}

# call  calculateBondsHelper1() for each residue defined in templates
sub calculateBonds1
{
print "Setting intra-residue bonds distances\n";
	my($bondFunctHandle,$whichPDL,$bondCache,$indexhandle,$allatoms,$bondvectors) = @_;
	foreach my $res(keys %{$bondFunctHandle}){
	       if(!exists $whichPDL->{$res}){next;}
	       calculateBondsHelper1($bondFunctHandle->{$res},$whichPDL->{$res},$bondCache,$indexhandle,$allatoms,$bondvectors);
	}
}

#call connCalculateBondsHelper() for each chain in PDB
sub calculateBonds2
{
	my($bondHandle,$isBOND,$whichPDL,$bondCache,$indexhandle,$allatoms,$bondvectors) = @_;
	my %isBOND=%{$isBOND};
	print "Setting inter-residue bonds for:\n";
	foreach my $chain(sort { $a <=> $b } keys %{$bondHandle})
	{
		if(exists $isBOND{$chain}){
			print "\tuser-defined bond $isBOND{$chain}...\n";
		
		}else{
			my $chainn=$chain+1;
			print "\tchain $chainn...\n";
		}
		calculateBondsHelper2($bondHandle->{$chain},$whichPDL->{$chain},$bondCache,$indexhandle,$allatoms,$bondvectors);
	
	}
}

sub calculateBondsHelper1
{
	my($bondHash,$inputPDL,$bondCache,$indexhandle,$allatoms,$bondvectors) = @_;
	my $bondArr = $bondHash->{"bonds"};
	my $bondFunc =$bondHash->{"functions"};
	my $bondIndex = 0;
	foreach my $bonds(@{$bondArr})
	{
	       my ($atomOne,$atomTwo) = split("-",$bonds);
	       my $outer = slice($inputPDL,"0:2,$atomOne,:")-slice($inputPDL,"0:2,$atomTwo,:");
	       my @bondList = (sqrt(inner($outer,$outer))*$angToNano)->flat()->list();
	       my @indexList1 = slice($inputPDL,"3:3,$atomOne,:")->flat()->list();
	       my @indexList2 = slice($inputPDL,"3:3,$atomTwo,:")->flat()->list();
	       my @vecarr = $outer->flat()->list();
	       for(my $i=0;$i<scalar(@bondList);$i++)
	       {
			my $I1=$indexList1[$i];
			my $I2=$indexList2[$i];
			my $normv=norm(pdl($vecarr[3*$i], $vecarr[3*$i+1], $vecarr[3*$i+2]));
			$bondvectors->{"$I1-$I2"}=$normv;
			$bondvectors->{"$I2-$I1"}=-$normv;
			my $val=bondOutput($bondFunc->[$bondIndex],$I1,$I2,$bondList[$i],$indexhandle,$allatoms);
			if(!$val){next;}
			# i,j are meta data
	 		push @{$bondCache}, {'i' => $I1,'j' => $I2, 'v' => $val};
		}
	       	$bondIndex++;
	
	}
}

sub calculateBondsHelper2
{
	my($bondInfo,$inputPDL,$bondCache,$indexhandle,$allatoms,$bondvectors) = @_;
	my $size = $bondInfo->dim(1);

	for(my $i=0;$i<$size;$i++)
	{
		my $atomOne = sclr(slice($bondInfo,"0:0,$i:$i"));
		my $atomTwo = sclr(slice($bondInfo,"1:1,$i:$i")); 
		my $func = sclr(slice($bondInfo,"2:2,$i:$i"));
		my $outer = slice($inputPDL,"0:2,$atomOne,:")-slice($inputPDL,"0:2,$atomTwo,:");
		my $output = sclr(sqrt(inner($outer,$outer))*$angToNano);
		$atomOne = sclr(slice($inputPDL,"3:3,$atomOne,:"));
		$atomTwo = sclr(slice($inputPDL,"3:3,$atomTwo,:"));
		$bondvectors->{"$atomOne-$atomTwo"}=norm($outer);
		$bondvectors->{"$atomTwo-$atomOne"}=-norm($outer);
		my $val=bondOutput(intToFunc("bonds",$func,""),$atomOne, $atomTwo,$output,$indexhandle,$allatoms);
		if(!$val){next;}
		push @{$bondCache}, {'i' => $atomOne,'j' => $atomTwo, 'v' => $val};
	}
}

# Convert internal bond function format to gromacs function format,
sub bondOutput
{
	my($inputFunc,$i,$j,$values,$indexhandle,$allatoms) = @_;
	$inputFunc = trim($inputFunc);
	## If $input contains a + ##
	my @funcs = split(/\+/,$inputFunc); ## split combination of functions
	my $outputString="";
	my @paramArr;
	my $fType=""; my $formattedString;
	       ## Parse each part of the function ##
	foreach my $fun(@funcs){
		($fType,@paramArr) = bondFuncParser($fun);
		## $paramArr[0] is bond length
		if($fType == -1){
			# this mean bond_bytype was used
			# don't write distances or strengths. Make gromacs use bondtype
			# since we are not writing a distance, let's check and make sure this pair has a bondtype provided
			my $tmtype=checkbondtype($i,$j,$allatoms);
			my @tmtype=@{$tmtype};
			my $type=$tmtype[0];
			$formattedString = sprintf("%d\t%d",$i,$j);
			$outputString .= $formattedString;
			if(defined $OpenSMOG && $type > 0){
				#openMM requires that the function type is listed, even if relying on bondtype
				$outputString .= sprintf("\t%d\n",$type);
			}else{
				$outputString .= "\n";
			}
			if(abs($tmtype[1]-$values)/$tmtype[1] > 0.1){
				my $i1=$indexhandle->{$i};
				my $j1=$indexhandle->{$j};
				my $DIST=int($values*10000)/10000.0;
				smog_note("Distance of $DIST nm calculated for atom pair $i $j (gro indices.  Or, lines $i1 and $j1 of PDB file). This differs by more than 10 percent from the value explicitly given in the templates/extras ($tmtype[1]). This may mean there is something strange with your structure.");
			}
      
 		}else{
			# by default, assume we will replace and evaluate the distance.
			my $dosub=0;
			if($paramArr[0] !~ m/\?/){
				# nothing to sub.  Just use the value given in the .b file
				$dosub=1;
			}
			$paramArr[0]=evalsub($paramArr[0],$values);
			if($dosub==1){
				if(abs($paramArr[0]-$values)/$paramArr[0] > 0.1){
					my $i1=$indexhandle->{$i};
					my $j1=$indexhandle->{$j};
					my $DIST=int($values*10000)/10000.0;
					smog_note("Distance of $DIST nm calculated for atom pair $i $j (gro indices.  Or, lines $i1 and $j1 of PDB file). This differs by more than 10 percent from the value explicitly given in the templates ($paramArr[0]). This may mean there is something strange with your structure.");
				}
			}elsif($values < $interactionThreshold->{"bonds"}->{"shortBond"}
                        || $values > $interactionThreshold->{"bonds"}->{"longBond"}){
        		## Check bonds threshold ##
				#note, only reset the distance and/or check it, if the templates don't define a specific value (i.e. $dosub==0)
				my $DIST=int($values*10000)/10000.0;
				if($setBondtoLimit){
					if(!exists ${$indexhandle}{$i} || !exists ${$indexhandle}{$j}){
						smog_quit("Internal error 2.  Please inform smog team");
					}
					my $i1=$indexhandle->{$i};
					my $j1=$indexhandle->{$j};
	 				if($paramArr[0] < $interactionThreshold->{"bonds"}->{"shortBond"}){
	  					$paramArr[0]=$interactionThreshold->{"bonds"}->{"shortBond"};
	 				}elsif($paramArr[0] > $interactionThreshold->{"bonds"}->{"longBond"}){
	  					$paramArr[0]=$interactionThreshold->{"bonds"}->{"longBond"};
	 				}
					smog_note("Distance of $DIST nm calculated for atom pair $i $j (gro indices.  Or, lines $i1 and $j1 of PDB file). This is outside of bond threshold range. -limitbondlength is being used, will set length to: $paramArr[0]");
				}else{
					if(!exists ${$indexhandle}{$i} || !exists ${$indexhandle}{$j}){
						smog_quit("Internal error 3.  Please inform smog team");
					}
					my $i1=$indexhandle->{$i};
					my $j1=$indexhandle->{$j};
					smog_quit("Distance of $DIST nm calculated for atom pair $i $j (gro indices.  Or, lines $i1 and $j1 of PDB file). This is outside of bond threshold range.");
				}
        		}	
## Format output <i j function p1 p2 ... pn>
			my $paramFormat=formatvalues($#paramArr);
			$formattedString = sprintf("%d\t%d\t%d\t$paramFormat",$i,$j,$fType,@paramArr);
			$outputString = "$outputString$formattedString";
       		}
	}
	return $outputString;
}

sub checkbondtype
{
	my ($i,$j,$allatoms)=@_;
	my $found=0;
	# only check that the pair has a bondtype, if the hash is defined
	if($allatoms ne "0"){
		my $typei=$allatoms->{$i}->[0];
		my $typej=$allatoms->{$j}->[0];
		foreach my $I("X",$typei)
		{
			foreach my $J("X",$typej)
			{
				my $nm="$I-$J";
				if(defined $foundBtype{$nm})
				{
					return $foundBtype{$nm};
				}
			}
		}
		if($found ==0){
			smog_quit("Default bond interaction not provided for pair $i-$j (types $typei and $typej)");
		}
	}
}

sub checkangletype
{
	my ($i,$j,$k,$allatoms)=@_;
	my $found=0;
	# only check that the pair has a bondtype, if the hash is defined
	my $typei=$allatoms->{$i}->[0];
	my $typej=$allatoms->{$j}->[0];
	my $typek=$allatoms->{$k}->[0];
	foreach my $I("X",$typei)
	{
		foreach my $J("X",$typej)
		{
			foreach my $K("X",$typek)
			{
				my $nm="$I-$J-$K";
				if(defined $foundAtype{$nm})
				{
					return $foundAtype{$nm};
				}
			}
		}
	}
	if($found ==0){
		smog_quit("Default angle interaction not provided for pair $i-$j-$k (types $typei, $typej, $typek)");
	}
}

sub checkdihedraltype
{
	my ($i,$j,$k,,$l,$allatoms)=@_;
	# only check that the pair has a bondtype, if the hash is defined
	my $typei=$allatoms->{$i}->[0];
	my $typej=$allatoms->{$j}->[0];
	my $typek=$allatoms->{$k}->[0];
	my $typel=$allatoms->{$l}->[0];
	my $found=0;
	foreach my $I("X",$typei)
	{
		foreach my $J("X",$typej)
		{
			foreach my $K("X",$typek)
			{
				foreach my $L("X",$typel)
				{
					my $nm="$I-$J-$K-$L";
					if(defined $foundDtype{$nm})
					{
						return $foundDtype{$nm};
					}
				}
			}
		}
	}
	if($found ==0){
		smog_quit("Default dihedral interaction not provided for pair $i-$j-$k-$l (types $typei, $typej, $typek, $typel)");
	}
}

# Given a user defined function, parse values
sub bondFuncParser
{
	my($bondFunc) = @_;
	my $fType;my @paramArr;my $directive;
	my $funcName = ""; my $params = "";
	if(exists $bondParseSeen{$bondFunc}{"fType"}){
		# if we have parsed this before, just write it.  Don't mess with everything else.
		return ($bondParseSeen{$bondFunc}{"fType"},@{$bondParseSeen{$bondFunc}{"paramArr"}});
	}

 	($bondFunc =~ /^([^(]+)\((.*)\)$/);
	$funcName = $1;
	$params = $2;
	($fType,$directive) = returnFunction($funcName); ## Obtain Gromacs function type
	$params =~ s/\s+//g; 
	@paramArr = split(",",$params); ## Parse all parameters
	$bondParseSeen{$bondFunc}{"fType"}=$fType;
	$bondParseSeen{$bondFunc}{"paramArr"}=\@paramArr;
	return ($fType,@paramArr);
}

# Combined bond calculation,sorting, and printing
sub printOrderedAngles
{
	my($AngleData,$isBOND,$bondPDL,$indexhandle,$allatoms,$bondvectors) = @_;
	my @angleCache; ## CACHE BONDS TO ORDER

	## Cache Bonds ##
	CalculateAngles($AngleData,$isBOND,$bondPDL,\@angleCache,$indexhandle,$allatoms,$bondvectors);

	## Sort angles by i,j then k ## 
	@angleCache = sort {($a->{"i"} <=> $b->{"i"}) || ($a->{"j"} <=> $b->{"j"}) || ($a->{"k"} <=> $b->{"k"})} @angleCache;
	my %blist;
	## Print our sorted bonds ##
  	foreach my $p(@angleCache){
  		addToTop("angles",$p->{"v"});
                my $i=$p->{"i"};
                my $k=$p->{"k"};
                $blist{"$i $k"}=0;
                $blist{"$k $i"}=0;
	}
        if(defined $OpenSMOG && $interactions->{"nrexcl"} >=2){
                %excludebonded=(%excludebonded,%blist);
        }
}

# CalculateAnglesHelper() calculates the angles for each chain
sub CalculateAngles
{
	my($angleFunctHandle,$isBOND,$whichPDL,$angleCache,$indexhandle,$allatoms,$bondvectors) = @_;
	my %isBOND=%{$isBOND};
	print "Working on:\n"; 
	foreach my $chain(sort { $a <=> $b } keys %{$angleFunctHandle}){
		if(exists $isBOND{$chain}){
			print "\tuser-defined bond $isBOND{$chain}...\n";
		
		}else{
			my $chainn=$chain+1;
			print "\tchain $chainn...\n";
		}
		CalculateAnglesHelper($angleFunctHandle->{$chain},$whichPDL->{$chain},$angleCache,$indexhandle,$allatoms,$bondvectors);
	}
}

sub CalculateAnglesHelper
{
	my($angleArr,$inputPDL,$angleCache,$indexhandle,$allatoms,$bondvectors) = @_;
	my $size = $angleArr->dim(1);
	for(my $i=0;$i<$size;$i++)
	{
		my ($atom1,$atom2,$atom3,$func) = $angleArr->slice(":,$i:$i")->list;
		my $atomi1 = sclr(slice($inputPDL,"3:3,$atom1,:"));
		my $atomi2 = sclr(slice($inputPDL,"3:3,$atom2,:"));
		my $atomi3 = sclr(slice($inputPDL,"3:3,$atom3,:"));
		my $left = $bondvectors->{"$atomi1-$atomi2"};
		my $right = $bondvectors->{"$atomi3-$atomi2"};
		if (! defined $left){
			smog_quit("Internal error 4. left atom pair $atomi1-$atomi2 not defined when building an angle. This should not happen. Please report to the SMOG 2 developers.");
		}
		if (! defined $right){
			smog_quit("Internal error 5. right atom pair $atomi3-$atomi2 not defined when building an angle. This should not happen. Please report to the SMOG 2 developers.");
		}
		my $acos = mathFunctions::rad_to_deg(mathFunctions::acos(sclr(inner($left,$right))));
		
		if($atomi1 > $atomi3) { 
			($atomi1,$atomi2,$atomi3)=($atomi3,$atomi2,$atomi1);
		}
		my $val=angleOutput(intToFunc("angles",$func,""),$atomi1,$atomi2,$atomi3,$acos,$indexhandle,$allatoms);
		if(!$val) {next;}
			# i,j,k are meta data
	 	push @{$angleCache}, {'i' => $atomi1,'j' => $atomi2,'k' =>$atomi3, 'v' => $val};
	}
}

# Convert internal angle function format to gromacs function format
sub angleOutput
{
 	my($inputFunc,$i,$j,$k,$values,$indexhandle,$allatoms) = @_;
 	$inputFunc = trim($inputFunc);
 ## If $input contains a + ##
	my @funcs = split(/\+/,$inputFunc);
	my $outputString="";
	my $kd="";
	my $fType="";my @paramArr;
	my $formattedString="";
	foreach my $fun(@funcs)
	{
		($fType,@paramArr) = angleFuncParser($fun);

		if($fType ==-1){
			 ## don't write angle and constant. Make gromacs use angletype
			my $tmtype=checkangletype($i,$j,$k,$allatoms); 
			my @tmtype=@{$tmtype};
			my $type=$tmtype[0];
			$formattedString = sprintf("%d\t%d\t%d",$i,$j,$k);
			$outputString .= $formattedString;
                        if(defined $OpenSMOG && $type > 0){
                                #openMM requires that the function type is listed, even if relying on angletypes
                                $outputString .= sprintf("\t%d\n",$type);
                        }else{
                                $outputString .= "\n";
                        }

			if(abs($tmtype[1]-$values)/$tmtype[1] > 0.1){
				my $THETA=int($values*100)/100.0;
				my $i1=$indexhandle->{$i};
				my $j1=$indexhandle->{$j};
				my $k1=$indexhandle->{$k};
				smog_note("Angle of $THETA degrees calculated for atom pair $i $j $k (gro indices.  Or, lines $i1 $j1 $k1 of PDB file). This differs by more than 10 percent from the value explicitly given in the templates/extras ($tmtype[1]). This may mean there is something strange with your structure.");
			}
	 		
		}elsif($fType != 0){
			my $dosub=0;
			if($paramArr[0] !~ m/\?/){
				# nothing to sub.  Just use the value given in the .b file
				$dosub=1;
			}
			$paramArr[0]=evalsub($paramArr[0],$values);
			if($dosub==1){
			        ## non-native option used
				if(abs($paramArr[0]-$values)/$paramArr[0] > 0.1){
					my $i1=$indexhandle->{$i};
					my $j1=$indexhandle->{$j};
					my $k1=$indexhandle->{$k};
					my $ANGLE=int($values*10000)/10000.0;
					smog_note("Angle of $ANGLE calculated for atom set $i $j $k (gro indices.  Or, lines $i1, $j1 and $k1 of PDB file). This differs by more than 10 percent from the value explicitly given in the templates ($paramArr[0]). This may mean there is something strange with your structure.");
				}
	 		}elsif($paramArr[0] < $interactionThreshold->{"angles"}->{"smallAngles"}){ 
			## Check angles threshold ##
				my $THETA=int($paramArr[0]*100)/100.0;
				my $i1=$indexhandle->{$i};
				my $j1=$indexhandle->{$j};
				my $k1=$indexhandle->{$k};
				smog_quit("Angle assigned to atoms $i $j $k (PDB lines $i1 $j1 $k1) smaller than smallAngles (see .sif): theta=$THETA degrees\n\tBe careful! Depending on the angles adopted during the simulation, this may lead to numerical instabilities.",1);
			}elsif($paramArr[0] > $interactionThreshold->{"angles"}->{"largeAngles"}){
				my $THETA=int($paramArr[0]*100)/100.0;
				my $i1=$indexhandle->{$i};
				my $j1=$indexhandle->{$j};
				my $k1=$indexhandle->{$k};
				smog_quit("Angle assigned to atoms $i $j $k (PDB lines $i1 $j1 $k1) greater than largeAngles (see .sif): theta=$THETA degrees\n\tBe careful!  This can lead to numerical instability of your simulations.",1);
			}
		## Format output <i j k function p1 p2 ... pn>
			my $paramFormat=formatvalues($#paramArr);
			$formattedString = sprintf("%d\t%d\t%d\t%d\t$paramFormat",$i,$j,$k,$fType,@paramArr);
			$outputString = "$outputString$formattedString";
		}else{
			$freeangles{"$i-$j-$k"}=1;
			$freeangles{"$k-$j-$i"}=1;
		}
	}
	return $outputString; 
}

# Given a user defined angle function parse values
sub angleFuncParser
{
	my($angFunc) = @_;
	my $fType;my @paramArr;my $directive;
	my $funcName = ""; my $params = "";

	if(exists $angleParseSeen{$angFunc}{"fType"}){
		# if we have parsed this before, just write it.  Don't mess with everything else.
		return ($angleParseSeen{$angFunc}{"fType"},@{$angleParseSeen{$angFunc}{"paramArr"}});
	}
 	($angFunc =~ /^([^(]+)\((.*)\)$/);
	$funcName = $1;
	$params = $2;
	$params =~ s/\s+//g; 
	($fType,$directive) = returnFunction($funcName); ## Obtain Gromacs function type
 	@paramArr = split(",",$params); ## Parse all parameters
	$angleParseSeen{$angFunc}{"fType"}=$fType;
	$angleParseSeen{$angFunc}{"paramArr"}=\@paramArr;
	return ($fType,@paramArr);
}

# Combined dihedral calculation,sorting, and printing
sub printOrderedDihedrals
{
	my($DihedralData,$isBOND,$bondPDL,$allatoms,$bondvectors) = @_;
	my @diheCache; ## CACHE BONDS TO ORDER
	## Cache Bonds ##
	CalculateDihedrals($DihedralData,$isBOND,$bondPDL,\@diheCache,$allatoms,$bondvectors);
	## Sort dihedrals by i, then j then k then l ## 
	@diheCache = sort {($a->{"j"} <=> $b->{"j"}) || ($a->{"k"} <=> $b->{"k"}) || ($a->{"f"} <=> $b->{"f"}) || ($a->{"i"} <=> $b->{"i"}) || ($a->{"l"} <=> $b->{"l"})} @diheCache;
	my %blist;	
	## Print our sorted bonds ##
        if(defined $OpenSMOG){
		if($interactions->{"nrexcl"} >=3){
                	%excludebonded=(%excludebonded,%blist);
		}
	}
	foreach my $p(@diheCache){
	        my $i=$p->{"i"};
	        my $l=$p->{"l"};
	        $blist{"$i $l"}=0;
	        $blist{"$l $i"}=0;
		if($p->{"f"} == -2){
			addToTop("OpenSMOG",$p->{"v"},"dihedral");
			addToSCMbufferArr("dihedrals",$p->{"v"});
		}else{
			addToTop("dihedrals",$p->{"v"},"dihedral");
			addToSCMbuffer("dihedrals",$p->{"v"});
		}
	}
}

# Setup the calculation of dihedral angles of all combined residues,
sub CalculateDihedrals
{
	my($diheFunctHandle,$isBOND,$whichPDL,$diheCache,$allatoms,$bondvectors) = @_;
	my %isBOND=%{$isBOND};
	print "Working on:\n";
	foreach my $chain(sort { $a <=> $b } keys %{$diheFunctHandle}){
		if(exists $isBOND{$chain}){
			print "\tuser-defined bond $isBOND{$chain}...\n";
		
		}else{
			my $chainn=$chain+1;
			print "\tchain $chainn...\n";
		}
		CalculateDihedralsHelper($diheFunctHandle->{$chain},$whichPDL->{$chain},$diheCache,$allatoms,$bondvectors);
	}
}

sub CalculateDihedralsHelper
{
	 my($diheArr,$inputPDL,$diheCache,$allatoms,$bondvectors) = @_;
	 $anyfree=0;
	 $anyfree=scalar(keys %freeangles);
	 my $size = $diheArr->dim(1);
	 for(my $i=0;$i<$size;$i++)
	 {
		my ($atom1,$atom2,$atom3,$atom4,$func,$cD,$eG) = $diheArr->slice(":,$i:$i")->list;
	        if(!defined $eG){
                       	next; 
                       	# This has to do with the functional array being used for the same purpose as the listing array. Some old sloppiness that should be cleaned up.
	        }else{
			# global atom indices. 
			my $atomi1 = sclr(slice($inputPDL,"3:3,$atom1,:"));
			my $atomi2 = sclr(slice($inputPDL,"3:3,$atom2,:"));
			my $atomi3 = sclr(slice($inputPDL,"3:3,$atom3,:"));
			my $atomi4 = sclr(slice($inputPDL,"3:3,$atom4,:"));

			if($eG >= 0)
			{
				## $eG >=0 dihedral is proper dihedral of any functional form
				# these can all be calculated based on saved bonded vectors.

				my $b1=$bondvectors->{"$atomi2-$atomi1"};
				my $b2=$bondvectors->{"$atomi3-$atomi2"};
				my $b3=$bondvectors->{"$atomi4-$atomi3"};
	
				my $acos=dihfrombonds($b1,$b2,$b3);

				if($atomi2 > $atomi3) { #then reverse order
					($atomi1,$atomi2,$atomi3,$atomi4)=($atomi4,$atomi3,$atomi2,$atomi1);
				}
				my ($valArray,$fTypeArray) = dihedralOutput(intToFunc("dihedrals",$func,$eG),$atomi1,$atomi2,$atomi3,$atomi4,$acos,$cD,$eG,$allatoms);
				my @arr=@{$valArray};
				my @Farr=@{$fTypeArray};
				for(my $I=0;$I<=$#arr;$I++){
					push @{$diheCache}, {'i'=> $atomi1,'j' => $atomi2,'k' =>$atomi3,'l' =>$atomi4, 'f' => $Farr[$I], 'v' => $arr[$I]};
				}
				# j,k,f are meta data
			}else{
				## Improper dihedral. must calculate everything

		  		my $A1=slice($inputPDL,"0:2,$atom1,:");
		  		my $A2=slice($inputPDL,"0:2,$atom2,:"); 
		  		my $A3=slice($inputPDL,"0:2,$atom3,:"); 
		  		my $A4=slice($inputPDL,"0:2,$atom4,:"); 

				my $b1=$A2-$A1;
				my $b2=norm($A3-$A2);
				my $b3=$A4-$A3;
				my $acos=dihfrombonds($b1,$b2,$b3);

				my ($valArray,$fTypeArray)=dihedralOutput(intToFunc("impropers",$func,$eG),$atomi1,$atomi2,$atomi3,$atomi4,$acos,$cD,-1);
				my @arr=@{$valArray};
				my @Farr=@{$fTypeArray};
				for(my $I=0;$I<=$#arr;$I++){
					push @{$diheCache}, {'i'=> $atomi1,'j' => $atomi2,'k' =>$atomi3,'l' =>$atomi4, 'f' => $Farr[$I], 'v' => $arr[$I]};
				}
			}
		}
	}
}

sub dihfrombonds
{
	my ($b1,$b2,$b3)=@_;
	# b1, b2 and b3 are unit vectors
	my $n1 = norm(crossp($b1,$b2));
	my $n2 = norm(crossp($b2,$b3));
	my $m1 = crossp($b2,$n1);
	my $acos = atan2(inner($m1,$n2),inner($n1,$n2));
	return $acos;
}

sub dihedralOutput
{
 	my($inputFunc,$ai,$aj,$ak,$al,$value,$ratio,$eG,$allatoms) = @_;
 	$inputFunc = trim($inputFunc);
	my @funcs;
	# splitFunctions is a more robust function parser, but it outputs data 
	# in the wrong format for this routine. So, we'll fix the org of @funcs
	my ($name,$var)=splitFunction($inputFunc);
	my @vars=@{$var};
	my @names=@{$name};
	for (my $I=0;$I<=$#vars;$I++){
		push(@funcs,"$names[$I]($vars[$I])");
	}
	my $outputString="";
	my $fType="";       
 	my $formattedString="";
	my @paramArr;
	my $funcName;
	my @fTypei;
 	my @OSarray=();
 	my @fTypeArray=();
	foreach my $fun(@funcs)
	{
		# funcName is only used for OS features
		($fType,$funcName,@paramArr) = diheFuncParser($fun);
		push(@fTypeArray,$fType);
		# convert to degrees, except when using OpenSMOG
		my $value_local;
		if($fType ==-1){
			 ## don't write angle. Make gromacs use dihedraltype
			my $type=checkdihedraltype($ai,$aj,$ak,$al,$allatoms);
			$formattedString = sprintf("%d\t%d\t%d\t%d",$ai,$aj,$ak,$al);
			$outputString .= $formattedString;
                        if(defined $OpenSMOG && $type > 0){
                                #openMM requires that the function type is listed, even if relying on dihedraltypes
                                $outputString .= sprintf("\t%d\n",$type);
                        }else{
                                $outputString .= "\n";
                        }

			push(@OSarray,"$outputString");
		}elsif($fType != 0){

	 		if($anyfree!=0 and (exists $freeangles{"$ai-$aj-$ak"} or exists $freeangles{"$ak-$aj-$ai"} or exists $freeangles{"$aj-$ak-$al"} or exists $freeangles{"$al-$ak-$aj"})  ){
				# skip
			}else{
				# If there is a ?, then substitute the angle value and apply the multiplicity.  If there is no wild card, then simply use the angle provided
				if ($fType == -2){
					if(exists $fTypesdefault{$funcName}){
						# this is a default dihedral function.  So, use degrees when evaluating ? expressions
						$value_local= sclr(mathFunctions::rad_to_deg($value)); 
					}else{
						$value_local=sclr($value);
					}
					# if OS potential, then every parameter (except for weight, which is the first) may contain a ?
					my $ind=-2;
					if( exists $OpenSMOGpothash->{$funcName}->{weight}){
						$ind=exists $OpenSMOGpothash->{$funcName}->{weight};
					}

					for(my $in=0;$in<=$#paramArr;$in++){
						if($in != $ind){
							# replace ? on all terms, except for weight
							$paramArr[$in]=evalsub($paramArr[$in],$value_local);
							
							if(exists $fTypesdefault{$funcName}){
								# this is one of the default dihedral functions.  So, convert back to radians
								if($OpenSMOGpothash->{$funcName}->{theta0} == $in){
									
									$paramArr[$in]= mathFunctions::deg_to_rad($paramArr[$in]); 
								}
							}
						}
					}
					if(exists $OpenSMOGpothash->{$funcName}->{weight}){
			 			my $ind=$OpenSMOGpothash->{$funcName}->{weight};
						$paramArr[$ind]*=$ratio;
					}

					my @array;
					## organize the array of info
					$array[0]=$ai;
					$array[1]=$aj;
					$array[2]=$ak;
					$array[3]=$al;
					$array[4]="dihedrals";
					$array[5]= $funcName;
					foreach my $en(@paramArr){
						push(@array,$en);
					}
					#add parameters
        				if(OpenSMOGfunctionExists($OSref,"dihedrals","$funcName") == 0){
        				        my $potential = $OpenSMOGpothash->{$funcName}->{expression};

        				        my $parhandle=\@{$OpenSMOGpothash->{$funcName}->{parameters}};
        				        OShashAddFunction($OSref,"dihedrals","$funcName","$potential",$parhandle);
        				}
					push(@OSarray,\@array);

				}else{
					$value_local= sclr(mathFunctions::rad_to_deg($value)); 
					# not OS
					$paramArr[0]=evalsub($paramArr[0],$value_local);
                                	if($funcName eq "dihedral_cosine" or $funcName eq "dihedral_cosine4" ){
						if( $fType == 1 || $fType == 4){
					            	# Angle will be scaled by multiplicity factor n, if they are cosine functions
					        	$paramArr[0] *= $paramArr[2];
	                        	        }

                                	       # this adds the negative sign in front of cosines, since that is
                                	       # standard with SMOG models.  If not using these functions, don't add it
                                	        $paramArr[0] += 180;
					}elsif($funcName eq "dihedral_ncos" or $funcName eq "dihedral_ncos4"){
					       # ncos and cosine are very similar.  The only difference is that 
					       # with ncos the given angle is not multiplied by the multiplicity 
                                	       # this adds the negative sign in front of cosines, since that is
                                	       # standard with SMOG models.  If not using these functions, don't add it
                                	        $paramArr[0] += 180;
					}


			 		$paramArr[1]*=$ratio;


					## Format output <i j k function p1 p2 ... pn>
					my $paramFormat=formatvalues($#paramArr);

					if($fType == 1 || $fType == 4) {
						$paramFormat=" %12.9e %12.9e %u\n";
					}elsif($fType == 2){    
                               #	## CONVERT FIX RIGID/IMPROPER DIHEDRALS ANGLES TO GROMACS CONVENTION ###
                                	       if($paramArr[0]>180){$paramArr[0]-=360;}elsif($paramArr[0]<-180){$paramArr[0]+=360;}
					}
					$formattedString = sprintf("%d\t%d\t%d\t%d\t%d\t$paramFormat",$ai,$aj,$ak,$al,$fType,@paramArr);
					$outputString = "$outputString$formattedString";
					push(@OSarray,"$formattedString");
				}
			}
		}
	}
	return (\@OSarray,\@fTypeArray);
}
 
# Given a user defined dihedral function, parse values
sub diheFuncParser
{
	my($diheFunc) = @_;
	if(exists $dihParseSeen{$diheFunc}{"fType"}){
		# if we have parsed this before, just write it.  Don't mess with everything else.
		return ($dihParseSeen{$diheFunc}{"fType"},$dihParseSeen{$diheFunc}{"funcName"},@{$dihParseSeen{$diheFunc}{"paramArr"}});
	}
 	my $fType;my @paramArr; my $directive;
	my $funcName = "";my $params = "";
 	($diheFunc =~ /^([^(]+)\((.*)\)$/);
	$funcName = $1; $params = $2;
	$params =~ s/\s+//g; 

	($fType,$directive) = returnFunction($funcName); ## Obtain Gromacs function type
	@paramArr = split(",",$params); ## Parse all parameters;
	$dihParseSeen{$diheFunc}{"fType"}=$fType;
	$dihParseSeen{$diheFunc}{"paramArr"}=\@paramArr;
	$dihParseSeen{$diheFunc}{"funcName"}=$funcName;
	return ($fType,$funcName,@paramArr);
}

sub calculateContacts
{
	my($contactPDL,$inputPDL,$atomTypes,$numCon,$numAtom) = @_;
	my $atoma; my $atomb; my $dist;
	my $pairtypea; my $pairtypeb;
	my $resTypea; my $resTypeb;
	my $multFactor = 1;
	my $c0;  
	my $epsilon;my $cG;my $funct;
 	my $totalStrength; 
	my $contactIntraScale;
	my $count=0;

	my @funct_array;
	my @normalize_array;
	my @atoma_array;
	my @atomb_array;
	my @dist_array;
	my @epsilon_array;

	## Sum all initial contact strengths ##	
	my %conttypeseen;
	for(my $i=0;$i<$numCon;$i++)
	{
		my $normalize;
		my $deltaMin=-1;my $scale=-1;my $deltaMax=-1;
		my $resIdxA=0;my $resIdxB=0;
		$atoma = sclr(slice($contactPDL,"1:1,$i:$i"));
		$atomb = sclr(slice($contactPDL,"2:2,$i:$i"));
		$pairtypea = $atomTypes->{$atoma}->[10];
		$pairtypeb = $atomTypes->{$atomb}->[10];
		$resTypea = $atomTypes->{$atoma}->[1];
		$resTypeb = $atomTypes->{$atomb}->[1];
		my $resnamea = $atomTypes->{$atoma}->[5];
		my $resnameb = $atomTypes->{$atomb}->[5];
		($funct,$cG) = getContactFunctionals($pairtypea,$pairtypeb);
		$conttypeseen{$funct}=1;
		if(!$funct || !$cG){smog_quit("No contact Function defined for nbType contacts $pairtypea-$pairtypeb");}
		$normalize = $termRatios->{"contactGroup"}->{$cG}->{"normalize"};
	
		$funct_array[$i] = $funct;
		$normalize_array[$i] = $normalize;
		$atoma_array[$i] = $atoma;
		$atomb_array[$i] = $atomb;
		$dist_array[$i]	=  sclr(slice($contactPDL,"3:3,$i:$i"));

		## Stacking scaling ##
		$epsilon = 1;
		if(exists $contactSettings->{"contactScaling"}->{$resTypea}
		&& exists $contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb})
		{
			$deltaMin=$contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"deltaMin"};
			$deltaMax=$contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"deltaMax"};
			
			$scale = $contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"scale"};
			$scale = eval($scale);
			$resIdxA = $allAtoms{$atoma}->[2];
			$resIdxB = $allAtoms{$atomb}->[2];
			
			my $atomA = $allAtoms{$atoma}->[3];
			my $atomB = $allAtoms{$atomb}->[3];
			##Atom to boolean##
			$atomA = exists($contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"atomList"}->{$atomA});
			$atomB = exists($contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"atomList"}->{$atomB});
			
			
			if(abs($resIdxB-$resIdxA)>=$deltaMin 
			&& abs($resIdxB-$resIdxA)<=$deltaMax
			&& $atomA && $atomB && $allAtoms{$atoma}[4]==$allAtoms{$atomb}[4]){
				$epsilon*=$scale;
			}
		}

		$epsilon_array[$i] =$epsilon;

		if(!$normalize){next;}
		
		$contactIntraScale = $termRatios->{"contactGroup"}->{$cG}->{"intraRelativeStrength"};
		$epsilon_array[$i] *= $contactIntraScale;

		unless($residues{$resnamea}->{'atomCount'}==0 || $residues{$resnameb}->{'atomCount'}==0){
			$count+=$epsilon_array[$i];
		}
	}

	# determine any global energy redistribution

	if(defined $termRatios->{"interRelativeTotal"} && defined $termRatios->{"energyRelative"}){
       		my $totalStrength = $termRatios->{"interRelativeTotal"};
       		my $diheTotal = $termRatios->{"energyRelative"};
       		my $contactLeftOver = $numAtom - $numAtom*($diheTotal/$totalStrength);
		if($count != 0 ){
       			$contactLeftOver = $contactLeftOver/$count;
			$multFactor = $contactLeftOver;
		}
	}

	# print everything

	if(!defined $OpenSMOG){
		%excludebonded = ();
	}
	for(my $i=0;$i<$numCon;$i++){
		my $outputString;
		my $directive;my $addExclusions;
		my $normalize=$normalize_array[$i];	
		## Non-normalize option for contacts ##
		if($normalize) {
			## DIHE TO CONTACT SCALING ##
			$epsilon_array[$i] *= $multFactor;
		}
		($directive,$addExclusions,$outputString) = contactOutput($funct_array[$i],$atoma_array[$i],$atomb_array[$i],$dist_array[$i],$epsilon_array[$i],$normalize_array[$i]);
		addToTop($directive,$outputString,"contact");
		if($addExclusions && !exists $excludebonded{"$atoma_array[$i] $atomb_array[$i]"}) { addToTop("exclusions",$atoma_array[$i]."	".$atomb_array[$i]."\n"); }
	}

	if(scalar keys %conttypeseen >1 && !defined $OpenSMOG){
		my $L;
		foreach my $CT(keys %conttypeseen){
			$L .= $CT;
			$L .= " ";
		}
		smog_note("More than one type of contact being used at the same time. Not all combinations of contacts are supported by Gromacs. List of used contact types: $L");
 	}
}

# Convert internal contact function format to gromacs function format,
# internal format is f()+g()
sub contactOutput
{
	my($inputFunc,$i,$j,$c0,$epsilon,$normalize) = @_;
	$inputFunc = trim($inputFunc);
	## If $input contains a + ##
	my @funcs = split(/\+/,$inputFunc); ## split combination of functions
	my $outputString="";
	my @paramArr;
	my $fname;
	my $directive;
	my $addExclusions;
	my $fType=""; my $formattedString;
	my $addNewline = "";
	## Parse each part of the function ##
	foreach my $fun(@funcs){
		my $paramFormat="";
		($fType,$fname,$directive,$addExclusions,@paramArr) = contactFuncParser($fun);
		## LJ CONTACTS N-M polynomial, sigma and epsilon usage ##	
		if($fType != 0) {
			# fType=0 means treat as free.  All other, we should process
			$addNewline = "\n";
			if($fname eq "contact_1"){
				contactParseNM1(\@paramArr,$c0,$epsilon,$normalize);
			}
			## LJ CONTACTS N-M polynomial, CN, CM usage ##	
			elsif($fname eq "contact_2"){
				contactParseNM2(\@paramArr,$c0,$epsilon,$normalize);
			}
			    ## Gaussian ##
			elsif($fname eq "contact_gaussian"){
				contactParseGaussian(\@paramArr,$c0,$epsilon,$normalize);
			}
			## harmonic bond type 6 ##
			elsif($fname eq "bond_type6"){
				contactParseBond6(\@paramArr,$c0,$epsilon);
			}else{
				# if not one of the above functions, then it must be a custom potential
				contactParseOpenSMOG($fname,\@paramArr,$c0,$epsilon,$normalize);
			}
			if($paramArr[0] eq "OpenSMOG"){
				# format for OpenSMOG
				$directive="OpenSMOG";
				$paramArr[0]=$j;
				unshift(@paramArr,$i);
				$outputString=\@paramArr;	
 			}else{
		 		foreach(@paramArr){$paramFormat="$paramFormat %12.9e";}
				$formattedString = sprintf("%d\t%d\t%d\t$paramFormat",$i,$j,$fType,@paramArr);
				$outputString = "$outputString$formattedString$addNewline";
			}
		}
	}
	return ($directive,$addExclusions,$outputString);
}

# Parse LJ NM sigma eps usage
sub contactParseNM1
{
	my($paramArr,$r0,$epsilon,$normalize) = @_;
	##paramArr holds N, M, and whether native distances and weights should be used.
	##epsilon
	##r0 is native distance##
	#

	my $A; my $B;
	my $N; my $M;
	$M=$paramArr->[0];
	$N=$paramArr->[1];
	my $length=scalar @{$paramArr};

	if($interactions->{"gmx-combination-rule"}==1 || defined $OpenSMOG){
	
		$B=-1.0/($M/$N-1.0);
		$A=$M/$N*$B;
		# replace ? with native distance expression
        	$r0=evalsub($paramArr->[2],$r0);
		   
		$A *= $epsilon*$r0**$N;
		$B *= $epsilon*$r0**$M;
		
		## normalized option used
		if($paramArr->[3] =~ /^\?$/ || $paramArr->[3] =~ m/energynorm/i)
		{
			$paramArr->[3]=$A;
			$paramArr->[2]=$B;
		}
		else{
			$A *= $paramArr->[3];
			$B *= $paramArr->[3];
			$paramArr->[3]=$A;
			$paramArr->[2]=$B;
		} 
	}elsif($interactions->{"gmx-combination-rule"}==2){

		# replace ? with native distance expression
        	$paramArr->[2]=evalsub($paramArr->[2],$r0);
		$paramArr->[2] /= (2.0)**(1.0/6.0);   
		## normalized option used
		if($paramArr->[3] =~ /^\?$/ || $paramArr->[3] =~ m/energynorm/i )
		{
			$paramArr->[3]=$epsilon;
		}
	}
	if(defined $OpenSMOG){
		if(OpenSMOGfunctionExists($OSref,"contacts","contact_1-$M-$N") == 0){
			my $potential = $OpenSMOGpothash->{contact_1}->{expression};
			$potential =~ s/N/$N/g;
			$potential =~ s/M/$M/g;
			
			my $parhandle=\@{$OpenSMOGpothash->{contact_1}->{parameters}};
			OShashAddFunction($OSref,"contacts","contact_1-$M-$N","$potential",$parhandle);
		}
		# switch order for OpenSMOG, so that the first parameter is the 12 term
		($paramArr->[2],$paramArr->[3])=($paramArr->[3],$paramArr->[2]);
		unshift(@{$paramArr},"OpenSMOG");
		$paramArr->[1]="contacts";
		$paramArr->[2]="contact_1-$M-$N";
		return;
	}
	## Shift first value off ##
	shift @{$paramArr};
	shift @{$paramArr};
}

# Parse LJ: F_N(sigma), G_M(sigma), sigma, epsilon format
sub contactParseNM2
{
	my($paramArr,$r0,$epsilon,$normalize) = @_;
	##pararArr holds f(r), g(r), and whether native distances and weights should be used.
	##epsilon  
	##r0 is native distance##
	#
	my $A; my $B;
	my $length=scalar @{$paramArr};

	# replace ? with native distance expression
	$paramArr->[2]=evalsub($paramArr->[2],$r0);
	
	# substitute value of r into f(r) and g(r)
	$A=evalsub($paramArr->[1],$paramArr->[2]);	
	$B=evalsub($paramArr->[0],$paramArr->[2]);	

	$A *= $epsilon; 
	$B *= $epsilon; 
	
	## standard normalization used
	if($paramArr->[3] =~ /^\?$/ || $paramArr->[3] =~ m/energynorm/i)
	{
		$paramArr->[3]=$A;
		$paramArr->[2]=$B;
	}else{
	## additional rescaling used
		$A *= $paramArr->[3];
		$B *= $paramArr->[3];
		$paramArr->[3]=$A;
		$paramArr->[2]=$B;
	} 
	## Shift first value off ##
	shift @{$paramArr};
	shift @{$paramArr};
}

# Parse Gaussian Params
sub contactParseGaussian
{

	my($paramArr,$r0,$epsilon,$normalize) = @_;
	my $A=0;my $sigma_G=0;my $a=0;
	##i=0 is epsilon_c##
	##i=1 is epsilon_nc#
	##i=2 is sigma_gaussian##
	##i=3 is r ##
	
	
	## Epsilon_c ##
	if($paramArr->[0] =~ /^\?$/ || $paramArr->[0] =~ m/energynorm/i ){
		$paramArr->[0]=$epsilon;
	}else{
		$paramArr->[0]=$epsilon*($paramArr->[0]);
	}
	
	## Check if sigma_G has r0 dependency ##
	if($paramArr->[2] =~ /\?/)
	{
		#Replace ? with $r0
		$paramArr->[2] = evalsub($paramArr->[2],$r0); 
		#Eval expression
	}
	if($paramArr->[3] =~ /^?$/){$paramArr->[3]=$r0;}

        if(defined $OpenSMOG){
                if(OpenSMOGfunctionExists($OSref,"contacts","contact_gaussian") == 0){
                        my $potential = $OpenSMOGpothash->{contact_gaussian}->{expression};
                        my $parhandle=\@{$OpenSMOGpothash->{contact_gaussian}->{parameters}};
                        OShashAddFunction($OSref,"contacts","contact_gaussian","$potential",$parhandle);
                }
                # switch order for OpenSMOG, so that the first parameter is k
                ($paramArr->[0],$paramArr->[1],$paramArr->[2],$paramArr->[3])=($paramArr->[0],$paramArr->[3],$paramArr->[2],$paramArr->[1]);
                unshift(@{$paramArr},"contact_gaussian");
                unshift(@{$paramArr},"contacts");
                unshift(@{$paramArr},"OpenSMOG");
                return;
        }	
	($A,$r0,$sigma_G,$a) = ($paramArr->[0],$paramArr->[3],$paramArr->[2],$paramArr->[1]);
	@{$paramArr}=($A,$r0,$sigma_G,$a);

}

# Parse Bond type 6
sub contactParseBond6
{
	my($paramArr,$r0,$epsilon) = @_;
	my $k;
	##i=0 is r##
	##i=1 is k#
	
	## k ##
	$paramArr->[1] = eval($paramArr->[1]);
	
	## r ##
	$paramArr->[0] = evalsub($paramArr->[0],$r0);

        if(defined $OpenSMOG){
                if(OpenSMOGfunctionExists($OSref,"contacts","bond_type6") == 0){
                        my $potential = $OpenSMOGpothash->{bond_type6}->{expression};

                        my $parhandle=\@{$OpenSMOGpothash->{bond_type6}->{parameters}};
                        OShashAddFunction($OSref,"contacts","bond_type6","$potential",$parhandle);
                }
                # switch order for OpenSMOG, so that the first parameter is k
                ($paramArr->[0],$paramArr->[1])=($paramArr->[1],$paramArr->[0]);
                unshift(@{$paramArr},"bond_type6");
                unshift(@{$paramArr},"contacts");
                unshift(@{$paramArr},"OpenSMOG");
                return;
        }

	($r0,$k) = ($paramArr->[0],$paramArr->[1]);
	@{$paramArr}=($r0,$k);

}

# Parse custom OpenSMOG potentials
sub contactParseOpenSMOG
{
	my($fname,$paramArr,$r0,$epsilon,$normalize) = @_;
	## fname is the name of the function.  this is used to get the parameter list
	##paramArr holds the entries for the OpenSMOG parameter list
	##epsilon is the normalize weight
	# normalize indicates whether normalization is applied
	##r0 is native distance##
	#

	if(exists $OpenSMOGpothash->{$fname}->{weight}){
		# there is a weight variable
		if($paramArr->[$OpenSMOGpothash->{$fname}->{weight}] =~ /^\?$/ || $paramArr->[$OpenSMOGpothash->{$fname}->{weight}] =~ /^energynorm$/i){
			# the weight should be normalized, so set it to epsilon
			$paramArr->[$OpenSMOGpothash->{$fname}->{weight}]=$epsilon;	
		}
	}

	my $length=scalar @{$paramArr};

	# replace all other ? marks in parameters with r0 
	for(my $I=0;$I<$length;$I++){
		$paramArr->[$I]=evalsub($paramArr->[$I],$r0);
	}

	if(!defined $OpenSMOG){
		smog_quit("Function $fname only supported with the -OpenSMOG flag");
	}

        unshift(@{$paramArr},"$fname");
        unshift(@{$paramArr},"contacts");
        unshift(@{$paramArr},"OpenSMOG");

        if(OpenSMOGfunctionExists($OSref,"contacts","$fname") == 0){
                my $potential = $OpenSMOGpothash->{$fname}->{expression};

                my $parhandle=\@{$OpenSMOGpothash->{$fname}->{parameters}};
                OShashAddFunction($OSref,"contacts","$fname","$potential",$parhandle);
        }

	return;
}


# Given a user defined contact function parse values
sub contactFuncParser
{
	my($contactFunc) = @_;
	my $fType;my @paramArr;my $directive;my $addExclusions;
	my $funcName = ""; my $params = "";

	if(exists $contactParseSeen{$contactFunc}{"fType"}){
		# if we have parsed this before, just write it.  Don't mess with everything else.
		return ($contactParseSeen{$contactFunc}{"fType"},
			$contactParseSeen{$contactFunc}{"funcName"},
			$contactParseSeen{$contactFunc}{"directive"},
			$contactParseSeen{$contactFunc}{"addExclusions"},
			@{$contactParseSeen{$contactFunc}{"paramArr"}});
	}
 	($contactFunc =~ /^([^(]+)\((.*)\)$/);
 	$funcName = $1;
	$params = $2;
	$params =~ s/\s+//g; 
	($fType,$directive,$addExclusions) = returnFunction($funcName); ## Obtain Gromacs function type
 	@paramArr = split(",",$params); ## Parse all parameters

	$contactParseSeen{$contactFunc}{"fType"}=$fType;
	$contactParseSeen{$contactFunc}{"funcName"}=$funcName;
	$contactParseSeen{$contactFunc}{"directive"}=$directive;
	$contactParseSeen{$contactFunc}{"addExclusions"}=$addExclusions;
	$contactParseSeen{$contactFunc}{"paramArr"}=\@paramArr;

	return ($fType,$funcName,$directive,$addExclusions,@paramArr);
}

sub getAtomTypes
{
	my($uniqueHandle) = @_;
	
	## OBTAIN UNIQUE ATOM TYPES ##
	my $nbtype ="";
	
	foreach my $atoms(sort { $a <=> $b } keys %{$uniqueHandle})
	{
		$nbtype = $uniqueHandle->{$atoms}->[0];
  		if(!$uniqueHandle->{$atoms}->[0])
        	{
          		smog_quit("Atom $atoms has no nbType");
        	}
		$presentatomtypes{$nbtype}=1;
	}
}

sub saveAtomTypes
{
	my $formattedString = "";	
	my $c2;my $c1;my $sigma;my $epsilon;my $ptype;my $charge;my $mass;
	 
	foreach my $nbtype(sort keys %presentatomtypes){
		my $tmptype;
		if(exists $interactions->{"nonbonds"}->{$nbtype}){
			if(exists $extraatomtypes{$nbtype}){
				smog_quit("Non-bonded parameters for atomtype $nbtype are defined in the .nb and extras file");
			}
			$tmptype=$nbtype;
		}elsif(exists $extraatomtypes{$nbtype}){
			# dump the extras information.  Don't match to a wild card, below
			addToTop("atomtypes",$extraatomtypes{$nbtype}."\n");
			next;
		}elsif(exists $interactions->{"nonbonds"}->{"*"}){
			$tmptype="*";
		}else{
			smog_quit("No matching nb parameters found for nbtype $nbtype");
		}
		if($interactions->{"gmx-combination-rule"}==1){ 
			$c1 = $interactions->{"nonbonds"}->{$tmptype}->{"c6"};
			$c2 = $interactions->{"nonbonds"}->{$tmptype}->{"c12"};
		}elsif($interactions->{"gmx-combination-rule"}==2){
			$c1 = $interactions->{"nonbonds"}->{$tmptype}->{"sigma"};
			$c1 /= (2.0)**(1.0/6.0);
			$c2 = $interactions->{"nonbonds"}->{$tmptype}->{"epsilon"};
		}
			$ptype = $interactions->{"nonbonds"}->{$tmptype}->{"ptype"};
			$mass = $interactions->{"nonbonds"}->{$tmptype}->{"mass"};
			$charge = $interactions->{"nonbonds"}->{$tmptype}->{"charge"};
			
			$formattedString = sprintf("%-4s %8.4f %10.6f  %1s     %-13.5e %-13.5e",$nbtype,$mass,$charge,$ptype,$c1,$c2);
		addToTop("atomtypes",$formattedString."\n");
	}
}

sub readAtoms
{
	my($inputPDB) = @_;
	my %reflist;
	open(PDB,$inputPDB);
	my $line = "";
	my $atomName;my $atomNum; my $resName; my $resNum;
	my $charge = 0; my $mass = 1; my $atomType="none";
	my $counter=0; my $resCounter=1;my $resNumCurr="null";
	my $endreached=0;
	my $totalcharge=0;
	my $systemcharge=0;
	my $chainindex=1;
	my $linenumber=0;
	my $atomindex=0;
	my $lastTER=0;
	my $lastTERfound=0;
	while($line = <PDB>)
	{
		$linenumber++;
		if($line =~ m/^TER|^END/ ) {
			if($linenumber-$lastTERfound>1){
				my $TCr=round($totalcharge);
				if(abs($totalcharge-$TCr) > 0.001){
					smog_quit("Non-integer charge ($totalcharge) for chain $chainindex. This typically means something is wrong with the .bif file.");
				}
				print "Charge of chain $chainindex: $TCr\n";
				$systemcharge+=$totalcharge;
				$totalcharge=0;
				$chainindex++;
				$resCounter++;
				$lastTER=1;
			}
			$lastTERfound=$linenumber;
		}
		if($line =~ m/^END/) {$endreached=1;last;}
		if($line =~ m/^ATOM/ || $line =~ m/^HETATM/)
		{
			$atomindex++;
			$reflist{$atomindex}=$linenumber;
			$atomName = trim(substr($line, 12, 4));
			$atomNum = trim(substr($line,6,5));
			$resName = trim(substr($line,17,4));
			$resNum = trim(substr($line,22,4));
			if($resNumCurr eq "null"){
				$resNumCurr=$resNum;
			}
   			if($resNum ne $resNumCurr)
			{
				$resNumCurr=$resNum;
				if($lastTER ==0){
					$resCounter++;
				}
			}
			if(!$residues{$resName}->{"atoms"}->{$atomName}){next;}
			$counter++;$atomNum=$counter;
			$atomType = $residues{$resName}->{"atoms"}->{$atomName}->{"nbType"};
			addToTop("atoms",sprintf("%6d %10s %6d %6s %6s %6d", $atomNum, $atomType, $resCounter, $resName, $atomName, $atomNum));
			if(defined $residues{$resName}->{"atoms"}->{$atomName}->{"charge"}){
				#if charge is defined for an atom in a  specific residue, then write it
				addToTop("atoms",sprintf(" %9.6f", $residues{$resName}->{"atoms"}->{$atomName}->{"charge"}));
				# this residue has a charge on that atom, add that value to the total
				$totalcharge += $residues{$resName}->{"atoms"}->{$atomName}->{"charge"};
			}elsif(defined $interactions->{"nonbonds"}->{$atomType}->{"charge"}){
				# since there is not residue-specific charge assigned, use the atomtype value.
				$totalcharge += $interactions->{"nonbonds"}->{$atomType}->{"charge"};
			}
			addToTop("atoms",sprintf("\n"));
			$lastTER=0;
		}
	}

        addToTop("comments","After running SMOG2, the total charge of the system is $systemcharge\n\n");
	if(abs($systemcharge-round($systemcharge)) > 0.001){
		smog_quit("Non-integer system charge ($systemcharge). This usually means something is wrong with the .bif, .nb, .extras of .ions.def file.");
	}else{
		printf("\nTotal charge of system: %8.3f\n\n",$systemcharge);
	}
	unless($endreached){smog_quit("PDB format error. END must appear at the end of the ATOM lines.")};
	return(%reflist);
}

# Convert PDB to GRO
# Store chain info to ndx file
sub convertPDBToGroNdx
{
	my ($inputPDB,$outputGRO,$outputg96,$outputGRO4SCM,$outputNDX,$userProvidedMap,$freecoor) = @_;
	my $counter = 0 ;	
	my $line = "";
	my $resName="";
	my $resNum="";
	my $atomName="";
	my $atomNum="";
 	my $x="";my $y="";my $z="";
 	my $output = "";
 	my $chain = "";
 	my $chainCounter = 1;
 	my %chainHash;
	my $resNumCurr=1;my $resCounter=1;
	my $boundflag=0;
	my $lastTER=0;
	my ($xmin, $xmax, $ymin,$ymax,$zmin,$zmax);
	my $grofmt="%5d%-5s%5s%5d%8.3f%8.3f%8.3f\n";
	my $groSCMfmt="%5d%-5s%5s%5d %10.4f %10.4f %10.4f\n";
	my $g96fmt="%5d %-5s %-5s%7d%15.9f%15.9f%15.9f\n";
	my $usefmt;
	my $atommod;
	my $maxchar;
	my $filetype;
	if($outputg96 ne ""){
		$usefmt=$g96fmt;
		$atommod=10000000;
		$maxchar=6;
		$filetype="G96";
	}else{
		$usefmt=$grofmt;
		$atommod=100000;
		$maxchar=5;
		$filetype="Gro";
	}
 	open(PDB,"$inputPDB") or smog_quit("can not open $inputPDB"); ## INPUT PDB
	my @atominfo;
	my $atominfo4SCM="";
        my $linenum=0;
	my $lastTERline=0;
	my $atomnum=0;
	while($line=<PDB>)
	{
		
	 	if($line =~ m/^END/) {last;}
  	 	if($line =~ m/^TER/) {
	 	       if($lastTERline != $linenum){
	 	       		# don't increment chain number if the chain is empty
	 	       		$chainCounter++;
	 	       		$resCounter++;
	 	       		$lastTER=1;
	 	       }
	 	       $lastTERline=$linenum;
	 	       next;
	 	}
	 	$linenum++;
         	if($line =~ m/^ATOM|^HETATM/) {
	 		$atomName = trim(substr($line, 12, 4));
	 	       	$resName = trim(substr($line,17,4));
         	       	if(!exists $residues{$resName}->{"atoms"}->{$atomName}){next;}
			$atomnum++;
	
         	       	if(defined $freecoor){
         	       		# Read the PDB coordinates as free-format.
         	       		my $string=trim(substr($line, 30));
         	       		my @coor=split(/\s+/,$string);
         	       		$x=$coor[0];
         	       		$y=$coor[1];
         	       		$z=$coor[2];
	 	       		# only check sizes of coords if using a gro and freecoor
	 	       		foreach my $n($x,$y,$z){
	 	       			my @A=split(/\./,$n);
	 	       			if(length($A[0])>$maxchar){
	 	       				smog_quit("Coordinates are too large to write a $filetype file. Found coordinates:\n\t$line");
	 	       			};
	 	       		}
         	       	}else{
         	               	$x = trim(substr($line, 30, 8));
         	               	$y = trim(substr($line, 38, 8));
         	               	$z = trim(substr($line, 46, 8));
         	       	}
	 	       	if(! looks_like_number($x) or ! looks_like_number($y) or ! looks_like_number($z)){
	 	       		smog_quit("Unable to interpret coordinate in PDB file. Perhaps the file doesn't strictly follow PDB fixed-column formatting. Or, perhaps you need to use the -freecoor option. Problematic line:$line");
	 	       	}
	
	 	       	$x*=0.10;
	 	       	$y*=0.10;
	 	       	$z*=0.10;
	 	       
	 	       	if($boundflag == 0){
	 	       		$xmin=$x;
	 	       		$xmax=$x;
	 	       		$ymin=$y;
	 	       		$ymax=$y;
	 	       		$zmin=$z;
	 	       		$zmax=$z;
	 	       		$boundflag=1;
	 	       	}else{
	 	       		if($x > $xmax){$xmax=$x;}
	 	       		if($x < $xmin){$xmin=$x;}
	 	       		if($y > $ymax){$ymax=$y;}
	 	       		if($y < $ymin){$ymin=$y;}
	 	       		if($z > $zmax){$zmax=$z;}
	 	       		if($z < $zmin){$zmin=$z;}
	 	       	}
	
  	 	       	$chain = $chainCounter;
	 	       	$counter++;$atomNum=$counter;
	 	       	$resNum = trim(substr($line,22,4));
	 	       	if($atomNum == 1){$resNumCurr=$resNum;}
	 	       	if($resNum ne $resNumCurr){
	 	       		$resNumCurr=$resNum;
	 	       		if($lastTER==0){
	 	       			$resCounter++;
	 	       		}
	 	       	}

  	 	       	## Save atom index to chain ##
  	 	       	push(@{$chainHash{$chain}},$atomNum);
	 	       	if($atomNum >= $atommod){$atomNum = $atomNum%$atommod;}
	 	       	if($resCounter >= 100000){$resCounter = $resCounter%100000;}
	 	       
	 	       	push(@atominfo,["$usefmt",$resCounter,$resName,$atomName,$atomNum,$x,$y,$z]);
	 	       	$atominfo4SCM .= sprintf("$groSCMfmt",$resCounter,$resName,$atomName,$atomNum,$x,$y,$z);
	 	       	$lastTER=0;  
	 	}
	}

	if($atomnum == 0){
		smog_quit("No atoms found in $inputPDB.  This is sometimes be due to coarse-gaining, if the structure doesn't have any of the corresponding CG atoms.");
	}
## default box size if 1nm larger than system size in each direction
	my $xrange=($xmax-$xmin)+$boxbuffer*2;
	my $yrange=($ymax-$ymin)+$boxbuffer*2;
	my $zrange=($zmax-$zmin)+$boxbuffer*2;

	if(defined $centersystem){
		print("Will shift coordinates so that the molecule is centered in the box\n\n");
		for (my $I=0;$I<scalar(@atominfo);$I++){
			${$atominfo[$I]}[5]-=$xmin-$boxbuffer;
			${$atominfo[$I]}[6]-=$ymin-$boxbuffer;
			${$atominfo[$I]}[7]-=$zmin-$boxbuffer;
		}
	}


 ## ADJUST GRO FILE ##
	close(PDB);
	if($outputGRO ne ""){
		open(GRO,">$outputGRO") or smog_quit("can not open $outputGRO for writing");
		print GRO "Gro file for a structure based model, generated with SMOG Version $VERSION\n";
		print GRO $counter,"\n";
		foreach my $atoms(@atominfo){
			my @atom=@{$atoms};
	 	       	printf GRO ($atom[0],$atom[1],$atom[2],$atom[3],$atom[4],$atom[5],$atom[6],$atom[7]);
		}
		print GRO "$xrange $yrange $zrange\n";
		close(GRO);
		print "$outputGRO written\n"; 
	}

	if($outputg96 ne ""){
		open(G96,">$outputg96") or smog_quit("can not open $outputg96 for writing");
		print G96 "TITLE\n";
		print G96 "g96 file for a structure based model, generated with SMOG Version $VERSION\n";
		print G96 "END\nPOSITION\n";
		foreach my $atoms(@atominfo){
			my @atom=@{$atoms};
	 	       	printf GRO ($atom[0],$atom[1],$atom[2],$atom[3],$atom[4],$atom[5],$atom[6],$atom[7]);
		}
		print G96 "END\nBOX\n";
		printf G96 ("%15.9f%15.9f%15.9f\n",$xrange, $yrange, $zrange);
		print G96 "END\n";
		close(G96);
		print "$outputg96 written\n"; 
	}

	# save full PDB-precision gro. -keep4SCM not given, then it will be deleted later.
	open(GRO,">$outputGRO4SCM") or smog_quit("can not open $outputGRO4SCM for writing");
	print GRO "Temp Gro file with PDB precision for SCM calculations.\n";
	print GRO $counter,"\n";
	print GRO "$atominfo4SCM";
	print GRO "$xrange $yrange $zrange\n";
	close(GRO);

	
 ## CREATE NDX FILE ##
	open(NDX,">$outputNDX");
	
	foreach my $chain (sort {$a <=> $b} keys %chainHash) 
	{
	       print NDX "[ $chain ]\n";
	       print NDX join("\n",@{$chainHash{$chain}});
	       print NDX "\n\n";
	}
	close(NDX);
}

sub parseInputFolder
{
	my ($folderName) = @_;
	$folderName = $1 if($folderName=~/(.*)\/$/);
	opendir(my $folder,$folderName);
	my $bif;my $sif;my $b;my $nb;my $extras;
	my $bifexists=0;
	my $sifexists=0;
	my $nbexists=0;
	my $bexists=0;
	my $extrasexists=0;
	my $iondefexists=0;
	while(my $file = readdir($folder)){
                if($file =~ /^\./){
                        # skipping hidden files. They can sometimes creep in due to OSX/LINUX incompatibilities
                        next;
                }

		if($file =~ m/\.bif$/){
			$bifexists++;
			$bif = $file;$bif = "$folderName/$bif";
			print "Found .bif file $bif\n";
			next;
		}elsif($file =~ m/\.sif$/){
			$sifexists++;
			$sif = $file;$sif = "$folderName/$sif";
			print "Found .sif file $sif\n";
			next;
		}elsif($file =~ m/\.b$/){
			$bexists++;
			$b = $file;$b = "$folderName/$b";
			print "Found .b file $b\n";
			next;
		}elsif($file =~ m/\.nb$/){
			$nbexists++;
			$nb = $file;$nb = "$folderName/$nb";
			print "Found .nb file $nb\n";
			next;
		}elsif($file =~ m/\.extras$/ || $file =~ m/^extras$/) {
			$extrasexists++;
			$extrasfile = "$folderName/$file";
			print "Found extras file $extrasfile\n";
			next;
		}elsif($file =~ m/\.ions.def$/ || $file =~ m/^ions.def$/) {
			$iondefexists++;
			$iondeffile = "$folderName/$file";
			print "Found ions.def file $iondeffile\n";
			next;
		}elsif($file !~ m/^[Rr][Ee][Aa][Dd][Mm][Ee]$/ && $file !~ m/^\./) {
			# note that READMEs are ignored
			smog_note("Found unused file \"$file\" in the template directory");	
		}
	}
        print "\n";
	$bifForSCM = $bif;

	if($bifexists >1){
		smog_quit ("Found multiple .bif files in directory $folderName");
	}elsif($bifexists ==0){
		smog_quit (" .bif file not found in directory $folderName");
	}
	if($sifexists >1){
		smog_quit ("Found multiple .sif files in directory $folderName");
	}elsif($sifexists ==0){
		smog_quit (" .sif file not found in directory $folderName");
	}
	if($bexists >1){
		smog_quit ("Found multiple .b files in directory $folderName");
	}elsif($bexists ==0){
		smog_quit (" .b file not found in directory $folderName");
	}
	if($nbexists >1){
		smog_quit ("Found multiple .nb files in directory $folderName");
	}elsif($nbexists ==0){
		smog_quit (" .nb file not found in directory $folderName");
	}
	if($extrasexists >1){
		smog_quit ("Found multiple extras (or .extras) files in directory $folderName");
	}

	print "Validating XML format of $bif\n";
	validateXML($bif,"bif");
	print "Validating XML format of $sif\n";
	validateXML($sif,"sif");
	print "Validating XML format of $b\n";
	validateXML($b,"b");
	print "Validating XML format of $nb\n";
	validateXML($nb,"nb");
	if($extrasexists ==1){
		print "Checking format of $extrasfile\n";
		checkExtras($extrasfile);
	}
	setInputFileName($bif,$sif,$b,$nb,$iondeffile);
	
}

sub header
{
	my $header="******* ******* ******* ******* ******* SMOG v$VERSION ******* ******* ******* ******* *******";
	my $gitver=getgitver;
	if($gitver ne ""){
		$gitver="\nTHIS VERSION IS FROM A GIT REPO. COMMIT NUMBER\n$gitver\n";
	}
	my $headw=length($header);
	printdashed($headw);
	print "\n$header\n";

	my $tmpstring = <<"EOT";
$gitver
Thank you for using the Structure-based Model (SMOG) software

This package is the product of contributions from a number of people, including:
Jeffrey Noel, Mariana Levi, Antonio Oliveira, VinÃ­cius Contessoto,
Esteban Dodero-Rojas, Mohit Raghunathan, Joyce Yang, Prasad Bandarkar,
Udayan Mohanty, Ailun Wang, Heiko Lammert, Ryan Hayes,
Jose Onuchic & Paul Whitford         

Copyright (c) 2015,2016,2018,2021,2022,2024 The SMOG development team at
The Center for Theoretical Biological Physics
Rice University and Northeastern University

SMOG v$VERSION, Shadow and OpenSMOG are available at http://smog-server.org

You can direct questions to info\@smog-server.org, or the smog-users forum, 
which can be found at https://mailman.rice.edu/mailman/listinfo/smog-users

EOT

	printcenter($headw,$tmpstring);
	printdashed($headw);
	print "\nSMOG 2 called with the command:\n";
	print "smog2 ";
	foreach my $filen(@ARGV){
		print "$filen ";
	}	
	print "\n";
}

sub usage
{
	print <<EOT;

usage: smog2 .. options ..

   Options
     I/O flags  
       -i [molecule.pdb]       : input PDB to generate Hamiltonian
       -g [smog.gro]           : output .gro file name
       -o [smog.top]           : output .top file name
       -s [smog.contacts]      : output .contacts file name
       -n [smog.ndx]           : output .ndx file name
       -c <file name>          : input contact map file
       -SCMorig                : directly save SCM contact map (i.e. not PDB numbering).  useful for debugging
       -dname [smog]           : default name to use for all output files
       -OpenSMOGxml [smog.xml] : file name for OpenSMOG xml file (requires use of -OpenSMOG)
       -backup [yes]           : back up any pre-existing output files
       -freecoor               : allow for free-format (space/tab/etc delimited) coordinate fields in PDB

     Force Field Designation
       -AA                     : use default All-atom model
       -AAgaussian             : use default All-atom model with gaussian contacts
       -CA                     : use default Calpha protein model
       -CAgaussian             : use default Calpha protein model with gaussian contacts
       -t [templateFolder]     : folder containing templates of molecular and interaction definitions. required when defaults are not used
       -tCG [templateFolder]   : folder containing templates used for coarse graining. indicates that the program should coarse grain
       -nocheck                : turn off template cross-checks. may sometimes be useful
                                   when using old templates with new versions of SMOG

     Coordinate Processing Options
       -center                 : center the system in a box
       -boxbuffer  [1]         : set box size such that there is space between the molecule and the boundary (default: 1nm)

     Force Field Modifications/exceptions
       -limitbondlength            : if a bond length is outside of the allowable range, set it to limiting value
       -limitcontactlength         : if a contact length is too short, set it to the minimal value
       -deleteshortcontact         : if a contact length is too short, don't include it in the model

     Misc. Options
       -OpenSMOG                   : make files compatible with the OpenSMOG library for OpenMM  
       -ignH                       : ignore any atoms with name starting with 'H' in the internal contact algorithm
       -warn [0]                   : convert the first N fatal errors to warnings  
                                       Convert all if N=-1 (Caution: Consult manual before using this option)
       -help                       : show options 
EOT
	if ( @_ ){
		smog_quit("Flag \"@_\" not recognized, or is missing arguments.");
	}else{
		exit(0);
	}
}

sub setContactParams
{
	my $method = $contactSettings->{"method"};
	my $params = "";
	my $proteinDelta = 3;
	if(exists $contactSettings->{"proteinDelta"}) { $proteinDelta = $contactSettings->{"proteinDelta"}}
	if($method =~ m/shadow/)
	{
		my $radius = $contactSettings->{"shadowRadius"};
		my $radiusBonded = $contactSettings->{"shadowRadiusBonded"};
		my $dist = $contactSettings->{"contactDistance"};
		$params="-m shadow -c $dist -s $radius -br $radiusBonded -bif $bifForSCM -pd $proteinDelta --smog2output --showProgress";
	}
	elsif($method =~ m/cutoff/) 
	{
		my $dist = $contactSettings->{"contactDistance"};
		my $radius = 0.0;
		my $radiusBonded = 0.0;
		$params="-m shadow -c $dist -s $radius -br $radiusBonded -bif $bifForSCM -pd $proteinDelta --smog2output --showProgress";
	}
	else {smog_quit ("Contact map method $method is not supported.");}
	if($ignoreHydrogen == 1) { $params = $params." --ignoreH "; }
	return $params;
}

sub printNotes
{
	my $notes = "";
	## CHECK FOR .notes meta file ##
	if($coarseFolder && -e "$coarseFolder/.notes")
	{
		open(NOTES,"$coarseFolder/.notes");
		$notes = join("",<NOTES>);
		close(NOTES);
	}
	elsif(-e "$inputFolder/.notes")
	{
		open(NOTES,"$inputFolder/.notes");
		$notes = join("",<NOTES>);
		close(NOTES);
	}
	else
	{
		$notes = "";
	}

	if ($notes ne ""){
print <<EOT2;

#################################### TEMPLATE NOTES ####################################

$notes

########################################################################################

EOT2
	}
}


sub printCitation
{
	my $citationFile = "";
	## CHECK FOR .citation meta file ##
	if($coarseFolder && -e "$coarseFolder/.citation")
	{
		open(CITE,"$coarseFolder/.citation");
		$citationFile = join("",<CITE>);
		close(CITE);
	}
	elsif(-e "$inputFolder/.citation")
	{
		open(CITE,"$inputFolder/.citation");
		$citationFile = join("",<CITE>);
		close(CITE);
	}
	else
	{
		$citationFile = "";
	}
      	my $osref="";
	if(defined $OpenSMOG){
		$osref="--OpenSMOG--
Oliveira AB, Contessoto VG, Hassan A, Byju S, Wang A, Wang Y, Dodero-Rojas E,
Mohanty U, Noel JK, Onuchic JN, Whitford PC.
SMOG 2 and OpenSMOG: Extending the limits of structure-based models. (2021)
Protein Science, DOI: 10.1002/pro.4209.
"
	}

print <<EOT;

########################################################################################

              We kindly ask that you cite the appropriate primary references
             when using SMOG models. See http://www.smog-server.org/refs.html

--Software-- 
Noel JK, Levi M, Raghunathan M, Lammert H, Hayes R, Onuchic JN, and Whitford PC. (2016)
SMOG V2, A Versatile Software Package for Generating Structure-Based Models.
PLoS Comput Biol 12(3): e1004794. doi:10.1371/journal.pcbi.1004794

$osref
$citationFile
########################################################################################

EOT

}

sub freeMemoryForShadow
{
	undef %resPDL;
	undef %bondPDL;
	undef %isBOND;
	undef %AngleData;
	undef %DihedralData;
	undef %BondData;
	undef $contactPDL;
	undef %foundBtype;
	undef %foundAtype;
	undef %foundDtype;
}

sub OpenSMOGSwitchPotFlag{
	foreach my $I(@OSswitchlist){
		$fTypes{$I}=-2;
                # this hash is to allow the code to know when we are using an OpenSMOG potential for default dihedral definitions.  The issue that arises is that OpenMM uses radians and SMOG2 uses degrees in the template files (for default potentials). For custom potentials, then the user provides expressions in radians, and this flag is not needed.
		$fTypesdefault{$I}=0;
	}
}

sub parseTemplatesAndPDB
{
	my ($inputFolder,$inputPDB,$CGenabled,$CGstage) = @_;
    
    	## TEST IF SMOG PATH EXISTS ##
    	if(!$ENV{"SMOG_PATH"}){smog_quit("SMOG_PATH environment variable not set");}
	$| = 1;
	parseInputFolder($inputFolder); 

	
	#####################
    	## PARSE TEMPLATES ##
    	#####################
	## parse .sif File ##
	parseSif($OSref);
	## parse .nb file  ##
	parseNonBonds($OSref);
	## parse .b file   ##
	parseBonds();
	## parse .bif File ##
	parseBif();

	## if present, read in ions.def file ##
	parseIons($iondeffile);

	print "\nDone parsing templates.\n";

	unless($nocheck eq "yes"){ 
	    	print "\nChecking template definitions for consistency.\n";
		my $checkmessage=checkenergygroups();
		$checkmessage.=checkNONBONDnames();
		$checkmessage.=checkBONDnames();
		$checkmessage.=checkPAIRnames();
		$checkmessage.=checkREScharges();
		$checkmessage.=checkRESenergygroups();
		$checkmessage.=checkCONNenergygroups();
		$checkmessage.=checkRESimpropers();
		$checkmessage.=checkFunctions();
		$checkmessage.=checkIons();
		if($checkmessage ne ""){
			smog_quit("Validation of templates failed. See messages below:\n\n$checkmessage");
		}
	}

	# no need to initialize these things if we are only making a map file
	&initializeDirectives;
	
	if(defined $OpenSMOG){
		# switch some potentials to be treated as OpenSMOG potentials.  This will ensure they are saved to the xml file
		&OpenSMOGSwitchPotFlag;
	}	
	print "\nPre-processing templates\n";
	## Find Bonds ##
	createBondFunctionals();
	## Find Angles ##
	createDihedralAngleFunctionals();
	###############
    	## PARSE PDB ##
    	###############
	print "\nReading $inputPDB\n\n";
	## CREATE GRO FILE ##
	convertPDBToGroNdx($inputPDB,$groFile,$g96File,$groFile4SCM,$ndxFile,$userProvidedMap,$freecoor);
	my $PDBhandle=checkPDB($inputPDB,$CGenabled,$CGstage,$freecoor);
	parsePDBATOMS($PDBhandle,$CGenabled,$CGstage,$freecoor);
	catPDL();
}

sub printBondedTopOutput {

	my ($inputPDB) = @_;
        if($countDihedrals){
		print "Counting dihedrals\n";
		getSetDiheCounts(\%DihedralData);
        }else{
        	print "Will not count/rescale dihedrals with common middle bonds.\n";
        }
	## SET DIHEDRAL RATIOS ##
	if($normalizevals){
		# only set ratios if normalization is on.  It is faster to not use it.
		print "Setting energetic ratios\n";
		setRatios(\%DihedralData,\%bondPDL,$totalAtoms,\%allAtoms);
	}
	print "Processing atoms\n";
	getAtomTypes(\%allAtoms);
 	# adding extras at this point is a bit out of place.  but, it is important, in order to verify that all bonds have bondtypes, etc.
	addExtras($extrasfile);
	saveAtomTypes();
	my %atomIndex2Line=readAtoms($inputPDB);

	## CALCULATE BONDS/CONNECTED BONDS ##
	print "Checking and saving bonds\n";
	my %bondvectors;
	printOrderedBonds(\%bondFunctionals,\%resPDL,\%BondData,\%isBOND,\%bondPDL,\%atomIndex2Line,\%allAtoms,\%bondvectors);

	## CALCULATE ANGLES ##
	print "Checking and saving angles\n";
	printOrderedAngles(\%AngleData,\%isBOND,\%bondPDL,\%atomIndex2Line,\%allAtoms,\%bondvectors);

	## CALCULATE DIHEDRALS ##
	print "Checking and saving dihedrals\n";
	printOrderedDihedrals(\%DihedralData,\%isBOND,\%bondPDL,\%allAtoms,\%bondvectors);

}

sub generateContactMap {
	my ($groFile4SCM,$ndxFile,$shadowFile,$topFile) = @_;
	## CALL SHADOW/PARSE CONTACTS ##
	print "Starting contact calculations ...\n  ";
	my $SCMparams = setContactParams();
    	my $memoryMax = "";
	my $absAtomCount = keys(%allAtoms);
	#AKE lattice with 6e5 atoms needs 70 MB. Use 80MB for safety...
	my $megabytesNeeded = int($absAtomCount / 60000 * 80);
	if( $megabytesNeeded > 100 ) #default java heapsize is 1/4 physical memory. Don't think anyone will have <400MB these days 
    	{
		print "JAVA HEAP SIZE INCREASED to $megabytesNeeded Mb\n";
		$memoryMax = "-Xmx$megabytesNeeded"."m";
    	} 
	
	## Delete Preexisting contact file ##
	if(-e $shadowFile){unlink($shadowFile);}
	
	## Free Memory for Shadow ##
	freeMemoryForShadow();
	
	if((!exists $ENV{SMOG_PATH}) || !(-e "$ENV{SMOG_PATH}/src/tools/SCM.jar")){smog_quit ("Can't find Shadow executable. Make sure SMOG_PATH is set correctly.")}
	print "Calling $ENV{SMOG_PATH}/src/tools/SCM.jar \n";
	system("java $memoryMax -jar $ENV{SMOG_PATH}/src/tools/SCM.jar -g $groFile4SCM -freecoor -t $topFile -o $shadowFile -ch $ndxFile $SCMparams ");
}

sub appendDefaults
{
	my $combrule = $interactions->{"gmx-combination-rule"};
	my $nbfunc = $interactions->{"nbfunc"};
	my $genpairs = $interactions->{"gen-pairs"};
	my $fudgeLJ = $interactions->{"fudgeLJ"};
	my $fudgeQQ = $interactions->{"fudgeQQ"};
	my $nbfuncv=$nbfunc;
	if(exists $interactions->{"CustomNonBonded"} && defined $OpenSMOG){
		# if we are using a CustomNonBonded with OpenSMOG, then we will need to give a nbfunc that can be understood by the gromacs top parser.  But, the function type listed will be deleted and replaced in openSMOG.
		$nbfuncv=1;
	}
	if($fudgeLJ == -1 && $fudgeQQ == -1){
		addToTop("defaults", "; nbfunc comb-rule gen-pairs\n");
		addToTop("defaults", "  $nbfuncv      $combrule         $genpairs\n");
	}
	if($fudgeLJ != -1 && $fudgeQQ == -1){
		addToTop("defaults", "; nbfunc comb-rule gen-pairs fudgeLJ\n");
		addToTop("defaults", "  $nbfuncv      $combrule         $genpairs        $fudgeLJ\n");
	}
	if($fudgeQQ != -1){
		addToTop("defaults", "; nbfunc comb-rule gen-pairs fudgeLJ fudgeQQ\n");
		addToTop("defaults", "  $nbfuncv      $combrule         $genpairs        $fudgeLJ       $fudgeQQ\n");
	}
}

sub appendContacts {
	my($fileName,$fileName2,$userProvidedMap,$saveSCMorig) = @_;
	#Parse the contact map, either the generated one or the user provided one
	$numContacts = parseCONTACT($shadowFile,$ContactFile,$userProvidedMap,$CGenabled,$saveSCMorig);
	if($numContacts == 0){smog_quit ("There are 0 contacts.  See earlier messages for possible errors");}
	my $absAtomCount = keys(%allAtoms);
	print "If normalization is used, the total number of atoms included in normalization\nwill be $totalAtoms, while $absAtomCount atoms are in the system.\n";
	print "Completing final details...\n";
	## CALCULATE PAIRS and EXCLUSIONS ##
 	calculateContacts($contactPDL,\%resPDL,\%allAtoms,$numContacts,$totalAtoms);
}



