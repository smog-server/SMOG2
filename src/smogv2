#!/usr/bin/perl -w
#####################################################################
# smogv2: Generate a structure-based model
#####################################################################

#####################
## COMPILE HEADERS ##
#####################
use strict;
use warnings;
####################
## MODULE HEADERS ##
####################
use XML::Simple;
use Data::Dumper;
use templateParser;
use pdbParser;
use PDL;
use mathFunctions;
use setRatios;
use Getopt::Long;
use XML::SAX::ParserFactory;
use XML::Validator::Schema; 
use IPC::Open3;


######################
## GLOBAL VARIABLES ##
######################
my $VERSION="2.0";
my $angToNano = 0.1;
my @diheArr;
my $OUTPUT;
my $help;my $inputPDB; my $inputFolder=""; my $bifForSCM;
my $ignAllContacts=0;
my $topFile = "smog.top";
my $groFile = "smog.gro";
my $ContactFile = "";
my $shadowFile = "smog.contacts";
my $ndxFile = "smog.ndx";
my $mapOpt = "shadow";my $contactOpt = "6 1";
my $numContacts = 0;
my $coarseFolder = ""; ## Coarse Grain Folder ##
my $contactRes = ""; ## Duplicate ##
my $AAdefault = 0; ## Duplicate ##
my $CAdefault = 0; ## Duplicate ##
my $noexit=0;
our $CGenabled=0; ## enable coarse-graining
## this is the array that defines how function names are converted to gromacs function types
our %fTypes = (	'bond_harmonic' => '1',
		'bond_type6' => '6',
		'angle_harmonic' => '1',
		'angle_free' => '0',
		'dihedral_cosine'=>'1',
		'dihedral_harmonic' => '2',
		'dihedral_free' => '0',
		'contact_1'=>'1',
		'contact_2'=>'1',
		'contact_gaussian'=>'6'
		);


#####################
# Error call        #
# ##################

sub smog_quit
{
	my ($LINE)=@_;
	print "\n\nFATAL ERROR: $LINE\n\n";
	unless($noexit){
		exit;
	}
}

#####################
## CALCULATE BONDS ##
#####################

##
# Combined bond calculation,sorting, and printing
sub printOrderedBonds
{

  my($bondFunctHandle1,$whichPDL1,$bondHandle2,$whichPDL2) = @_;
  my @bondCache; ## CACHE BONDS TO ORDER

  ## print directive headers ##
  print $OUTPUT "\n[ bonds ]\n";
  print $OUTPUT ";ai     aj      func    r0(nm)  Kb\n";
  ## Cache Bonds ##
  calculateBonds1($bondFunctHandle1,$whichPDL1,\@bondCache);
  calculateBonds2($bondHandle2,$whichPDL2,\@bondCache);

  ## Sort bonds by i then j ## 
  @bondCache = sort {($a->{"i"} <=> $b->{"i"}) || ($a->{"j"} <=> $b->{"j"}) } @bondCache;
  
  ## Print our sorted bonds ##
  foreach my $p(@bondCache)
  {print $OUTPUT $p->{"v"};}
}


##
# calculate bond angle of a specific residue  PDL
sub calculateBondsHelper1
{
 my($bondHash,$inputPDL,$bondCache) = @_;
 my $bondArr = $bondHash->{"bonds"};
 my $bondFunc =$bondHash->{"functions"};
 my $bondIndex = 0;
 foreach my $bonds(@{$bondArr})
 {
	my ($atomOne,$atomTwo) = split("-",$bonds);
	my $outer = slice($inputPDL,"0:2,$atomOne,:")-slice($inputPDL,"0:2,$atomTwo,:");
	my @bondList = (sqrt(inner($outer,$outer))*$angToNano)->flat()->list();
	my @indexList1 = slice($inputPDL,"3:3,$atomOne,:")->flat()->list();
	my @indexList2 = slice($inputPDL,"3:3,$atomTwo,:")->flat()->list();
	for(my $i=0;$i<scalar(@bondList);$i++)
	{
		#print $OUTPUT bondOutput($bondFunc->[$bondIndex],$indexList1[$i],$indexList2[$i],$bondList[$i]);} 
  push @{$bondCache}, {'i' => $indexList1[$i],'j' => $indexList2[$i], 'v' => bondOutput($bondFunc->[$bondIndex],$indexList1[$i],$indexList2[$i],$bondList[$i])};
 }
		$bondIndex++;

 }
}

##
# Setup the calculation of bond angles of all the residues,
#	then call calculateBondsHelper() with a specific residue
sub calculateBonds1
{
 my($bondFunctHandle,$whichPDL,$bondCache) = @_;
 #print $OUTPUT "\n[ bonds ]\n";
 #print $OUTPUT ";ai     aj      func    r0(nm)  Kb\n";
 foreach my $res(keys %{$bondFunctHandle})
 {
	if(!exists $whichPDL->{$res}){next;}
	calculateBondsHelper1($bondFunctHandle->{$res},$whichPDL->{$res},$bondCache);
 }
}


##
#Setup the calculate of bond angles of all combined residues,
#then call connCalculateBondsHelper() with a specific residue
sub calculateBonds2
{
 my($bondHandle,$whichPDL,$bondCache) = @_;
 foreach my $counter(keys %{$bondHandle})
 {
	calculateBondsHelper2($bondHandle->{$counter},$whichPDL->{$counter},$bondCache);

 }
}
##
#calculate bond angle of a specific combined residue PDL
sub calculateBondsHelper2
{
 my($bondInfo,$inputPDL,$bondCache) = @_;
 my $size = $bondInfo->dim(1);
 for(my $i=0;$i<$size;$i++)
 {
 my $atomOne = sclr(slice($bondInfo,"0:0,$i:$i"));
 my $atomTwo = sclr(slice($bondInfo,"1:1,$i:$i")); 
 my $func = sclr(slice($bondInfo,"2:2,$i:$i"));
 my $outer = slice($inputPDL,"0:2,$atomOne,:")-slice($inputPDL,"0:2,$atomTwo,:");
 my $output = sclr(sqrt(inner($outer,$outer))*$angToNano);
 $atomOne = sclr(slice($inputPDL,"3:3,$atomOne,:"));
 $atomTwo = sclr(slice($inputPDL,"3:3,$atomTwo,:"));
  #print $OUTPUT bondOutput(intToFunc("bonds",$func,""),$atomOne,$atomOne,$output);
 push @{$bondCache}, {'i' => $atomOne,'j' => $atomTwo, 'v' => bondOutput(intToFunc("bonds",$func,""),$atomOne, $atomTwo,$output)};
 }
}

##
# Convert internal bond function format to gromacs function format,
# internal format is f()+g()
sub bondOutput
{
 my($inputFunc,$i,$j,$values) = @_;
 if(!$inputFunc){smog_quit ("BONDOUTPUT::NO FUNCTION DEFINED");}
 ## Remove white spaces from string ##
 $inputFunc =~ s/^\s+|\s+$//g;
 ## If $input contains a + ##
 my @funcs = split(/\+/,$inputFunc); ## split combination of functions
 my $outputString="";
 my @paramArr;
 my $fType=""; my $formattedString;
	## Parse each part of the function ##
 foreach my $fun(@funcs)
 {
	my $paramFormat="";
	($fType,@paramArr) = bondFuncParser($fun);
     ## $paramArr[0] is bond angle
	if($paramArr[0] =~ /\?/){$paramArr[0]=$values;} ## non-native option used
	 
	 ## Check bonds threshold ##
	 if($paramArr[0] < $interactionThreshold->{"bonds"}->{"shortBond"}
	 || $paramArr[0] > $interactionThreshold->{"bonds"}->{"longBond"})
	 {print("\n\nWARNING: Distance between atoms $i and $j is larger than bonds threshold: r=$paramArr[0]\n\n");}
	
 ## Format output <i j function p1 p2 ... pn>
 foreach(@paramArr){$paramFormat="$paramFormat %12.9e";}
	$formattedString = sprintf("%9d%9d%6d$paramFormat",$i,$j,$fType,@paramArr);
	$outputString = "$outputString$formattedString\n";
 }
 return $outputString;
 }

##
# Given a user defined function parse values
sub bondFuncParser
{
	my($bondFunc) = @_;
	my $fType;my @paramArr;my $directive;
	my $funcName = ""; my $params = "";
 ($bondFunc =~ m/(.*)\((.*)\)/);
	$funcName = $1;
	$params = $2;
	($fType,$directive) = returnFunction($funcName); ## Obtain Gromacs function type
	if($directive ne "bonds"){smog_quit ("$funcName is not a valid bonds function");}
 @paramArr = split(",",$params); ## Parse all parameters
 foreach $params(@paramArr){$params =~ s/^\s+|\s+$//g;}
	return ($fType,@paramArr);
}

######################
## CALCULATE ANGLES ##
######################

##
# Combined bond calculation,sorting, and printing
sub printOrderedAngles
{
		my($connAngleFunctionals,$connPDL) = @_;
  my @angleCache; ## CACHE BONDS TO ORDER

  ## print directive headers ##
  print $OUTPUT "\n[ angles ]\n";
  print $OUTPUT ";ai  aj   ak  func  th0(deg)   Ka\n";

  ## Cache Bonds ##
  connCalculateAngles($connAngleFunctionals,$connPDL,\@angleCache);

  ## Sort angles by i,j then k ## 
  @angleCache = sort {($a->{"i"} <=> $b->{"i"}) || ($a->{"j"} <=> $b->{"j"}) || ($a->{"k"} <=> $b->{"k"})} @angleCache;
  
  ## Print our sorted bonds ##
  foreach my $p(@angleCache)
  {print $OUTPUT $p->{"v"};}
}

##
# calculate 3 angle value of a specific residue PDL
sub calculateAnglesHelper
{
 my($angleArr,$inputPDL) = @_;
 
 foreach my $angles(@{$angleArr})
 {
	my ($atom1,$atom2,$atom3) = split("-",$angles);
 my $left = norm(slice($inputPDL,"0:2,$atom1,:")-slice($inputPDL,"0:2,$atom2,:"));
	my $right = norm(slice($inputPDL,"0:2,$atom3,:")-slice($inputPDL,"0:2,$atom2,:"));
	my $acos = inner($left,$right);
 }
}

##
# Setup the calculation of 3 angle value of all the residues,
# then call calculateAnglesHelper() with a specific residue
sub calculateAngles
{
 my($angleFunctHandle,$whichPDL) = @_;
 foreach my $res(keys %{$angleFunctHandle})
 {
	calculateAnglesHelper($angleFunctHandle->{$res}->{"angles"},$whichPDL->{$res});
 }
}

##
# Setup the calculate of bond angles of all combined residues,
# then call connCalculateAnglesHelper() with a specific residue
sub connCalculateAngles
{
 my($angleFunctHandle,$whichPDL,$angleCache) = @_;
 #print $OUTPUT "\n[ angles ]\n";
 #print $OUTPUT ";ai  aj   ak  func  th0(deg)   Ka\n";

 foreach my $res(keys %{$angleFunctHandle})
 {
	connCalculateAnglesHelper($angleFunctHandle->{$res},$whichPDL->{$res},$angleCache);
 }
}

##
# calculate bond angle of a specific combined residue PDL
sub connCalculateAnglesHelper
{
 my($angleArr,$inputPDL,$angleCache) = @_;
 my $size = $angleArr->dim(1);
 
 for(my $i=0;$i<$size;$i++)
 {
	my ($atom1,$atom2,$atom3,$func) = $angleArr->slice(":,$i:$i")->list;
  	my $left = norm(slice($inputPDL,"0:2,$atom1,:")-slice($inputPDL,"0:2,$atom2,:"));
	my $right = norm(slice($inputPDL,"0:2,$atom3,:")-slice($inputPDL,"0:2,$atom2,:"));
	my $acos = mathFunctions::rad_to_deg(mathFunctions::acos(sclr(inner($left,$right))));
	
	my $atomi1 = sclr(slice($inputPDL,"3:3,$atom1,:"));
	my $atomi2 = sclr(slice($inputPDL,"3:3,$atom2,:"));
	my $atomi3 = sclr(slice($inputPDL,"3:3,$atom3,:"));

  	my $val=angleOutput(intToFunc("angles",$func,""),$atomi1,$atomi2,$atomi3,$acos);
	if(!$val) {next;}
  	push @{$angleCache}, {'i' => $atomi1,'j' => $atomi2,'k' =>$atomi3, 'v' => angleOutput(intToFunc("angles",$func,""),$atomi1,$atomi2,$atomi3,$acos)};
 }
}

## 
# Convert internal angle function format to gromacs function format
sub angleOutput
{
 my($inputFunc,$i,$j,$k,$values) = @_;
	if(!$inputFunc){smog_quit ("ANGLEOUTPUT::NO FUNCTION DEFINED");}
 ## Remove white spaces from string ##
 $inputFunc =~ s/^\s+|\s+$//g;
 ## If $input contains a + ##
	my @funcs = split(/\+/,$inputFunc);
	my $outputString="";
	my $value="";my $kd="";
	my $fType="";my @paramArr;
	my $formattedString="";
	foreach my $fun(@funcs)
	{
	my $paramFormat="";
	($fType,@paramArr) = angleFuncParser($fun);
	if($fType != 0){
		if($paramArr[0] =~ /\?/){$paramArr[0]=$values;} ## non-native option used
	
		## Check angles threshold ##
	 	if($paramArr[0] < $interactionThreshold->{"angles"}->{"smallAngles"})
	 	 {print("\n\nWARNING: ANGLE between atoms $i $j $k smaller than smallAngles (see .sif): theta=$paramArr[0]\n\n");}
	 	if($paramArr[0] > $interactionThreshold->{"angles"}->{"largeAngles"})
	 	 {print("\n\nWARNING: ANGLE between atoms $i $j $k greater than largeAngles (see .sif): theta=$paramArr[0]\n\n");}
	
 		## Format output <i j k function p1 p2 ... pn>
 		foreach(@paramArr){$paramFormat="$paramFormat %12.9e";}
			$formattedString = sprintf("%9d%9d%9d%6d$paramFormat",$i,$j,$k,$fType,@paramArr);
			$outputString = "$outputString$formattedString\n";
		}
	}
	if($fType != 0){
		return $outputString; 
	}
}

##
# Given a user defined angle function parse values
sub angleFuncParser
{
	my($angFunc) = @_;
	my $fType;my @paramArr;my $directive;
	my $funcName = ""; my $params = "";
 ($angFunc =~ m/(.*)\((.*)\)/);
	$funcName = $1;
	$params = $2;
	($fType,$directive) = returnFunction($funcName); ## Obtain Gromacs function type
	if($directive ne "angles"){smog_quit ("$funcName is not a valid angles function");}
 @paramArr = split(",",$params); ## Parse all parameters
 foreach $params(@paramArr){$params =~ s/^\s+|\s+$//g;}
	return ($fType,@paramArr);
}

#########################
## CALCULATE DIHEDRALS ##
#########################

##
# Combined dihedral calculation,sorting, and printing
sub printOrderedDihedrals
{
		my($connDiheFunctionals,$connPDL) = @_;
  my @diheCache; ## CACHE BONDS TO ORDER

  ## print directive headers ##
		print $OUTPUT "\n[ dihedrals ]\n";
 	print $OUTPUT ";ai  aj  ak  al  func  phi0(deg) kd mult\n";

  ## Cache Bonds ##
  connCalculateDihedrals($connDiheFunctionals,$connPDL,\@diheCache);

  ## Sort dihedrals by i,j then k ## 
  @diheCache = sort {($a->{"j"} <=> $b->{"j"}) || ($a->{"k"} <=> $b->{"k"}) || ($a->{"i"} <=> $b->{"i"})} @diheCache;
  
  ## Print our sorted bonds ##
  foreach my $p(@diheCache)
  {print $OUTPUT $p->{"v"};}
  print $OUTPUT "\n";
}


##
# calculate dihedral angle of a specific residue PDL
sub calculateDihedralsHelper
{
 my($diheArr,$inputPDL) = @_;
 foreach my $dihedrals(@{$diheArr})
 {
	my ($atom1,$atom2,$atom3,$atom4) = split("-",$dihedrals);
	
 my $b1 = slice($inputPDL,"0:2,$atom2,:")-slice($inputPDL,"0:2,$atom1,:");
	my $b2 = slice($inputPDL,"0:2,$atom3,:")-slice($inputPDL,"0:2,$atom2,:");
	my $b3 = slice($inputPDL,"0:2,$atom4,:")-slice($inputPDL,"0:2,$atom3,:");
	my $n1 = norm(crossp($b1,$b2));
	my $n2 = norm(crossp($b2,$b3));
	my $m1 = crossp($n1,norm($b2));
	my $cos = atan2(inner($m1,$n2),inner($n1,$n2));
	my $negcos = $cos; #$cos->where($cos < 0);
	$negcos*=-1;$negcos+=mathFunctions::pi();
	my $acos = sclr(mathFunctions::rad_to_deg($cos));
	my $atomi1 = sclr(slice($inputPDL,"3:3,$atom1,:"));
	my $atomi2 = sclr(slice($inputPDL,"3:3,$atom2,:"));
	my $atomi3 = sclr(slice($inputPDL,"3:3,$atom3,:"));
	my $atomi4 = sclr(slice($inputPDL,"3:3,$atom4,:"));
 }
}

##
# Setup the calculate of dihedral angles of all the residues,
# then call calculateDihedralsHelper() with a specific residue
sub calculateDihedrals
{
 my($diheFunctHandle,$whichPDL) = @_;
 foreach my $res(keys %{$whichPDL})
 {
	calculateDihedralsHelper($diheFunctHandle->{$res}->{"dihedrals"},$whichPDL->{$res});
 }
}

##
# Setup the calculate of bond angles of all combined residues,
# then call connCalculateBondsHelper() with a specific residue
sub connCalculateDihedrals
{
 my($diheFunctHandle,$whichPDL,$diheCache) = @_;
 #print $OUTPUT "\n[ dihedrals ]\n";
 #print $OUTPUT ";ai  aj  ak  al  func  phi0(deg) kd mult\n";
 foreach my $res(keys %{$diheFunctHandle})
 {
		connCalculateDihedralsHelper($diheFunctHandle->{$res},$whichPDL->{$res},$diheCache);
 }
}

sub connCalculateDihedralsHelper
{
	 my($diheArr,$inputPDL,$diheCache) = @_;
	 my $size = $diheArr->dim(1);
	 for(my $i=0;$i<$size;$i++)
	 {
			my ($atom1,$atom2,$atom3,$atom4,$func,$cD,$eG) = $diheArr->slice(":,$i:$i")->list;
		
		   
	        my $b1 = slice($inputPDL,"0:2,$atom2,:")-slice($inputPDL,"0:2,$atom1,:");
			my $b2 = slice($inputPDL,"0:2,$atom3,:")-slice($inputPDL,"0:2,$atom2,:");
			my $b3 = slice($inputPDL,"0:2,$atom4,:")-slice($inputPDL,"0:2,$atom3,:");
		
			my $n1 = norm(crossp($b1,$b2));
			my $n2 = norm(crossp($b2,$b3));
			my $m1 = crossp($n1,norm($b2));
		
			my $cos = atan2(inner($m1,$n2),inner($n1,$n2));
			my $negcos = $cos;#$cos->where($cos < 0);
	
			$negcos*=-1;$negcos+=mathFunctions::pi();
			my $acos = sclr(mathFunctions::rad_to_deg($cos));
		
			my $atomi1 = sclr(slice($inputPDL,"3:3,$atom1,:"));
			my $atomi2 = sclr(slice($inputPDL,"3:3,$atom2,:"));
			my $atomi3 = sclr(slice($inputPDL,"3:3,$atom3,:"));
			my $atomi4 = sclr(slice($inputPDL,"3:3,$atom4,:"));
	
			## $eG >=0 dihedral is proper dihedral of any functional form
	        if($eG >= 0)
			{
				my $val = dihedralOutput(intToFunc("dihedrals",$func,$eG),$atomi1,$atomi2,$atomi3,$atomi4,$acos,$cD,$eG);
				if(!$val) {next;}
				push @{$diheCache}, {'i' => $atomi1,'j' => $atomi2,'k' =>$atomi3, 'l' => $atomi4, 'v' => dihedralOutput(intToFunc("dihedrals",$func,$eG),$atomi1,$atomi2,$atomi3,$atomi4,$acos,$cD,$eG)};
			}
			## Improper dihedral
			else
			{
				#print $OUTPUT dihedralOutput(intToFunc("impropers",$func,$eG),$atomi1,$atomi2,$atomi3,$atomi4,$acos,$cD);
				push @{$diheCache}, {'i' => $atomi1,'j' => $atomi2,'k' =>$atomi3, 'l' => $atomi4, 'v' => dihedralOutput(intToFunc("impropers",$func,$eG),$atomi1,$atomi2,$atomi3,$atomi4,$acos,$cD,-1)};
	 	   }
	 }
}

## Convert .b dihedral function format to gromacs function format
sub dihedralOutput
{
 my($inputFunc,$ai,$aj,$ak,$al,$values,$ratio,$eG) = @_;
 ## Remove white spaces from string ##
 $inputFunc =~ s/^\s+|\s+$//g;
 ## If $input contains a + ##
 	my @funcs = split(/\+/,$inputFunc);
	my $outputString="";
	my $fType="";my $exportRatio;       
 	my $formattedString="";
	my $valueSend;my @paramArr;
	my $funci=0; my @fTypei;
	foreach my $fun(@funcs)
	{
	my $paramFormat="";
	($fType,@paramArr) = diheFuncParser($fun);

 	if($fType !=0){
		# If there is a ?, then substitute the angle value and apply the multiplicity.  If there is no wild card, then simply use the angle provided
		if($paramArr[0] =~ /\?/){
	         # replace ? with native angles
	   	 $paramArr[0] =~ s/\?/$values/g;
		 # evaluate
		 $paramArr[0] = eval($paramArr[0]);
		 }
		 if( $fType == 1){
	            # Angle will be scaled by multiplicity factor n, if they are cosine functions
	            $paramArr[0] *= $paramArr[2];
		 }
	
	
	        if($paramArr[1] =~ /[*?^&!@#%()]/){smog_quit ("Dihedral weight can only contain numbers, but $paramArr[1] found.")};
	#	my $h=$energyGroups->{$eGTable{$eG}}->{"normalize"};
	#	print "$eG $fType $h\n";
	
		if($fType == 0 and $energyGroups->{$eGTable{$eG}}->{"normalize"} != 0){
			smog_quit("Function type dihedral_free is being used for an energy group with normalize != 0.  This can lead to unpredictable results.");
		}
	
		if($funci == 0){
		  $fTypei[0]= $fType;
	
		  if($fType==1 and $paramArr[1] != 1 and $energyGroups->{$eGTable{$eG}}->{"normalize"} != 0){
		   smog_quit ("Since normalization is turned on, the first cosine dihedral in a sum should have weight of 1.\n In order to adjust overall weight of dihedral, while also imposing normalization, use intraRelativeStrength in .sif file");
		  }
		}elsif($funci != 0 and $fTypei[0] != $fType){
	          smog_quit ("Sums of dihedrals of different types is not supported.");
		}
	
		$funci++;
		## If dihedral kd is normalized or has scaling&normalize ##
	 	$paramArr[1]*=$ratio;
	
		### MINOR KLUDGE TO FIX RIGID/IMPROPER DIHEDRALS BEING OFF BY +-180 ###
		if($fType == 2)
		{
			if($paramArr[0]>180){$paramArr[0]-=180;}else{$paramArr[0]+=180;}
		}
	 
		## Format output <i j k function p1 p2 ... pn>
	 	foreach(@paramArr){$paramFormat="$paramFormat %12.9e";}
	
	 ## MINOR KLUDGE TO FIX MULTIPLICITY FORMATTING FOR TYPE 1 ##
	 ## BLAME PAUL##
	 if($fType eq 1) {$paramFormat=" %12.9e	%12.9e %u";}
	
		$formattedString = sprintf("%9d%9d%9d%9d%3d$paramFormat",$ai,$aj,$ak,$al,$fType,@paramArr);
		$outputString = "$outputString$formattedString\n";
	}
	}
		return $outputString;
 }
 
##
# Given a user defined dihedral function parse values
sub diheFuncParser
{
	my($diheFunc) = @_;
 	my $fType;my @paramArr; my $directive;
	my $funcName = "";my $params = "";
	($diheFunc =~ m/(.*)\((.*)\)/);
	$funcName = $1; $params = $2;

	($fType,$directive) = returnFunction($funcName); ## Obtain Gromacs function type
	if($directive ne "dihedrals"){smog_quit ("$funcName is not a valid dihedrals function");}
	@paramArr = split(",",$params); ## Parse all parameters;
	foreach $params(@paramArr){$params =~ s/^\s+|\s+$//g;}
	return ($fType,@paramArr);
}


########################
## CALCULATE CONTACTS ##
########################

sub calculateContacts
{
	my($contactPDL,$inputPDL,$atomTypes,$numCon,$numAtom) = @_;
	my $atoma; my $atomb;my $fType; my $dist;
	my $nbtypea; my $nbtypeb;
	my $resTypea; my $resTypeb;
	my $contactInterScale;
 	my $dihedralInterScale;
	my $multFactor = 1;
	my $c0; my $c1; 
	my $epsilon;my $cG;my $funct;
 	my $totalStrength; my $outputString;
	my $contactIntraScale;
	my $contactIntraTotal;	
	my $count;
	
	print $OUTPUT "\n\n[ pairs ]\n";
	print $OUTPUT "; ai aj type, A, B\n";
	
	## REMOVE ##
	my $totalEpsilon=0;

	## Sum all initial contact strengths ##	
	for(my $i=0;$i<$numCon;$i++)
	{
			my $normalize;
			$atoma = sclr(slice($contactPDL,"1:1,$i:$i"));
	  		$atomb = sclr(slice($contactPDL,"2:2,$i:$i"));
			$nbtypea = $atomTypes->{$atoma}->[0];
			$nbtypeb = $atomTypes->{$atomb}->[0];
			$resTypea = $atomTypes->{$atoma}->[1];
			$resTypeb = $atomTypes->{$atomb}->[1];
			($funct,$cG) = getContactFunctionals($nbtypea,$nbtypeb);
			if(!$funct || !$cG)
			{smog_quit("No contact Function defined for nbType contacts $nbtypea-$nbtypeb");}
			$normalize = $termRatios->{"contactGroup"}->{$cG}->{"normalize"};
			if(!$normalize){next;}		
			$contactIntraTotal = $termRatios->{"cintraRelativeTotal"};
			$contactIntraScale = $termRatios->{"contactGroup"}->{$cG}->{"intraRelativeStrength"};
			$count+=($contactIntraScale/$contactIntraTotal);
	}

	## Adjust ratio ##
	for(my $i=0;$i<$numCon;$i++)
	{
			my $contactLeftOver;my $diheTotal; my $normalize;
			my $deltaMin=-1;my $scale=-1;my $deltaMax=-1;
			my $resIdxA=0;my $resIdxB=0;
			my $atomA="";my $atomB="";
			
	  		$atoma = sclr(slice($contactPDL,"1:1,$i:$i"));
	  		$atomb = sclr(slice($contactPDL,"2:2,$i:$i"));
			$nbtypea = $atomTypes->{$atoma}->[0];
			$nbtypeb = $atomTypes->{$atomb}->[0];
			$resTypea = $atomTypes->{$atoma}->[1];
			$resTypeb = $atomTypes->{$atomb}->[1];
			($funct,$cG) = getContactFunctionals($nbtypea,$nbtypeb);
			if(!$funct || !$cG)
			{smog_quit("No contact Function defined for nbType contacts $nbtypea-$nbtypeb");} 
			
			$normalize = $termRatios->{"contactGroup"}->{$cG}->{"normalize"};

            ## Stacking scaling ##
            $epsilon = 1;
            if(exists $contactSettings->{"contactScaling"}->{$resTypea}
            && exists $contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb})
            {
              $deltaMin=$contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"deltaMin"};
              $deltaMax=$contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"deltaMax"};

              $scale = $contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"scale"};
              $scale = eval($scale);
              $resIdxA = $allAtoms{$atoma}->[2];
              $resIdxB = $allAtoms{$atomb}->[2];
              
              $atomA = $allAtoms{$atoma}->[3];
              $atomB = $allAtoms{$atomb}->[3];
              ##Atom to boolean##
              $atomA = exists($contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"atomList"}->{$atomA});
              $atomB = exists($contactSettings->{"contactScaling"}->{$resTypea}->{$resTypeb}->{"atomList"}->{$atomB});

              
              if(abs($resIdxB-$resIdxA)>=$deltaMin 
              && abs($resIdxB-$resIdxA)<=$deltaMax
              && $atomA && $atomB)
              {
               $epsilon*=$scale;
              }
              else{$epsilon=1;}
            
            }

			## Non-Native option for contacts ##
			if(!$normalize) {
			$dist = sclr(slice($contactPDL,"3:3,$i:$i"));
			$c0=$dist;
			print $OUTPUT contactOutput($funct,$atoma,$atomb,$c0,$epsilon),"\n";
			}	
			
			else {	
			## DIHE TO CONTACT SCALING ##
			## DIHEDRAL TO CONTACT RATIO IS GLOBAL IRREGARDLESS OF RESIDE TYPE ##
			$totalStrength = $termRatios->{"interRelativeTotal"};
			$diheTotal = $termRatios->{"energyRelative"};
			$contactLeftOver = $numAtom - $numAtom*($diheTotal/$totalStrength);
			$contactLeftOver = $contactLeftOver/$count;
   			$multFactor = $contactLeftOver;

			## CONTACT TO CONTACT SCALING ##			
			$contactIntraTotal = $termRatios->{"cintraRelativeTotal"};
			$contactIntraScale = $termRatios->{"contactGroup"}->{$cG}->{"intraRelativeStrength"};
			$multFactor = $multFactor*($contactIntraScale/$contactIntraTotal);

			$epsilon = $epsilon*$multFactor;
	  		$dist = sclr(slice($contactPDL,"3:3,$i:$i"));
	  		$c0=$dist;
	  		$totalEpsilon+=$epsilon;
			print $OUTPUT contactOutput($funct,$atoma,$atomb,$c0,$epsilon),"\n";
			}
	}
}

##
# Convert internal contact function format to gromacs function format,
# internal format is f()+g()
sub contactOutput
{
 my($inputFunc,$i,$j,$c0,$epsilon) = @_;
 if(!$inputFunc){smog_quit ("CONTACTOUTPUT::NO FUNCTION DEFINED");}
 ## Remove white spaces from string ##
 $inputFunc =~ s/^\s+|\s+$//g;
 ## If $input contains a + ##
 my @funcs = split(/\+/,$inputFunc); ## split combination of functions
 my $outputString="";
 my @paramArr;
 my $fname;
 my $fType=""; my $formattedString;
 ## Parse each part of the function ##
 foreach my $fun(@funcs)
 {
	my $paramFormat="";
	($fType,$fname,@paramArr) = contactFuncParser($fun);

	## LJ CONTACTS N-M polynomial, sigma and epsilon usage ##	
    if($fname eq "contact_1"){
		contactParseNM1(\@paramArr,$c0,$epsilon);
		if($fType != 1){smog_quit ("Only fType=1 is supported with contacts contact_1")}
    }
	## LJ CONTACTS N-M polynomial, CN, CM usage ##	
    elsif($fname eq "contact_2"){
		contactParseNM2(\@paramArr,$c0,$epsilon);
		if($fType != 1){smog_quit ("Only fType=1 is supported with contacts contact_2")}
    }
        ## Gaussian ##
    elsif($fname eq "contact_gaussian"){
	contactParseGaussian(\@paramArr,$c0,$epsilon);
	if($fType != 6){smog_quit ("Only fType=6 is supported with contacts contact_gaussian")}

    }
    else{smog_quit("Contact function name $fname is not supported");}

 	## Format output <i j function p1 p2 ... pn>
 	foreach(@paramArr){$paramFormat="$paramFormat	%12.9e";}
	$formattedString = sprintf("%d %d %d$paramFormat",$i,$j,$fType,@paramArr);
	$outputString = "$outputString$formattedString";
 }
 return $outputString;
 
}

##
# Parse LJ NM sigma eps usage
sub contactParseNM1
{
  my($paramArr,$r0,$epsilon) = @_;
  ##pararArr holds N, M, and whether native distances and weights should be used.
  ##epsilon
  ##r0 is native distance##
  #
  my $cN;my $cM; 
  my $A; my $B;
  my $N; my $M;
  $M=$paramArr->[0];
  $N=$paramArr->[1];
  my $length=scalar @{$paramArr};
  if($length != 4){ smog_quit ("Incorrect number of parameters provided for contact_1. Expecting 4, found $length."); }
  if($N =~ /^\?$/ or $M =~ /^\?$/ or $N  !~ /^\d+$/ or $M  !~ /^\d+$/){smog_quit ("Must provide integers for exponents of function contact_1");}

  if($M>=$N){smog_quit ("When using contact_1, the first exponent provided should be smaller.")}

  $B=-1.0/($M/$N-1.0);
  $A=$M/$N*$B;
  # replace ? with native distance expression
  $paramArr->[2] =~ s/\?/$r0/g;
  #Eval expression
  $r0 = eval($paramArr->[2]);
     
  $A *= $epsilon*$r0**$N;
  $B *= $epsilon*$r0**$M;

  ## normalized option used
  if($paramArr->[3] =~ /^\?$/)
  {
    $paramArr->[3]=$A;
    $paramArr->[2]=$B;
  }
  ## additional rescaling used
  else{
   $A *= $paramArr->[3];
   $B *= $paramArr->[3];
   $paramArr->[3]=$A;
   $paramArr->[2]=$B;
  } 
  ## Shift first value off ##
  shift @{$paramArr};
  shift @{$paramArr};

}

# Parse LJ NM sigma eps usage
sub contactParseNM2
{
  my($paramArr,$r0,$epsilon) = @_;
  ##pararArr holds f(r), g(r), and whether native distances and weights should be used.
  ##epsilon
  ##r0 is native distance##
  #
  my $A; my $B;
  my $F; my $G;
  $F=$paramArr->[1];
  $G=$paramArr->[0];
  my $length=scalar @{$paramArr};
  if($length != 4){ smog_quit ("Incorrect number of parameters provided for contact_2. Expecting 4, found $length."); }

  # replace ? with native distance expression
  $paramArr->[2] =~ s/\?/$r0/g;

  $paramArr->[2] = eval($paramArr->[2]);

  # substitute value of r into f(r) and g(r)
  $F =~ s/\?/$paramArr->[2]/g;
  $G =~ s/\?/$paramArr->[2]/g;

  #Eval expression
  $A = eval($F);
  $B = eval($G);
  $A *= $epsilon; 
  $B *= $epsilon; 


  ## standard normalization used
  if($paramArr->[3] =~ /^\?$/)
  {
    $paramArr->[3]=$A;
    $paramArr->[2]=$B;
  }
  ## additional rescaling used
  else{
   $A *= $paramArr->[3];
   $B *= $paramArr->[3];
   $paramArr->[3]=$A;
   $paramArr->[2]=$B;
  } 
  ## Shift first value off ##
  shift @{$paramArr};
  shift @{$paramArr};

}


##
# Parse Gaussian Params
sub contactParseGaussian
{

 my($paramArr,$r0,$epsilon) = @_;
 my $A=0;my $sigma_G=0;my $a=0;
  ##i=0 is epsilon_c##
  ##i=1 is epsilon_nc#
  ##i=2 is sigma_gaussian##
  ##i=3 is r ##


  if($paramArr->[1] =~ /\?/ && !($paramArr->[2] =~ /^\?$/))
  {smog_quit("CONTACT FUNCTION PARSING:: CONFLICTING INPUTS");}

  ## Epsilon_c ##
  if($paramArr->[0] =~ /^\?$/){$paramArr->[0]=$epsilon;}
  else{$paramArr->[0]=$epsilon*($paramArr->[0]);}
  ## Epsilon_nc ##
  if($paramArr->[1] =~ /\?/){smog_quit("CONTACT FUNCTION PARSING:: CONFLICTING INPUTS");}

  ## Check if sigma_G has r0 dependency ##
  if($paramArr->[2] =~ /\?/)
  {
     #Replace ? with $r0 
     $paramArr->[2] =~ s/\?/$r0/g;
     #Eval expression
     $paramArr->[2] = eval($paramArr->[2]);
  }
  if($paramArr->[3] =~ /^?$/){$paramArr->[3]=$r0;}
  
  ($A,$r0,$sigma_G,$a) = ($paramArr->[0],$paramArr->[3],$paramArr->[2],$paramArr->[1]);
  @{$paramArr}=($A,$r0,$sigma_G,$a);

}


##
# Given a user defined contact function parse values
sub contactFuncParser
{
	my($contactFunc) = @_;
	my $fType;my @paramArr;my $directive;
	my $funcName = ""; my $params = "";
 	#($contactFunc =~ m/(.*)\((.*)\)/);
 	($contactFunc =~ /^([^(]+)\((.*)\)$/);
 	$funcName = $1;
	$params = $2;
	($fType,$directive) = returnFunction($funcName); ## Obtain Gromacs function type
	if($directive ne "pairs"){smog_quit ("$funcName is not a valid pairs(contacts) function");}
 	@paramArr = split(",",$params); ## Parse all parameters
 	foreach $params(@paramArr){$params =~ s/^\s+|\s+$//g;}
	return ($fType,$funcName,@paramArr);
}



##########################
## CALCULATE EXCLUSIONS ##
##########################


sub calculateExclusions
{
	my($contactPDL,$numCon) = @_;
	my $atoma; my $atomb;

	print $OUTPUT "\n[ exclusions ]\n";
	print $OUTPUT "; ai	aj\n";

	#print an exclusion for every contact
	for(my $i=0;$i<$numCon;$i++)
	{
		$atoma = sclr(slice($contactPDL,"1:1,$i:$i"));
		$atomb = sclr(slice($contactPDL,"2:2,$i:$i"));
		print $OUTPUT $atoma,"	",$atomb,"\n";
	}
}

sub calculateAtomTypes
{
	my($uniqeHandle) = @_;
	my $formattedString = "";	
	print $OUTPUT "\n [ atomtypes ] \n";
	print $OUTPUT "; name mass   charge ptype c6            c12\n";
	
	## OBTAIN UNIQUE ATOM TYPES ##
	my %obtained;my $nbtype ="";
	my $c12;my $c6;my $ptype;my $charge;my $mass;
	
	foreach my $atoms(keys %{$uniqeHandle})
	{
		$nbtype = $uniqeHandle->{$atoms}->[0];
  		if(!$uniqeHandle->{$atoms}->[0])
        {
          smog_quit("Atom $atoms has no nbType");
        }

		if(exists $obtained{$nbtype}){next;}
		$c6 = $interactions->{"nonbonds"}->{$nbtype}->{"c6"};
		$c12 = $interactions->{"nonbonds"}->{$nbtype}->{"c12"};
		$ptype = $interactions->{"nonbonds"}->{$nbtype}->{"ptype"};
		$mass = $interactions->{"nonbonds"}->{$nbtype}->{"mass"};
		$charge = $interactions->{"nonbonds"}->{$nbtype}->{"charge"};
		if(!$c6 || !$c12 || !$ptype || !$mass || !$charge)
		{smog_quit("Nonbond Params at atom types not set for nbType $nbtype");}
		
		$formattedString = sprintf("  %-4s %-6.3f %-5.3f  %1s     %-13.5e %-13.5e",$nbtype,$mass,$charge,$ptype,$c6,$c12);
		print $OUTPUT $formattedString,"\n";
		$obtained{$nbtype}=1;
	}
}

sub readAtoms
{
	my($inputPDB) = @_;
	open(PDB,$inputPDB);
	my $line = "";
	print $OUTPUT "\n[ atoms ]\n";	
	print $OUTPUT ";nr  type  resnr residue atom  cgnr\n";
	my $atomName;my $atomNum; my $resName; my $resNum;
	my $charge = 0; my $mass = 1; my $atomType="none";
	my $counter=0; my $resCounter=1;my $resNumCurr="null";
	while($line = <PDB>)
	{
		if($line =~ m/END/) {last;}
		if($line =~ m/ATOM/ || $line =~ m/HETATM/)
		{
			$atomName = substr($line, 12, 4);
			$atomName =~ s/^\s+|\s+$//g;
			#$atomNum = substr($line,6,5);
			
			$resName = substr($line,17,4);
			$resName =~ s/^\s+|\s+$//g;
			$resNum = substr($line,22,4);
			$resNum =~ s/^\s+|\s+$//g;
			if($resNumCurr eq "null"){
				$resNumCurr=$resNum;
			}
   			if($resNum ne $resNumCurr)
			{
				$resNumCurr=$resNum;
				$resCounter++;
			}
			if(!$residues{$resName}->{"atoms"}->{$atomName}){next;}
			$counter++;$atomNum=$counter;
			$atomType = $residues{$resName}->{"atoms"}->{$atomName}->{"nbType"};
			printf $OUTPUT "%6d %10s %6d %6s %6s %6d\n", $atomNum, $atomType, $resCounter, $resName, $atomName, $atomNum;
			

		}
	}


}


sub printDefaultParamsHeader
{
	print $OUTPUT "; Structure-based \"SMOG\" model for use with GROMACS, or NAMD\n";
	print $OUTPUT "; Generated by the SMOG tool version $VERSION\n";
	print $OUTPUT "\n[ defaults ]\n";
	print $OUTPUT "; nbfunc comb-rule gen-pairs\n";
	print $OUTPUT "  1      1         no\n";

}

sub printMoleculeTypes
{

	print $OUTPUT "\n[ moleculetype ]\n";
	print $OUTPUT "; name            nrexcl\n";
	print $OUTPUT "  Macromolecule   3\n";

}

sub printDefaultParamsFooter
{
	print $OUTPUT "\n[ system ]\n";
 	print $OUTPUT "; name\n";
 	print $OUTPUT "  Macromolecule\n";
 	print $OUTPUT "\n[ molecules ]\n";
 	print $OUTPUT "; name            #molec\n";
 	print $OUTPUT "  Macromolecule   1\n";
}


##
# Convert PDB to GRO
# Store chain info to ndx file
sub convertPDBToGroNdx
{
	my ($inputPDB,$outputGRO,$outputNDX) = @_;
	my $counter = 0 ;	
	my $line = "";
	my $resName="";
	my $resNum="";
	my $atomName="";
	my $atomNum="";
 	my $x="";my $y="";my $z="";
 	my $output = "";
 	my $chain = "";
 	my $chainCounter = 1;
 	my %chainHash;
	my $resNumCurr=1;my $resCounter=1;
	my $boundflag=0;
	my ($xmin, $xmax, $ymin,$ymax,$zmin,$zmax);
 	open(PDB,$inputPDB); ## INPUT PDB
	if(-e "meta.Gro"){
		print "meta.Gro is a reserved file name.  It appears to already exist.  Please move and try again\n";
		die;
	}
	open(GRO,">meta.Gro");
	while($line=<PDB>)
	{
		
	 if($line =~ m/END/) {last;}
  	 if($line =~ m/TER/) {$chainCounter++;next;}
         if($line =~ m/ATOM|HETATM/)
         {
		$atomName = substr($line, 12, 4);
		$atomName =~ s/^\s+|\s+$//g;
		$resName = substr($line,17,4);
		$resName =~ s/^\s+|\s+$//g;
        if(!exists $residues{$resName}->{"atoms"}->{$atomName})
		{next;}
		
		$x = substr($line, 30, 8);$x*=0.10;
		$y = substr($line, 38, 8);$y*=0.10;
		$z = substr($line, 46, 8);$z*=0.10;
		
		if($boundflag == 0){
			$xmin=$x;
			$xmax=$x;
			$ymin=$y;
			$ymax=$y;
			$zmin=$z;
			$zmax=$z;
			$boundflag=1;
		}else{
			if($x > $xmax){$xmax=$x;}
			if($x < $xmin){$xmin=$x;}
			if($y > $ymax){$ymax=$y;}
			if($y < $ymin){$ymin=$y;}
			if($z > $zmax){$zmax=$z;}
			if($z < $zmin){$zmin=$z;}
		}
	
  		$chain = $chainCounter;
		$counter++;$atomNum=$counter;
		$resNum = substr($line,22,4);
		$resNum =~ s/^\s+|\s+$//g;
		if($atomNum == 1){$resNumCurr=$resNum;}
		if($resNum ne $resNumCurr)
			{
				$resNumCurr=$resNum;
				$resCounter++;
			}

  		## Save atom index to chain ##
  		push(@{$chainHash{$chain}},$atomNum);
		if($atomNum >= 100000){$atomNum = $atomNum%100000;}
	    if($resCounter >= 100000){$resCounter = $resCounter%100000;}
		$output = sprintf("%5d%-5s%5s%5d%8.3f%8.3f%8.3f\n",$resCounter,$resName,$atomName,$atomNum,$x,$y,$z);
		print GRO $output;
		
	 }
	}

## default box size if 1nm larger than system size in each direction
	my $xrange=($xmax-$xmin)+2.0;
	my $yrange=($ymax-$ymin)+2.0;
	my $zrange=($zmax-$zmin)+2.0;

 ## ADJUST GRO FILE ##
	close(PDB);
	close(GRO);open(GROIN,"meta.Gro");
	open(GRO,">$outputGRO");
	print GRO "Gro file for a structure based model, generated with SMOG Version $VERSION\n";
	print GRO $counter,"\n";
	while(<GROIN>) { print GRO $_;}
	print GRO "$xrange $yrange $zrange\n";
	close(GRO); close(GROIN);
	unlink("meta.Gro");
	
 ## CREATE NDX FILE ##
 open(NDX,">$outputNDX");
 my $c;my $v;
 while(($c,$v) =  each %chainHash)
 {
			print NDX "[ $c ]\n";
   print NDX join("\n",@{$v});
   print NDX "\n";
 }
 close(NDX);
 
}

sub validateTemplate
{
 my ($file,$type) = @_;
 my $validator = XML::Validator::Schema->new(file => "$ENV{SMOG_PATH}/schemas/$type.xsd");
 my $parser = XML::SAX::ParserFactory->parser(Handler => $validator);
 eval { $parser->parse_uri($file) };
 die "\nFailed at validating $file: $@" if $@;

}

sub parseInputFolder
{
 my ($folderName) = @_;
 $folderName = $1 if($folderName=~/(.*)\/$/);
 opendir(my $folder,$folderName);
 my $bif;my $sif;my $b;my $nb;
 my $bifexists=0;
 my $sifexists=0;
 my $nbexists=0;
 my $bexists=0;
 while(my $file = readdir($folder))
 {
   if($file =~ m/\.bif$/)
   {
    $bifexists++;
    $bif = $file;$bif = "$folderName/$bif";
    print "\nFound .bif file $bif";
    validateTemplate($bif,"bif");next;}
   if($file =~ m/\.sif$/)
   {
    $sifexists++;
    $sif = $file;$sif = "$folderName/$sif";
    print "\nFound .sif file $sif";
    validateTemplate($sif,"sif");next;}
   if($file =~ m/\.b$/)
   {
    $bexists++;
    $b = $file;$b = "$folderName/$b";
    print "\nFound .b file $b";
    validateTemplate($b,"b");next;}
   if($file =~ m/\.nb$/)
   {
    $nbexists++;
    $nb = $file;$nb = "$folderName/$nb";
    print "\nFound .nb file $nb";
    validateTemplate($nb,"nb");next;}
  }
  $bifForSCM = $bif;

  if($bifexists >1){
   smog_quit ("Found multiple .bif files in directory $folderName");
  }elsif($bifexists ==0){
   smog_quit (" .bif file not found in directory $folderName");
  }
  if($sifexists >1){
   smog_quit ("Found multiple .sif files in directory $folderName");
  }elsif($sifexists ==0){
   smog_quit (" .sif file not found in directory $folderName");
  }
  if($bexists >1){
   smog_quit ("Found multiple .b files in directory $folderName");
  }elsif($bexists ==0){
   smog_quit (" .b file not found in directory $folderName");
  }
  if($nbexists >1){
   smog_quit ("Found multiple .nb files in directory $folderName");
  }elsif($nbexists ==0){
   smog_quit (" .nb file not found in directory $folderName");
  }

 setInputFileName($bif,$sif,$b,$nb);

}

sub header
{
my $header="******* ******* ******* ******* ******* SMOG v$VERSION ******* ******* ******* ******* *******";
my $headw=length($header);
  print "\n";
for(my $I=0;$I<$headw;$I++){
  print "*";
}
  print "\n";
  print "$header";

print <<EOT;

              Thank you for using the Structure-based Model (SMOG) software

    This package is the product of contributions from a number of people, including:
                     Jeffrey Noel, Mariana Levi, Mohit Ranghunathan,
                        Ryan Hayes,  Jose Onuchic & Paul Whitford

                     Copyright (c) 2015, The SMOG development team at
                        Rice University and Northeastern University

              SMOG v$VERSION & Shadow are available at http://smog-server.org

                        Direct questions to: info\@smog-server.org

EOT

 for(my $I=0;$I<$headw;$I++){
   print "*";
 }
 print "\n";

}

sub usage
{
  header();
  print "Unknown option: @_\n" if ( @_ );
  print <<EOT;

usage: smogv2  [-i PDB file name] [-o smog.top] [-g smog.gro] [--help|-?]

   Required Inputs
	-i [filename.pdb]: Input PDB to generate Hamiltonian
	-t [templateFolder]: Folder containing templates of molecular and interaction definitions
   Optional Input/Output parameters
	-AA: Use default All-atom model
	-CA: Use default Calpha protein model
	-CG: enable coarse-graining
	-t_contacts [templateFolder]: Folder containing templates for determining native contact map. Only necessary when -CG enabled
	-g [smog.gro]: Output .gro file name
	-o [smog.top]: Output .top file name
	-s [smog.contacts]: Output .contacts file name
	-n [smog.ndx]: Output .ndx file name
	-c [contacts.txt]: Input contact map file
	-dname [smog]: Default name to use for all output files.
	-exit [yes]: Exit if an error occurs (only use "no" if you are sure the errors are harmless)
EOT
  exit;
}

sub setContactParams
{
			my $method = $contactSettings->{"method"};
			if($method =~ m/shadow/)
			{
					my $radius = $contactSettings->{"shadowRadius"};
					my $radiusBonded = $contactSettings->{"shadowRadiusBonded"};
					my $dist = $contactSettings->{"contactDistance"};
				    return "-m shadow -c $dist -s $radius -br $radiusBonded -bif $bifForSCM --distance --smog2output --showProgress";
			}
			elsif($method =~ m/cutoff/) 
			{
			  my $dist = $contactSettings->{"contactDistance"};
		 	  my $radius = 0.0;
			  my $radiusBonded = 0.0;
			  return "-m shadow -c $dist -s $radius -br $radiusBonded -bif $bifForSCM --distance --smog2output --showProgress";
			
			}
			else {smog_quit ("Contact map method $method is not supported.");}
}


sub printCitation
{
    my $citationFile = "";
    ## CHECK FOR .citation meta file ##
    if($coarseFolder && -e "$coarseFolder/.citation")
    {
      open(CITE,"$coarseFolder/.citation");
      $citationFile = join("",<CITE>);
      close(CITE);
    }
    elsif(-e "$inputFolder/.citation")
    {
      open(CITE,"$inputFolder/.citation");
      $citationFile = join("",<CITE>);
      close(CITE);
    }
    else{$citationFile = "";}
       

print <<EOT;

########################################################################################

              We kindly ask that you cite the appropriate primary references
             when using SMOG models. See http://www.smog-server.org/refs.html

--Software-- 
Noel JK, Levi M, Rangunathan M, Hayes R, Onuchic JN, and Whitford PC.
SMOG V2, A Versatile Software Package for Generating Structure-Based Models 
2015, In preparation. 

$citationFile
########################################################################################

EOT

}

##
## MEMORY MANAGEMENT ROUTINES
##
sub determine_optimal_memory {

    # We'll set a ceiling for the memory allocation.  On a 32-bit OS this is going
    # to be 1500m (the max it can safely handle), on a 64-bit OS we won't take more
    # than 6GB
    my $max_memory = 1500;

    # We need not only a 64 bit OS but 64 bit java as well. It's easiest to just test
    # java since the OS support must be there if you have a 64 bit JRE.

    my ($in,$out);
    open3(\*IN,\*OUT,\*OUT,"java -version") or print_error("Can't find java");
    close IN;
    while (<OUT>) {
        if (/64-Bit/) {
            $max_memory = 6000;
        }
    }
    close OUT;
    # The way we determine the amount of physical memory is OS dependent.
    my $os = $^O;

    my $physical;
    if ($os =~ /Win/) {
        smog_quit("SMOG2 does not run on windows");
    }
    elsif ($os =~/darwin/ or $os =~ /bsd/i) {
        $physical = get_osx_memory($max_memory);
    }
    else {
        $physical = get_linux_memory($max_memory);
    }

    warn "Raw physical free memory is $physical\n";

    # We then set the memory to be the minimum of 2/3 of the physical
    # memory or the ceiling, whichever is lower.
    $physical = int(($physical/3)*2);

    if ($max_memory < $physical) {
        return $max_memory;
    }

    warn "Using $physical MB of RAM to launch seqmonk\n";
    return $physical;

}

sub get_linux_memory {
    # We get the amount of physical memory on linux by parsing the output of free

    open (MEM,"free -m |") or print_error("Can't launch free on linux: $!");

    while (<MEM>) {
        if (/^Mem:\s+(\d+)/) {
            return $1;
        }
    }

    close MEM;

    smog_quit("Couldn't parse physical memory from the output of free");
}

sub get_osx_memory {

    # We get the amount of physical memory on OSX by parsing the output of top

    open (MEM,"top -l 1 -n 0 |") or print_error("Can't get amount of memory on OSX: $!");

    my $total_mem = 0;

    while (<MEM>) {
        if (/^PhysMem:.*,\s+(\d+)M\s+unused/) {
            $total_mem += $1;
        }    
    }

    close MEM;
    unless ($total_mem) {
        smog_quit("Couldn't parse physical memory from the output of top");
    }

    return $total_mem;

}

sub freeMemoryForShadow
{
undef %resPDL;undef %connPDL;
undef %connAngleFunctionals;undef %connDiheFunctionals;
undef %connBondFunctionals;undef $contactPDL;
}


##
## ALL-ATOM PROGRAM DRIVER ##
## Perform All-Atom Topology Generation
sub allAtom
{
	my ($inputFolder,$inputPDB,$groFile,$ndxFile,$shadowFile,$topFile) = @_;

	print "\n*****************************************************\n";
	print   "******* ALL-ATOM SMOG MODEL WILL BE GENERATED *******";
	print "\n*****************************************************\n";
        
        ## TEST IF SMOG PATH EXISTS ##
        if(!$ENV{"SMOG_PATH"}){smog_quit("SMOG_PATH environment variable not set");}
	$| = 1;
	## OPEN .top handle ##
	open($OUTPUT, ">$topFile");
        print "Parsing All-Atom Templates... ";
	parseInputFolder($inputFolder); ## PARSE FOLDER --> FILE

	#####################
        ## PARSE TEMPLATES ##
        #####################

	## parse .bif File ##
	parseBif();
	## parse .sif File ##
	parseSif();
	## parse Bonds/Nonbonds File
	parseBonds();parseNonBonds();
        print "\nDone parsing templates.\n";

	## Find Bonds ##
	createBondFunctionals();
	## Find Angles ##
	createDihedralAngleFunctionals();

	###############
        ## PARSE PDB ##
        ###############
	print "Parsing .pdb...\n";
	parsePDBATOMS($inputPDB,0);
	catPDL();
	print "Done\n";
	print "Creating topology for contact calculation.....\n";
	#####################################
	## DO CALCULATIONS FOR HAMILTONIAN ##
	#####################################
	## COUNT NUMBER OF DIHEDRALS ##
	print "Generating angles and dihedrals...";
	getSetDiheCounts(\%connDiheFunctionals,\%connPDL);
	## SET DIHEDRAL RATIOS ##
	print "..";
	setRatios(\%connDiheFunctionals,\%connPDL,$totalAtoms,\%allAtoms);
	## PRINT TOPOLOGY HEADERS ##
	print "..";
	printDefaultParamsHeader();
	## CALCULATE ATOM TYPE HEADERS ##
	print "..";
	calculateAtomTypes(\%allAtoms);
	## PRINT MOLECULE TYPE ##
	print "..";
	printMoleculeTypes();
	## PRINT ATOMS HEADER ##
	print "..";
	readAtoms($inputPDB);
	## CALCULATE BONDS/CONNECTED BONDS ##
	print "..";
	printOrderedBonds(\%bondFunctionals,\%resPDL,\%connBondFunctionals,\%connPDL);
	## CALCULATE ANGLES ##
	print "\nSaving angles\n";
	printOrderedAngles(\%connAngleFunctionals,\%connPDL);
	## CALCULATE DIHEDRALS ##
	print "Saving dihedrals\n";
	printOrderedDihedrals(\%connDiheFunctionals,\%connPDL);
    
	## CREATE GRO FILE ##
	convertPDBToGroNdx($inputPDB,$groFile,$ndxFile);
	## CALL SHADOW/PARSE CONTACTS ##
	print "Starting contact calculations ...\n  ";
	
	
	my $SCMparams = setContactParams();
	my $absAtomCount = keys(%allAtoms);
    my $memoryMax = "";
    if($absAtomCount >= 1000000)
    {
     $memoryMax = 4000;
     print "JAVA HEAP SIZE INCREASED to $memoryMax Mb\n";
     $memoryMax = "-Xmx$memoryMax"."m";
    } 
	
	## Delete Preexisting contact file ##
	if(-e $shadowFile){unlink($shadowFile);}
	
	## Free Memory for Shadow ##
	freeMemoryForShadow();
	
	if((!exists $ENV{SMOG_PATH}) || 
		!(-e "$ENV{SMOG_PATH}/tools/SCM.jar")){smog_quit ("Can't find Shadow executable. Make sure SMOG_PATH is set correctly.")}
	if($ignAllContacts==0){
		print "Calling $ENV{SMOG_PATH}/tools/SCM.jar \n";
	    system("java $memoryMax -jar $ENV{SMOG_PATH}/tools/SCM.jar -g $groFile -t $topFile -o $shadowFile -ch $ndxFile $SCMparams ");}
	$numContacts = parseCONTACT($shadowFile,$ContactFile,$ignAllContacts,0);


	if($numContacts == 0){smog_quit ("There are 0 contacts,check log file for possible errors");}
	print "NOTE: Total number of atoms included in normalization is $totalAtoms, and $absAtomCount atoms are in the system.\n";
	print "Completing final details...";
	## CALCULATE PAIRS and EXCLUSION ##
 	calculateContacts($contactPDL,\%resPDL,\%allAtoms,$numContacts,$totalAtoms);
	calculateExclusions($contactPDL,$numContacts);
	## PRINT TOPOLOGY FOOTERS ##
	printDefaultParamsFooter();
	print "\nYour Structure-based Model is ready!\n\nFiles generated: \n\t$topFile\n\t$groFile\n\t$shadowFile\n\t$ndxFile\n";
	close($OUTPUT);
	printCitation();
}

##
## COARSE GRAIN PROGRAM DRIVER ##
## Perform Coarse Grain Topology Generation
sub coarseGrain
{
	my ($inputFolder,$coarseFolder,$inputPDB,$groFile,$ndxFile,$shadowFile,$topFile) = @_;
	print "\n*****************************************************\n";
	print   "**** COARSE-GRAINED SMOG MODEL WILL BE GENERATED ****";
	print "\n*****************************************************\n";
        

	$| = 1;
	## TEST IF SMOG PATH EXISTS ##
        if(!$ENV{"SMOG_PATH"}){smog_quit("SMOG_PATH environment variable not set");}

	## OPEN .top handle ##
	open($OUTPUT, ">$topFile");
	

	##############################
        ## PARSE ALL ATOM TEMPLATES ##
        ##############################
        print "\n\n		PREPROCESSING\n\nWill use contact-specific templates\n";
	parseInputFolder($inputFolder);
	## parse Bif File ##
	parseBif();
	## parse Sif File ##
        print "\nNote: Contact definitions given in templates $inputFolder are being used\n";
	parseSif();
	## parse Bonds/Nonbonds File
	parseBonds();parseNonBonds();
        print "\nDone parsing template files.\n";

	## Find Bonds ##
	createBondFunctionals();
	## Find Angles ##
	createDihedralAngleFunctionals();
	###############
        ## PARSE PDB ##
        ###############
	print "Parsing .pdb...\n";
	parsePDBATOMS($inputPDB,0);
	catPDL();
	print "Done\n";

	#####################################
	## DO CALCULATIONS FOR HAMILTONIAN ##
	#####################################
	## COUNT NUMBER OF DIHEDRALS ##
	print "Preparing system for contact evaluations...";
	getSetDiheCounts(\%connDiheFunctionals,\%connPDL);
	## SET DIHEDRAL RATIOS ##
	print "..";
	setRatios(\%connDiheFunctionals,\%connPDL,$totalAtoms,\%allAtoms);
	## PRINT TOPOLOGY HEADERS ##
	print "..";
	printDefaultParamsHeader();
	## CALCULATE ATOM TYPE HEADERS ##
	print "..";
	calculateAtomTypes(\%allAtoms);
	## PRINT MOLECULE TYPE ##
	print "..";
	printMoleculeTypes();
	## PRINT ATOMS HEADER ##
	print "..";
	readAtoms($inputPDB);
	## CALCULATE BONDS/CONNECTED BONDS ##
	print "..";
	printOrderedBonds(\%bondFunctionals,\%resPDL,\%connBondFunctionals,\%connPDL);
	## CALCULATE ANGLES ##
	print "..";
	printOrderedAngles(\%connAngleFunctionals,\%connPDL);
	## CALCULATE DIHEDRALS ##
	print "..";
	printOrderedDihedrals(\%connDiheFunctionals,\%connPDL);
	print "..\n";
        convertPDBToGroNdx($inputPDB,$groFile,$ndxFile);
	my $SCMparams = setContactParams();
	my $absAtomCount = keys(%allAtoms);
    	my $memoryMax = "";
    	if($absAtomCount >= 1000000)
    	{
     		$memoryMax = 4000;
     		print "JAVA HEAP SIZE INCREASED to $memoryMax Mb\n";
     		$memoryMax = "-Xmx$memoryMax"."m";
    	} 
        if($ignAllContacts ==0){
        print "Finding coarse grained contacts... ";
	if((!exists $ENV{SMOG_PATH}) || 
		!(-e "$ENV{SMOG_PATH}/tools/SCM.jar")){smog_quit ("Can't find Shadow executable. Make sure SMOG_PATH is set correctly.")}
	system("java $memoryMax -jar $ENV{SMOG_PATH}/tools/SCM.jar --coarse CA -g $groFile -t $topFile -ch $ndxFile -o $shadowFile $SCMparams ");
        }
	## CLEAR ALL-ATOM MEMORY ##
        clearBifMemory();clearPDBMemory();

 
	###################################
        ## PARSE COARSEGRAINED TEMPLATES ##
        ###################################
	## OPEN .top handle ##
	open($OUTPUT, ">$topFile");
        print "\n\n	     FINAL PROCESSING\n\nWill use templates for final model\n\n";
	print "Parsing Coarse Grained Templates... ";
	parseInputFolder($coarseFolder);
	## parse Bif File ##
	parseBif();
	## parse Sif File ##
        print "\nNote: Contact definitions given in templates $coarseFolder are NOT being used.\n";
	parseSif();
	## parse Bonds/Nonbonds File
	parseBonds();parseNonBonds();
        print "Done parsing templates\n";

	## Find Bonds ##
	createBondFunctionals();
	## Find Angles ##
	createDihedralAngleFunctionals();
        
	###############
    	## PARSE PDB ##
    	###############
	print "Coarse Graining system.....";
	parsePDBATOMS($inputPDB,1);
	catPDL();
	print "Done\n";
	
	## CREATE GRO FILE ##
	print "Creating .gro.....";
	convertPDBToGroNdx($inputPDB,$groFile,$ndxFile);
	print "Done\n";
	$absAtomCount = keys(%allAtoms);
	print "NOTE: Total atom count: $absAtomCount\n";
	
	## COUNT NUMBER OF DIHEDRALS ##
	print "Constructing final model...";
	getSetDiheCounts(\%connDiheFunctionals,\%connPDL);
	## SET DIHEDRAL RATIOS ##
	print "..";
	setRatios(\%connDiheFunctionals,\%connPDL,$totalAtoms,\%allAtoms);
	## PRINT TOPOLOGY HEADERS ##
	print "..";
	printDefaultParamsHeader();
	## CALCULATE ATOM TYPE HEADERS ##
	print "..";
	calculateAtomTypes(\%allAtoms);
	## PRINT MOLECULE TYPE ##
	print "..";
	printMoleculeTypes();
	## PRINT ATOMS HEADER ##
	print "..";
	readAtoms($inputPDB);
	## CALCULATE BONDS/CONNECTED BONDS ##
	print "..\n";
	printOrderedBonds(\%bondFunctionals,\%resPDL,\%connBondFunctionals,\%connPDL);
	## CALCULATE ANGLES ##
	print "Saving angles\n";
	printOrderedAngles(\%connAngleFunctionals,\%connPDL);
	## CALCULATE DIHEDRALS ##
	print "Saving dihedrals\n";
	printOrderedDihedrals(\%connDiheFunctionals,\%connPDL);

	$numContacts = parseCONTACT($shadowFile,$ContactFile,$ignAllContacts,1);
	if($numContacts == 0){smog_quit ("There are 0 contacts,check shadow.error log file for possible errors");}
	## CALCULATE PAIRS and EXCLUSION ##
 	calculateContacts($contactPDL,\%resPDL,\%allAtoms,$numContacts,$totalAtoms);
	calculateExclusions($contactPDL,$numContacts);
	## PRINT TOPOLOGY FOOTERS ##
	printDefaultParamsFooter();
	print "\nYour Structure-based Model is ready!\n\nFiles generated: \n\t$topFile\n\t$groFile\n\t$shadowFile\n\t$ndxFile\n";
	close($OUTPUT);
	printCitation();
}

##################
## PARSE INPUTS ##
##################

my $DNAME="";
my $exit;
## parse command line options ##
# -o output top file name, default is smog.top
usage() if (@ARGV < 1 || !GetOptions('help|?' => \$help, 'o=s' => \$topFile, 't=s' => \$inputFolder, 'i=s' => \$inputPDB, 'g=s' => \$groFile,
	'c=s' => \$ContactFile, 's=s' => \$shadowFile, 'n=s' => \$ndxFile,
	 'CG' => \$CGenabled, 't_contacts=s' => \$contactRes, 'CA'=> \$CAdefault, 'AA' => \$AAdefault, 'dname=s' => \$DNAME, 'exit=s' => \$exit)
          or defined $help 
          or !defined $inputPDB 
          or (!defined $inputFolder  && !defined $contactRes));

header();

if(defined $exit && $exit eq "no"){
	$noexit=1;
	print "\n\n-noexit selected.  Will not intentionally exit when an error is encountered.\n Be cautious, ignoring errors can lead to unpredictable results. \n ONLY use this option if you are sure the error is harmless.\n\n";
}elsif(defined $exit && $exit eq "yes"){
	$noexit=0;
}elsif(defined $exit){
	smog_quit('-exit can only accept \"yes\" or \"no\" as an argument.');
}


if($CAdefault == 1 and $AAdefault == 1){
	smog_quit('Can not use -CA and -AA flags at the same time.');
}
if($CAdefault == 1 and $CGenabled == 1){
	smog_quit('Can not use -CG and -AA flags at the same time.');
}
if($CAdefault == 1 and $inputFolder ne ""){
	smog_quit('Can not use -CA and -t flags at the same time.');
}
if($AAdefault == 1 and $inputFolder ne ""){
	smog_quit('Can not use -AA and -t flags at the same time.');
}
if(($CAdefault == 1 || $AAdefault == 1) and $contactRes ne ""){
	smog_quit('Can not use -AA, or -CA with -t_contacts.');
}

if($CAdefault == 1){
	print "\n -CA given. Will use the default Calpha SMOG model provided with the distribution.\n";
	my $SMOGDIR=$ENV{'SMOG_PATH'};
	$inputFolder="$SMOGDIR/SBM_calpha";
	$contactRes="$SMOGDIR/SBM_AA";
	print "Will try to use templates found in \n$inputFolder\n and\n$contactRes\n\n";
	if(! -d $inputFolder){
		smog_quit("$inputFolder is not a valid template directory.");
	}
	if(! -d $contactRes){
		smog_quit("$contactRes is not a valid template directory.");
	}
	$CGenabled=1;
}
if($AAdefault == 1){
	print "\n -AA given. Will use the default All-Atom SMOG model provided with the distribution.\n";
	my $SMOGDIR=$ENV{'SMOG_PATH'};
	$inputFolder="$SMOGDIR/SBM_AA";
	print "Will try to use templates found in \n$inputFolder\n\n";
	if(! -d $inputFolder){
		smog_quit("$inputFolder is not a valid template directory.");
	}
}

## get variables in order
# if CG is enabled, then the templates are CG templates
if($CGenabled != 0){
	$coarseFolder=$inputFolder;
}

# if contact templates are provided, and CG is turned on, then use contact templates for first round
if($contactRes ne "" && $CGenabled != 0)
{$inputFolder=$contactRes;} 

# if a contact file is provided, then don't calculate contacts
if($ContactFile ne ""){
	$ignAllContacts=1;
}

## Ensure we only write out files with gromacs-compatible suffices
my $maxbu=10;
if ($DNAME ne ""){
	$topFile=$DNAME;
	$groFile=$DNAME;
	$shadowFile=$DNAME;
	$ndxFile=$DNAME;
}
my ($ext)=$topFile =~ /(\.[^.]+)$/;
if($topFile !~ /(\.[^.]+)$/){
	$topFile = $topFile . ".top";
}elsif($ext ne ".top"){
	$topFile = $topFile . ".top";
}
($ext)=$groFile =~ /(\.[^.]+)$/;
if($groFile !~ /(\.[^.]+)$/){
	$groFile = $groFile . ".gro";
}elsif($ext ne ".gro"){
	$groFile = $groFile . ".gro";
}
($ext)=$shadowFile =~ /(\.[^.]+)$/;
if($shadowFile !~ /(\.[^.]+)$/){
	$shadowFile = $shadowFile . ".contacts";
}elsif($ext ne ".contacts"){
	$shadowFile = $shadowFile . ".contacts";
}
($ext)=$ndxFile =~ /(\.[^.]+)$/;
if($ndxFile !~ /(\.[^.]+)$/){
	$ndxFile = $ndxFile . ".ndx";
}elsif($ext ne ".ndx"){
	$ndxFile = $ndxFile . ".ndx";
}

## check if files exist
# things we don't want to overwrite
foreach my $filen($topFile, $groFile, $shadowFile, $ndxFile){

	my ($ext) = $filen =~ /(\.[^.]+)$/;
	if($filen ne "" && -e $filen){
		for(my $bu=1;$bu<=$maxbu;$bu++){
			my $buname="$filen.bu$bu";
			if( ! -e $buname){	
			print "$filen already exists.  Backing up to $buname\n";
			system("mv $filen $buname");
			last;
			}
			if($bu == $maxbu){
		 	smog_quit ("Already backed up $maxbu copies of $filen."); 
			}
		}
	}
}

# files we will read
foreach my $filen($inputPDB,$ContactFile){
	if($filen ne "" && ! -f $filen){
		smog_quit("Can't find file $filen !! ");
	}
}
# directories we will access
foreach my $filen($inputFolder,$contactRes){
	if($filen ne "" && ! -d $filen){
		smog_quit ("Can't find directory $filen !! ");
	}
}

## check for compatibility of options
# if CG is not enabled, but contact templates are provided, stop
if($CGenabled == 0 && $contactRes ne ""){
	smog_quit ("t_contacts only supported when using a CG model.  Did you forget to specify \"-CG\"?");
}

# if contact templates and a contact file are provided, complain
if($ContactFile ne "" && $contactRes ne "")
{smog_quit("You can only specify a t_contacts directory, or a contact file, not both");}


# if contact templates are not provided, and contact file is not provided, but CG is turned on, complain
if($contactRes eq "" && $CGenabled != 0 && $ContactFile eq "")
{smog_quit("You need to specify t_contacts, or provide a contact map, when using coarse-graining");}


####################
## PROGRAM DRIVER ##
####################

## PROCESS All-Atom or Coarse Grain ##
## ALL-ATOM ##
if($CGenabled == 0){allAtom($inputFolder,$inputPDB,$groFile,$ndxFile,$shadowFile,$topFile);}
## COARSE-GRAIN ## 
else{coarseGrain($inputFolder,$coarseFolder,$inputPDB,$groFile,$ndxFile,$shadowFile,$topFile);}
## END ##
