#########################################################################################
#                          Structure-based Model (SMOG) software
#    This package is the product of contributions from a number of people, including:
#            Jeffrey Noel, Mariana Levi, Antonio Oliveira, VinÃ­cius Contessoto,
#             Mohit Raghunathan, Joyce Yang, Prasad Bandarkar, Udayan Mohanty,
#                          Ailun Wang, Heiko Lammert, Ryan Hayes,
#                               Jose Onuchic & Paul Whitford
#
#            Copyright (c) 2015,2016,2018,2021, The SMOG development team at
#                        Rice University and Northeastern University
#
#          SMOG 2, Shadow and OpenSMOG are available at http://smog-server.org
#
#          You can direct questions to info@smog-server.org, or the smog-users forum,
#          which you can find at https://mailman.rice.edu/mailman/listinfo/smog-users
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#########################################################################################
########################
#OpenSMOG package provides all routines used for OpenSMOG support
########################

package OpenSMOG;



use strict;
use warnings FATAL => 'all';
use Exporter;
use XML::Simple qw(:strict);
use smog_common;
use XML::LibXML;

our @ISA = 'Exporter';
our @EXPORT = qw(OShashAddFunction OpenSMOGfunctionExists addOShash readOpenSMOGxml OpenSMOGwriteXML OpenSMOGextractXML newOpenSMOGfunction %fTypes %fTypesArgNum);
our %fTypes;
our %fTypesArgNum;
our $OpenSMOG;
our %OpenSMOGatoms2restrain;

########## OpenSMOG routines
sub OShashAddFunction{
	my ($OSref,$type,$name,$expr,$params)=@_;
	if($type ne "contacts"){
		smog_quit("OpenSMOG currently only supports modified contact potentials.  Issue processing $name");
	}
	my $ref=\%{$OSref->{$type}->{$type . "_type"}->{$name}};
	$ref->{expression}->{"expr"}=$expr;

	my @params=@{$params};
	foreach my $en(@params){
		push(@{$ref->{parameter}},"$en");
	}
}

sub OpenSMOGfunctionExists{
	my ($OSref,$type,$name)=@_;
	if(exists $OSref->{$type}->{$type . "_type"}->{$name}){
		return 1;
	}else{
		return 0;
	}
}

sub addOShash{
	my ($OSref,$stuff)=@_;
	my @stuff=@{$stuff};
	my $ref=\%{$OSref->{$stuff[2]}->{$stuff[2] . "_type"}->{$stuff[3]}};
# @stuff is the array that contains the following information: i, j, interaction type, function name, @parameter (in the order found in $OSref->{$type}->{$name}->{parameters} array)
	my %tmphash;
	$tmphash{"i"}=$stuff[0];
	$tmphash{"j"}=$stuff[1];
	my $parn=4;
	foreach my $param(@{$ref->{parameter}}){
		$tmphash{$param}=$stuff[$parn];
		$parn++;
	}
	push(@{$ref->{interaction}},\%tmphash);

}

sub readOpenSMOGxml {
	my ($XMLin)=@_;
	if(-f $XMLin){
		my $xml = new XML::Simple;
		my $data = $xml->XMLin($XMLin,KeyAttr=>{contacts_type=>"name"},ForceArray=>["contacts_type","parameter","interaction"]);
		# this will return a hashtable with the following format:
#<perldata>
# <hashref memory_address="0x7fc4f2a25300">
#  <item key="contacts">
#   <hashref memory_address="0x7fc4f2a25a38">
#    <item key="contacts_type">
#     <hashref memory_address="0x7fc4f2a42e30">
#      <item key="bond_type6">
#       <hashref memory_address="0x7fc4f2a42e78">
#        <item key="expression">
#         <hashref memory_address="0x7fc4f2a8ef70">
#          <item key="expr">eps*(r-r0)^2</item>
#         </hashref>
#        </item>
#        <item key="interaction">
#         <arrayref memory_address="0x7fc4f2a7ebd8">
#          <item key="0">
#           <hashref memory_address="0x7fc4f2a908e8">
#            <item key="eps">200</item>
#            <item key="i">1</item>
#            <item key="j">2</item>
#            <item key="r0">1.32823e-01</item>
#           </hashref>
#          </item>
#         </arrayref>
#        </item>
#        <item key="parameter">
#         <arrayref memory_address="0x7fc4f2a7eb60">
#          <item key="0">eps</item>
#          <item key="1">r0</item>
#         </arrayref>
#        </item>
#       </hashref>
#      </item>
#      <item key="c8-c12">
		return $data;
	}else{
		return 1;
	}
}

sub OpenSMOGwriteXML{
	my ($OSref,$OpenSMOGxml,$comments)=@_;
        # OSref is a handle to the hash holding all information to be written.
        # $OpenSMOGxml is the output file name
	my $space=" ";
	my $ones="$space";
	my $twos="$space$space";
	my $threes="$space$space$space";
	# this is a very limited XML writer that is made specifically for OpenSMOG-formatted contact hashes
	# we will make a more versatile version later. We will probably replace this with an XMLlib call, later. But, in order to format it exactly the way we want, directly writing it is ok.
	my $size = keys %{$OSref};
	if($size != 0){
		my $xmlout="<!--    OpenSMOG xml file generated by SMOG2.\n$comments -->\n";
		$xmlout .= "<OpenSMOGforces>\n";
		my $handle0=$OSref;

		foreach my $type(sort keys %{$handle0}){
			if($type eq "contacts"){
				$xmlout .= OpenSMOGwriteXMLcontacts($handle0,$type,$space);
			}else{
				smog_quit("When writing OpenSMOG XML file, type $type not supported.");
			}
		}	
		$xmlout.="</OpenSMOGforces>\n";
		open(XMLOO,">$OpenSMOGxml") or smog_quit("Unable to open $OpenSMOGxml for writing");
		print XMLOO $xmlout;
		close(XMLOO);

		# check that the written file aligns with the intended schema.
		my $doc = XML::LibXML->new->parse_file($OpenSMOGxml);
		my $xmlschema = XML::LibXML::Schema->new( location => "$ENV{SMOG_PATH}/share/schemas/OpenSMOG.xsd", no_network => 1 );
		eval { $xmlschema->validate( $doc ); };
		smog_quit("Failed to validate $OpenSMOGxml against schema file $ENV{SMOG_PATH}/share/schemas/OpenSMOG.xsd . $@ \nThis is due to an XML formatting issue, which is probably a bug in the code.  Please send a bug report to info\@smog-server.org") if $@;

		return "\t$OpenSMOGxml\n";
	}
	return "";
}

sub OpenSMOGwriteXMLcontacts{
	my ($handle0,$type,$space)=@_;
        my $ones="$space";
        my $twos="$space$space";
        my $threes="$space$space$space";

	my $localxmlout = "$space<$type>\n";
	my $handle1=$handle0->{$type};
	foreach my $subtype(sort keys %{$handle1}){
	   	my $handle2=$handle1->{$subtype};
	   	foreach my $name(sort keys %{$handle2}){
	   		my $handle3=$handle2->{"$name"};
			my $anydefined=0;
	   	     	foreach my $param(@{$handle3->{interaction}}){
				if(defined $param){
					$anydefined=1;
					last;
				}
			}
			if($anydefined==0){
				# means none of the interactions exist in the final system.  So, don't write this type
				next;
			}

	   	     	$localxmlout .= "$twos<$subtype name=\"$name\">\n";
	   	     	my $expr=$handle3->{expression}->{"expr"};
	   	     	$localxmlout .= "$threes<expression expr=\"$expr\"/>\n";
			my @paramlist=@{$handle3->{parameter}};
	   	     	foreach my $param(@paramlist){
	   	     		$localxmlout .= "$threes<parameter>$param</parameter>\n";
	   	     	}
	   	     	foreach my $param(@{$handle3->{interaction}}){
				if(!defined $param){
					#must have been deleted
					next;
				}
	   	     		$localxmlout .="$threes<interaction";
	   	     		my %tmphash=%{$param};
				foreach my $key("i","j",@paramlist){
   	     				my $fmt;
   	     				# write integers as integers.  Everything else as scientific notation
   	     				if($tmphash{$key} =~ m/^[0-9]*$/){
   	     					$fmt="%i";
   	     				}else{
   	     					$fmt="%7.5e";
   	     				}
   	     				my $val=sprintf("$fmt",$tmphash{$key});
   	     				$localxmlout .=" $key=\"$val\"";
				}
	   	     		$localxmlout .="/>\n";
	   	     	}
	   	     	$localxmlout .= "$twos</$subtype>\n";
           	 }
	}
	$localxmlout .= "$ones</$type>\n";
	my @num=split(/\s+/,$localxmlout);
	my $num = @num; 
	if($num > 3){	
		# there must be some content, so write it.
		return $localxmlout;
	}else{
		return "";
	}
}

sub OpenSMOGextractXML{
	my ($OSref,$OpenSMOGxml,$keepatoms)=@_;
        # OSref is a handle to the hash holding all information to be written.
        # $OpenSMOGxml is the output file name
	# Only load the module if we are writing an OpenSMOG file
 	my $checkPackage=`\$perl4smog -e "use XML::LibXML" 2>&1`;
        if(length($checkPackage) > 0) { smog_quit("Perl module XML::LibXML not installed. Since you are using OpenSMOG, we can not continue...")}
        # this was a workaround to a cryptic shared variable error in perl
	use if 0==0 , "XML::LibXML";
	my $space=" ";
	my $ones="$space";
	my $twos="$space$space";
	my $threes="$space$space$space";
	# this is a very limited XML writer that is made specifically for OpenSMOG-formatted contact hashes
	# we will make a more versatile version later. We will probably replace this with an XMLlib call, later. But, in order to format it exactly the way we want, directly writing it is ok.
	my $size = keys %{$OSref};
	if($size != 0){
		my $handle0=$OSref;

		foreach my $type(sort keys %{$handle0}){
			my $handle1=$handle0->{$type};
			foreach my $subtype(sort keys %{$handle1}){
			   	my $handle2=$handle1->{$subtype};
			   	foreach my $name(sort keys %{$handle2}){
			   		my $handle3=$handle2->{"$name"}->{interaction};
			   	     	#foreach my $param(@{$handle3->{interaction}}){
			   	     	for (my $I=0;$I<=$#{$handle3};$I++){
						if(OpenSMOGkeepinteraction(${$handle3}[$I],$keepatoms)){
							delete ${$handle3}[$I];
							# if evals to 1, then delete
						}
						# this renumbers, or removes the interaction
			   	     	}
                           	 }
			}
		}	
	}
	OpenSMOGwriteXML($OSref,$OpenSMOGxml);
	return \%OpenSMOGatoms2restrain;
}

sub OpenSMOGkeepinteraction {
	my ($tmphash,$keepatoms)=@_;
        if(exists $keepatoms->{$tmphash->{"i"}} && exists $keepatoms->{$tmphash->{"j"}}){
		$tmphash->{"i"}=$keepatoms->{$tmphash->{"i"}};
		$tmphash->{"j"}=$keepatoms->{$tmphash->{"j"}};
		return 0;
	}elsif(exists $keepatoms->{$tmphash->{"i"}}){
		$OpenSMOGatoms2restrain{$keepatoms->{$tmphash->{"i"}}}=1;
	}elsif(exists $keepatoms->{$tmphash->{"j"}}){
		$OpenSMOGatoms2restrain{$keepatoms->{$tmphash->{"j"}}}=1;
	}
	return 1;
}

sub newOpenSMOGfunction{
	my ($OpenSMOGhandle,$fh,$fN)=@_;
	# $fh is the functions handle
	# is the new function name to add

	if($fN =~ m/[\+\-\*\/]/){
		smog_quit("OpenSMOG function names can not have +, -, * or /.  Problematic definition: $fN");
	}

	if ( exists $fTypes{"$fN"}){
		smog_quit("Can not create new OpenSMOG function. $fN is a protected name.");
	}
	# the fType array is the gromacs function type. But, this is not used in OpenSMOG.  We still use the array to keep track of defined functions, and use it as a tag for determining that this is an OpenSMOG potential.  But we don't use the value in the output
	$fTypes{"$fN"}="-2";

	# set the number of required parameters
	my $parmstring=$fh->{$fN}->{"OpenSMOGparameters"};
	if($parmstring =~ m/^\s+\,|\,\s+\,|\,\s+$/){
		smog_quit("Incorrectly formatted parameter list given for function $fN. Found \"$parmstring\"\nCheck .sif file.");
	}
	$parmstring =~ s/\s+//g;
	my @parmarr=split(/\,/,$parmstring);
	$fTypesArgNum{"$fN"}=$#parmarr+1;

	# even though OpenSMOG doesn't use gromacs directives, various checks in the code use the directive name for checking validity of function definitions.
	if($fh->{$fN}->{"OpenSMOGtype"} eq "contact"){
		$fh->{$fN}->{"directive"}="pairs";
	}

	my $pot=$fh->{$fN}->{"OpenSMOGpotential"};
	my $pind=0;
	my %seenparm;
	foreach my $param(@parmarr){

                if($param =~ m/^[i-n]$/){
                        smog_quit(".sif file defines function $fN with OpenSMOG parameter $param. OpenSMOG functions can not use i-n as parameters. These are reserved symbols for denoting atom indices.");
                }

		if(exists $seenparm{$param}){
			smog_quit("Function $fN defines $param as a parameter more than once. See .sif file. Found $fh->{$fN}->{\"OpenSMOGparameters\"}");
		}else{
			$seenparm{$param}=1;
		}
		if($param =~ m/^weight$/){
			#keep track of which parameter is the weight, if any.
			$OpenSMOGhandle->{$fN}->{weight}=$pind;
		}
		$pind++;
		if($pot !~ m/$param/){
			smog_quit("Function $fN defines $param as a parameter, but it does not appear in the definition of the potential. Found $fh->{$fN}->{\"OpenSMOGpotential\"}");
		}
	}

	$OpenSMOGhandle->{$fN}->{expression}=$fh->{$fN}->{"OpenSMOGpotential"}  ;

	foreach my $par(@parmarr){
		push(@{$OpenSMOGhandle->{$fN}->{parameters}},"$par");
	}

}

1;
