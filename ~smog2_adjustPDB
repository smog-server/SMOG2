use strict;
use warnings;

## VARS: ##
my %map;
my $rows;
my $atomCount;
my $isHead;
my $isTail;
my $resInd;
my $chainName;
my $resName;
my @residue;
my @pArr;
my $loopInd;
my $prevResTypeRNA;
my $noexit=0;
my $outputPDB;
my $inputPDB;
my $mapFile;
my $default;
my $warnonly;
my $renumber;
my $mapOption;
my $help;

## MODULE HEADERS ##
use Getopt::Long;

sub usage
{
print <<EOT;
*****************************************************************************************
                                      smog_adjustPDB                                   

    smog_adjustPDB is part of the SMOG 2 distribution, available at smog-server.org     

    This tool will renumber the atoms in each chain, and modify the names of terminal
        residues, so that they are compatible with the definitions used by SMOG 2

                       See the SMOG manual for usage guidelines.

            For questions regarding this script, contact info\@smog-server.org              
*****************************************************************************************

usage: smog_adjustPDB [-i filename.pdb] [-o smog.pdb] [-default] | [-map filename] [--help|-?]

Required Input
	-i [filename.pdb]: Input PDB to adjust to smog2 format
	-default | -map filename : use the default file name provided by smog2 or specify a map file name
Optional Input parameters
	-warnonly : Convert fatal errors to warnings (Caution: Consult manual before using this option)
	-renumber : Ignore any residue numbering inconsistencies and renumber residues sequentially.

EOT

  if ( @_ ){
   	exitSmog("Command-line argument \"@_\" not recognized.");
  }else{
   exit;
  }

}

sub exitSmog{
	my @msg = @_;
	if (!$noexit){
		print "\n\nERROR: @msg\n\n\tReformatting incomplete...\n\n";
		exit;
	}else{
		print "\n\nWARNING: @msg\n\n\tReformatting incomplete...\n\n";
	}
}

usage() if (@ARGV < 1 || !GetOptions('help|?' => \$help, 'o=s' => \$outputPDB, 'i=s' => \$inputPDB, 'map=s' => \$mapFile, 'default' => \$default ,'warnonly' => \$warnonly, 'renumber' => \$renumber, '<>' => \&usage) or !defined $inputPDB);

if($warnonly){
	$noexit=1;	
	print "\n\n-warnonly selected.  Will not intentionally exit when an error is encountered.\nThis can lead to program instability, which may still result in a crash.\nBe cautious, ignoring errors can lead to unpredictable results. \n ONLY use this option if you are sure the error is harmless.\n\n";
}

if ($renumber){
	print "\n\nNOTE: the flag -renumber was selected. Will assign consecutive residue numbering within each chain.\n\n";
}

if($inputPDB eq ""){
	exitSmog("No input PDB was specified. Use -i to specify your input pdb file.");
}else{
	open(OLDPDB,"$inputPDB") or die "Can't open molecule PDB file.\n";
	print "Will reformatl the PDB file: $inputPDB\n";	
}

if ($default){
	print "\n\n-default selected. Will use the default map file provided for terminal residue names.\n\n";
	if(!exists $ENV{"SMOG_PATH"}){
        exitSmog("Environmental Variable SMOG_PATH not set\n");
	}
	$mapOption = "$ENV{SMOG_PATH}/tools/sbmMap";	
}else{
	if ($mapFile eq ""){
		exitSmog("No map file was provided. Please chose a map file or use the default map settings: -default.");
	}else{
		$mapOption = $mapFile;
		open(MAP,$mapOption) or die "Can't open $mapOption.\n";
	}
}

if ($outputPDB eq ""){
	print "\n\nNo output PDB file name was specified. Will produce a default PDB file name: smog.pdb\n\n";
	open(NEWPDB,">smog.pdb") or die "Can't open the output PDB file. \n";
}else{
	open(NEWPDB,">$outputPDB") or die "Can't open the output PDB file. \n";
	print "New file will be written: $outputPDB\n";
}

## CACHE MAP ##
#Note: Map files has to be in format <residue> <head_name> <tail_name>
open(MAP,$mapOption) || exitSmog("Cannot open Map file\n");
print "Mapping file $mapOption will be used.\n";

while(my $line = <MAP>)
{
  ## SKIP COMMENT LINE ##
  chomp($line);
  if($line =~ /#/){next;}
  my @entries = split(/\s+/,$line);
  #map-->residue-->{head|tail} 
  if($#entries != 2){
   my $count=$#entries+1;
   exitSmog("Looking for 3 fields in $mapOption, but found $count.\n
   				Offending line: $line");
  }
  $map{$entries[0]}{"head"} = $entries[1];
  $map{$entries[0]}{"tail"} = $entries[2];
}

## Returns 1 if a residue is a RNA or DNA, else returns zero. ##
sub isRNA{
	my($resName) = @_;
	my %RNAlist=("U",1,"U5",1,"G",1,"G5",1,"A",1,"A5",1,"C",1,"C5",1,"MIA",1);
	if (exists $RNAlist{$resName}){
			return 1;
	}
	return 0;
}


sub adjustInputFile(){
	
	# Read the molecule PDB into an array (for convinience)
	
	$rows=0;
	while(<OLDPDB>){
		my $line=$_;
		chomp($line);
		$pArr[$rows]=$line;	
		$rows++;
	}
	close OLDPDB;
	
	$isHead = 1;
	$isTail = 0;
	$resInd = 1;
	$atomCount=0;	
	my $k = 0;
	
	my $firstresidue=0;
	my $lastresidue=0;
	## Loops through all PDB rows ##
	while($k<$rows){
		
		chomp($pArr[$k]);
		$pArr[$k] =~ s/^\s+|\s+$//g;
		
		## If end of file: ##
		if ($pArr[$k] =~ m/^END/){
			print NEWPDB "END\n";
			last;
		}
		
		## If TER line: ##
		elsif($pArr[$k] =~ m/^TER/){
			print NEWPDB "TER\n";
			$atomCount=0;
			$isHead = 1;
			$resInd = 1;
			$k++;
		}

		## Exit if there's a BOND line in PDB: ##
		elsif($pArr[$k] =~ /^BOND/){
			exitSmog("Issue at line $k: BOND lines in the input PDB file are not supported by adjustPDB in this Smog version.");
		}

		elsif ($pArr[$k] =~ /^COMMENT/){
			print NEWPDB "$pArr[$k]\n";
			$k++;
			next;
		}
		
		## If atom line: ##
		elsif ($pArr[$k] =~ /^ATOM/ || $pArr[$k] =~ /^HETATM/){

			$firstresidue++;
			my $resNum = substr($pArr[$k],22,5);
			$resNum =~ s/^\s+|\s+$//g;		
			my $newResNum = $resNum;
			if($resNum =~ /^\d+$/ && $lastresidue =~ /^\d+$/){
				if($resNum-$lastresidue > 1 && $firstresidue !=1 && !$renumber){
					exitSmog("Non-consecutive residue numbering detected in original PDB file at residues $lastresidue and  $resNum.");
				}
			}elsif(!$renumber){
				exitSmog("Non-integer residue ID found: $resNum.");
			}
	
			$resName = substr($pArr[$k],17,4);
			$resName =~ s/^\s+|\s+$//g;
			my $altLoc = substr($pArr[$k],16,1);
			if ($altLoc ne " "){
				exitSmog("Issue at line $k: Alternate location indicators are not supported by SMOG.");
			}
			
			$chainName = substr($pArr[$k],21,1);
			
			## Loop through the resdiue ##
			$loopInd = 0;
			while ($newResNum eq $resNum){
				$atomCount++;	
				## Obtain atom information ##
				my $atomName = substr($pArr[$k],12,4);
				$atomName =~ s/^\s+|\s+$//g;
				
				$residue[$loopInd]->{"atomName"} = $atomName;
				$residue[$loopInd]->{"atomIndex"} = $atomCount;
				$residue[$loopInd]->{"x"} = substr($pArr[$k],30,8);   
				$residue[$loopInd]->{"y"} = substr($pArr[$k],38,8);  
				$residue[$loopInd]->{"z"} = substr($pArr[$k],46,8);  
				
				$k++;
				
				## Check if next line is END or TER ##
				if ($k == $rows || $pArr[$k] =~ /^END/ || $pArr[$k] =~ /^TER/){
					$newResNum = "";
					$isTail = 1;
					$firstresidue=0;
				}	
				else{
					$newResNum = substr($pArr[$k],22,5);	#get next residue index
					$newResNum =~ s/^\s+|\s+$//g;		
					if ($newResNum eq $resNum){
						$loopInd++;
					}
				}  	
			}
			$lastresidue=$resNum;

			## Adjust Tail\Head names ##
			if ($isHead){
				if(!exists $map{$resName}{"head"}){exitSmog("Issue with residue $resName - please check the map file to make sure the residue name is defined.");}
				my $newResName = $map{$resName}{"head"};
				$resName = $newResName;
			}
			if ($isTail){
				if (not($prevResTypeRNA)){	#check that it's not an amino-accilated tRNA
				if(!exists $map{$resName}{"tail"}){exitSmog("Issue with residue $resName - please check the map file to make sure the residue name is defined.");}
					my $newResName = $map{$resName}{"tail"};
					$resName = 	$newResName;
				}
			}
			
			for(my $i=0; $i<$loopInd+1; $i++){
					my $aName = $residue[$i]->{"atomName"};
					if ($aName =~ /'/){
						chop($aName);
						$aName .= "*";
					}
					if ($aName eq "OP1"){$aName="O1P"};
					if ($aName eq "OP2"){$aName="O2P"};
					if ($aName eq "OP3"){$aName="O3P"};
					if (($resName eq "ILE" || $resName eq "ILET") &&  $aName eq "CD"){$aName="CD1"};
					my $ind = $residue[$i]->{"atomIndex"};
					my $x = $residue[$i]->{"x"};
					my $y = $residue[$i]->{"y"};
					my $z = $residue[$i]->{"z"};

				    printf NEWPDB "ATOM  %5d %4s %-4s%s%4d    %8.3f%8.3f%8.3f\n",$ind,$aName,$resName,$chainName,$resInd,$x,$y,$z;
			}

			#LEAVE CURRENT RESIDUE AND UPDATE FLAGS#
			$isHead = 0;
			$isTail = 0;
			$resInd++;
			$prevResTypeRNA = isRNA($resName);
			undef @residue; 
		}
		
		## If the line is niether ATOM, BOND, COMMENT, TER or END - exit. ##
		else{
			exitSmog("Issue at line $k:\n$pArr[$k]\n\t is not supported by SMOG.\n\t Lines supported: ATOM, HETATM, TER, BOND, COMMENT, END");
		}
	}
	
	close NEWPDB;
}

adjustInputFile();
print "\n\tAdjustment of PDB is complete.\n\n";
